template<typename T>struct __xcodeml_identity { typedef T t; };
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long __int64_t;
typedef unsigned long __uint64_t;
typedef int __clock_t;
typedef long __critical_t;
typedef double __double_t;
typedef float __float_t;
typedef long __intfptr_t;
typedef long __intptr_t;
typedef long __intmax_t;
typedef int __int_fast8_t;
typedef int __int_fast16_t;
typedef int __int_fast32_t;
typedef long __int_fast64_t;
typedef signed char __int_least8_t;
typedef short __int_least16_t;
typedef int __int_least32_t;
typedef long __int_least64_t;
typedef long __ptrdiff_t;
typedef long __register_t;
typedef long __segsz_t;
typedef unsigned long __size_t;
typedef long __ssize_t;
typedef long __time_t;
typedef unsigned long __uintfptr_t;
typedef unsigned long __uintptr_t;
typedef unsigned long __uintmax_t;
typedef unsigned int __uint_fast8_t;
typedef unsigned int __uint_fast16_t;
typedef unsigned int __uint_fast32_t;
typedef unsigned long __uint_fast64_t;
typedef unsigned char __uint_least8_t;
typedef unsigned short __uint_least16_t;
typedef unsigned int __uint_least32_t;
typedef unsigned long __uint_least64_t;
typedef unsigned long __u_register_t;
typedef unsigned long __vm_offset_t;
typedef unsigned long __vm_paddr_t;
typedef unsigned long __vm_size_t;
typedef int ___wchar_t;
typedef int __blksize_t;
typedef long __blkcnt_t;
typedef int __clockid_t;
typedef unsigned int __fflags_t;
typedef unsigned long __fsblkcnt_t;
typedef unsigned long __fsfilcnt_t;
typedef unsigned int __gid_t;
typedef long __id_t;
typedef unsigned long __ino_t;
typedef long __key_t;
typedef int __lwpid_t;
typedef unsigned short __mode_t;
typedef int __accmode_t;
typedef int __nl_item;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef int __pid_t;
typedef long __rlim_t;
typedef unsigned char __sa_family_t;
typedef unsigned int __socklen_t;
typedef long __suseconds_t;
class __timer;
typedef class::__timer(*__timer_t);
class __mq;
typedef class::__mq(*__mqd_t);
typedef unsigned int __uid_t;
typedef unsigned int __useconds_t;
typedef int __cpuwhich_t;
typedef int __cpulevel_t;
typedef int __cpusetid_t;
typedef long __daddr_t;
typedef int __ct_rune_t;
typedef int __rune_t;
typedef int __wint_t;
class __xcodeml_1{public:long long __max_align1;
public:long double __max_align2;
}
;
typedef class::__xcodeml_1 __max_align_t;
typedef unsigned long __dev_t;
typedef unsigned int __fixpt_t;
union __xcodeml_2{public:char __mbstate8[128];
public:long _mbstateL;
}
;
typedef union::__xcodeml_2 __mbstate_t;
typedef unsigned long __rman_res_t;
typedef class::__va_list_tag __va_list[1];
typedef class::__va_list_tag __gnuc_va_list[1];
unsigned short __bswap16_var(unsigned short _x){return((unsigned short)((_x<<8)|(_x>>8)));
}
unsigned int __bswap32_var(unsigned int _x){"bswap %0""+r"_x;
return _x;
}
unsigned long __bswap64_var(unsigned long _x){"bswap %0""+r"_x;
return _x;
}
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long uint64_t;
unsigned short be16dec(void const(*pp)){unsigned char const(*p)=((unsigned char const(*))pp);
return(((p)[0]<<8)|(p)[1]);
}
unsigned int be32dec(void const(*pp)){unsigned char const(*p)=((unsigned char const(*))pp);
return((((((unsigned int)(p)[0])<<24)|((p)[1]<<16))|((p)[2]<<8))|(p)[3]);
}
unsigned long be64dec(void const(*pp)){unsigned char const(*p)=((unsigned char const(*))pp);
return((((unsigned long)(be32dec(p)))<<32)|(be32dec((p+4))));
}
unsigned short le16dec(void const(*pp)){unsigned char const(*p)=((unsigned char const(*))pp);
return(((p)[1]<<8)|(p)[0]);
}
unsigned int le32dec(void const(*pp)){unsigned char const(*p)=((unsigned char const(*))pp);
return((((((unsigned int)(p)[3])<<24)|((p)[2]<<16))|((p)[1]<<8))|(p)[0]);
}
unsigned long le64dec(void const(*pp)){unsigned char const(*p)=((unsigned char const(*))pp);
return((((unsigned long)(le32dec((p+4))))<<32)|(le32dec(p)));
}
void be16enc(void(*pp),unsigned short u){unsigned char(*p)=((unsigned char(*))pp);
((p)[0]=((u>>8)&0xff));
((p)[1]=(u&0xff));
}
void be32enc(void(*pp),unsigned int u){unsigned char(*p)=((unsigned char(*))pp);
((p)[0]=((u>>24)&0xff));
((p)[1]=((u>>16)&0xff));
((p)[2]=((u>>8)&0xff));
((p)[3]=(u&0xff));
}
void be64enc(void(*pp),unsigned long u){unsigned char(*p)=((unsigned char(*))pp);
(be32enc(p,((unsigned int)(u>>32))));
(be32enc((p+4),((unsigned int)(u&0xffffffffU))));
}
void le16enc(void(*pp),unsigned short u){unsigned char(*p)=((unsigned char(*))pp);
((p)[0]=(u&0xff));
((p)[1]=((u>>8)&0xff));
}
void le32enc(void(*pp),unsigned int u){unsigned char(*p)=((unsigned char(*))pp);
((p)[0]=(u&0xff));
((p)[1]=((u>>8)&0xff));
((p)[2]=((u>>16)&0xff));
((p)[3]=((u>>24)&0xff));
}
void le64enc(void(*pp),unsigned long u){unsigned char(*p)=((unsigned char(*))pp);
(le32enc(p,((unsigned int)(u&0xffffffffU))));
(le32enc((p+4),((unsigned int)(u>>32))));
}
namespace std{namespace __1{}
}
extern"C"{unsigned long ___runetype(int);};
extern"C"{int ___tolower(int);};
extern"C"{int ___toupper(int);};

extern int __mb_sb_limit;
class __xcodeml_3{public:int __min;
public:int __max;
public:int __map;
public:unsigned long(*__types);
}
;
typedef class::__xcodeml_3 _RuneEntry;
class __xcodeml_4{public:int __nranges;
public:class::__xcodeml_3(*__ranges);
}
;
typedef class::__xcodeml_4 _RuneRange;
class __xcodeml_5{public:char __magic[8];
public:char __encoding[32];
public:int(*__sgetrune)(char const(*),unsigned long,char const(*(*)));
public:int(*__sputrune)(int,char(*),unsigned long,char(*(*)));
public:int __invalid_rune;
public:unsigned long __runetype[256];
public:int __maplower[256];
public:int __mapupper[256];
public:class::__xcodeml_4 __runetype_ext;
public:class::__xcodeml_4 __maplower_ext;
public:class::__xcodeml_4 __mapupper_ext;
public:void(*__variable);
public:int __variable_len;
}
;
typedef class::__xcodeml_5 _RuneLocale;
extern class __xcodeml_5 const _DefaultRuneLocale;
extern class __xcodeml_5 const(*_CurrentRuneLocale);
extern class __xcodeml_5 const(*_ThreadRuneLocale);
class __xcodeml_5 const(*__getCurrentRuneLocale()){if(_ThreadRuneLocale){return _ThreadRuneLocale;};
return _CurrentRuneLocale;
}

int __maskrune(int _c,unsigned long _f){return((((_c<0)||(_c>=(1<<8)))?(___runetype(_c)):((__getCurrentRuneLocale())->__runetype)[_c])&_f);
}
int __sbmaskrune(int _c,unsigned long _f){return(((_c<0)||(_c>=__mb_sb_limit))?0:(((__getCurrentRuneLocale())->__runetype)[_c]&_f));
}
int __istype(int _c,unsigned long _f){return(!(!(__maskrune(_c,_f))));
}
int __sbistype(int _c,unsigned long _f){return(!(!(__sbmaskrune(_c,_f))));
}
int __isctype(int _c,unsigned long _f){return(((_c<0)||(_c>=128))?0:(!(!((_DefaultRuneLocale.__runetype)[_c]&_f))));
}
int __toupper(int _c){return(((_c<0)||(_c>=(1<<8)))?(___toupper(_c)):((__getCurrentRuneLocale())->__mapupper)[_c]);
}
int __sbtoupper(int _c){return(((_c<0)||(_c>=__mb_sb_limit))?_c:((__getCurrentRuneLocale())->__mapupper)[_c]);
}
int __tolower(int _c){return(((_c<0)||(_c>=(1<<8)))?(___tolower(_c)):((__getCurrentRuneLocale())->__maplower)[_c]);
}
int __sbtolower(int _c){return(((_c<0)||(_c>=__mb_sb_limit))?_c:((__getCurrentRuneLocale())->__maplower)[_c]);
}
int __wcwidth(int _c){unsigned int _x;
if((_c==0)){return 0;};
(_x=((unsigned int)(__maskrune(_c,(0xe0000000L|0x00040000L)))));
if(((_x&0xe0000000L)!=0)){return((_x&0xe0000000L)>>30);};
return(((_x&0x00040000L)!=0)?1:(-1));
}
typedef union::__xcodeml_2 mbstate_t;
typedef unsigned long size_t;
typedef class::__va_list_tag va_list[1];
typedef int wint_t;
class __sFILE;
typedef class::__sFILE FILE;
class tm;
extern"C"{int btowc(int);};
extern"C"{int fgetwc(class::__sFILE(*));};
extern"C"{wchar_t(*fgetws(wchar_t(*),int,class::__sFILE(*)));};
extern"C"{int fputwc(wchar_t,class::__sFILE(*));};
extern"C"{int fputws(wchar_t const(*),class::__sFILE(*));};
extern"C"{int fwide(class::__sFILE(*),int);};
extern"C"{int fwprintf(class::__sFILE(*),wchar_t const(*),...);};
extern"C"{int fwscanf(class::__sFILE(*),wchar_t const(*),...);};
extern"C"{int getwc(class::__sFILE(*));};
extern"C"{int getwchar();};
extern"C"{unsigned long mbrlen(char const(*),unsigned long,union::__xcodeml_2(*));};
extern"C"{unsigned long mbrtowc(wchar_t(*),char const(*),unsigned long,union::__xcodeml_2(*));};
extern"C"{int mbsinit(union __xcodeml_2 const(*));};
extern"C"{unsigned long mbsrtowcs(wchar_t(*),char const(*(*)),unsigned long,union::__xcodeml_2(*));};
extern"C"{int putwc(wchar_t,class::__sFILE(*));};
extern"C"{int putwchar(wchar_t);};
extern"C"{int swprintf(wchar_t(*),unsigned long n,wchar_t const(*),...);};
extern"C"{int swscanf(wchar_t const(*),wchar_t const(*),...);};
extern"C"{int ungetwc(int,class::__sFILE(*));};
extern"C"{int vfwprintf(class::__sFILE(*),wchar_t const(*),class::__va_list_tag(*));};
extern"C"{int vswprintf(wchar_t(*),unsigned long n,wchar_t const(*),class::__va_list_tag(*));};
extern"C"{int vwprintf(wchar_t const(*),class::__va_list_tag(*));};
extern"C"{unsigned long wcrtomb(char(*),wchar_t,union::__xcodeml_2(*));};
extern"C"{wchar_t(*wcscat(wchar_t(*),wchar_t const(*)));};
extern"C"{wchar_t(*wcschr(wchar_t const(*),wchar_t));};
extern"C"{int wcscmp(wchar_t const(*),wchar_t const(*));};
extern"C"{int wcscoll(wchar_t const(*),wchar_t const(*));};
extern"C"{wchar_t(*wcscpy(wchar_t(*),wchar_t const(*)));};
extern"C"{unsigned long wcscspn(wchar_t const(*),wchar_t const(*));};
extern"C"{unsigned long wcsftime(wchar_t(*),unsigned long,wchar_t const(*),class tm const(*));};
extern"C"{unsigned long wcslen(wchar_t const(*));};
extern"C"{wchar_t(*wcsncat(wchar_t(*),wchar_t const(*),unsigned long));};
extern"C"{int wcsncmp(wchar_t const(*),wchar_t const(*),unsigned long);};
extern"C"{wchar_t(*wcsncpy(wchar_t(*),wchar_t const(*),unsigned long));};
extern"C"{wchar_t(*wcspbrk(wchar_t const(*),wchar_t const(*)));};
extern"C"{wchar_t(*wcsrchr(wchar_t const(*),wchar_t));};
extern"C"{unsigned long wcsrtombs(char(*),wchar_t const(*(*)),unsigned long,union::__xcodeml_2(*));};
extern"C"{unsigned long wcsspn(wchar_t const(*),wchar_t const(*));};
extern"C"{wchar_t(*wcsstr(wchar_t const(*),wchar_t const(*)));};
extern"C"{unsigned long wcsxfrm(wchar_t(*),wchar_t const(*),unsigned long);};
extern"C"{int wctob(int);};
extern"C"{double wcstod(wchar_t const(*),wchar_t(*(*)));};
extern"C"{wchar_t(*wcstok(wchar_t(*),wchar_t const(*),wchar_t(*(*))));};
extern"C"{long wcstol(wchar_t const(*),wchar_t(*(*)),int);};
extern"C"{unsigned long wcstoul(wchar_t const(*),wchar_t(*(*)),int);};
extern"C"{wchar_t(*wmemchr(wchar_t const(*),wchar_t,unsigned long));};
extern"C"{int wmemcmp(wchar_t const(*),wchar_t const(*),unsigned long);};
extern"C"{wchar_t(*wmemcpy(wchar_t(*),wchar_t const(*),unsigned long));};
extern"C"{wchar_t(*wmemmove(wchar_t(*),wchar_t const(*),unsigned long));};
extern"C"{wchar_t(*wmemset(wchar_t(*),wchar_t,unsigned long));};
extern"C"{int wprintf(wchar_t const(*),...);};
extern"C"{int wscanf(wchar_t const(*),...);};
extern class::__sFILE(*__stdinp);
extern class::__sFILE(*__stdoutp);
extern class::__sFILE(*__stderrp);
extern"C"{int vfwscanf(class::__sFILE(*),wchar_t const(*),class::__va_list_tag(*));};
extern"C"{int vswscanf(wchar_t const(*),wchar_t const(*),class::__va_list_tag(*));};
extern"C"{int vwscanf(wchar_t const(*),class::__va_list_tag(*));};
extern"C"{float wcstof(wchar_t const(*),wchar_t(*(*)));};
extern"C"{long double wcstold(wchar_t const(*),wchar_t(*(*)));};
extern"C"{long long wcstoll(wchar_t const(*),wchar_t(*(*)),int);};
extern"C"{unsigned long long wcstoull(wchar_t const(*),wchar_t(*(*)),int);};
extern"C"{int wcswidth(wchar_t const(*),unsigned long);};
extern"C"{int wcwidth(wchar_t);};
extern"C"{unsigned long mbsnrtowcs(wchar_t(*),char const(*(*)),unsigned long,unsigned long,union::__xcodeml_2(*));};
extern"C"{class::__sFILE(*open_wmemstream(wchar_t(*(*)),unsigned long(*)));};
extern"C"{wchar_t(*wcpcpy(wchar_t(*),wchar_t const(*)));};
extern"C"{wchar_t(*wcpncpy(wchar_t(*),wchar_t const(*),unsigned long));};
extern"C"{wchar_t(*wcsdup(wchar_t const(*)));};
extern"C"{int wcscasecmp(wchar_t const(*),wchar_t const(*));};
extern"C"{int wcsncasecmp(wchar_t const(*),wchar_t const(*),unsigned long n);};
extern"C"{unsigned long wcsnlen(wchar_t const(*),unsigned long);};
extern"C"{unsigned long wcsnrtombs(char(*),wchar_t const(*(*)),unsigned long,unsigned long,union::__xcodeml_2(*));};
extern"C"{wchar_t(*fgetwln(class::__sFILE(*),unsigned long(*)));};
extern"C"{unsigned long wcslcat(wchar_t(*),wchar_t const(*),unsigned long);};
extern"C"{unsigned long wcslcpy(wchar_t(*),wchar_t const(*),unsigned long);};
class _xlocale;
typedef class::_xlocale(*locale_t);
extern"C"{int wcscasecmp_l(wchar_t const(*),wchar_t const(*),class::_xlocale(*));};
extern"C"{int wcsncasecmp_l(wchar_t const(*),wchar_t const(*),unsigned long,class::_xlocale(*));};
extern"C"{int wcscoll_l(wchar_t const(*),wchar_t const(*),class::_xlocale(*));};
extern"C"{unsigned long wcsxfrm_l(wchar_t(*),wchar_t const(*),unsigned long,class::_xlocale(*));};

wchar_t(*__libcpp_wcschr(wchar_t const(*__s),wchar_t __c)){return((wchar_t(*))(wcschr(__s,__c)));
}
wchar_t const(*wcschr(wchar_t const(*__s),wchar_t __c)){return(__libcpp_wcschr(__s,__c));
}
wchar_t(*wcschr(wchar_t(*__s),wchar_t __c)){return(__libcpp_wcschr(__s,__c));
}
wchar_t(*__libcpp_wcspbrk(wchar_t const(*__s1),wchar_t const(*__s2))){return((wchar_t(*))(wcspbrk(__s1,__s2)));
}
wchar_t const(*wcspbrk(wchar_t const(*__s1),wchar_t const(*__s2))){return(__libcpp_wcspbrk(__s1,__s2));
}
wchar_t(*wcspbrk(wchar_t(*__s1),wchar_t const(*__s2))){return(__libcpp_wcspbrk(__s1,__s2));
}
wchar_t(*__libcpp_wcsrchr(wchar_t const(*__s),wchar_t __c)){return((wchar_t(*))(wcsrchr(__s,__c)));
}
wchar_t const(*wcsrchr(wchar_t const(*__s),wchar_t __c)){return(__libcpp_wcsrchr(__s,__c));
}
wchar_t(*wcsrchr(wchar_t(*__s),wchar_t __c)){return(__libcpp_wcsrchr(__s,__c));
}
wchar_t(*__libcpp_wcsstr(wchar_t const(*__s1),wchar_t const(*__s2))){return((wchar_t(*))(wcsstr(__s1,__s2)));
}
wchar_t const(*wcsstr(wchar_t const(*__s1),wchar_t const(*__s2))){return(__libcpp_wcsstr(__s1,__s2));
}
wchar_t(*wcsstr(wchar_t(*__s1),wchar_t const(*__s2))){return(__libcpp_wcsstr(__s1,__s2));
}
wchar_t(*__libcpp_wmemchr(wchar_t const(*__s),wchar_t __c,unsigned long __n)){return((wchar_t(*))(wmemchr(__s,__c,__n)));
}
wchar_t const(*wmemchr(wchar_t const(*__s),wchar_t __c,unsigned long __n)){return(__libcpp_wmemchr(__s,__c,__n));
}
wchar_t(*wmemchr(wchar_t(*__s),wchar_t __c,unsigned long __n)){return(__libcpp_wmemchr(__s,__c,__n));
}

namespace std{namespace __1{class ios_base;
template<typename __xcodeml_template_type_0_0>class char_traits;
;
template<>class char_traits;
template<>class char_traits;
template<>class char_traits;
template<>class char_traits;
template<typename __xcodeml_template_type_0_0>class allocator;
template<>class allocator template<>class allocator template<>class allocator<int>{public:
public:typedef unsigned long size_type;
public:typedef long difference_type;
public:typedef int(*pointer);
public:typedef int const(*const_pointer);
public:typedef int&reference;
public:typedef int const&const_reference;
public:typedef int value_type;
public:typedef class::std::__1::integral_constant<bool,1>propagate_on_container_move_assignment;
public:typedef class::std::__1::integral_constant<bool,1>is_always_equal;
public:template<typename __xcodeml_template_type_0_0>class rebind;
;
public:allocator(){}
public:template<typename __xcodeml_template_type_0_0>allocator(allocator<__xcodeml_template_type_0_0>)
template <>allocator(class allocator const&)
public:int(*address(int&__x)const);
public:int const(*address(int const&__x)const);
public:int(*allocate(unsigned long __n,void const(*))){if((__n>(this->max_size()))){(__throw_length_error("allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size"));};
return static_cast<int(*)>((std::__1::__libcpp_allocate((__n*(sizeof(int))),int)));
}
public:void deallocate(int(*__p),unsigned long __n){(std::__1::__libcpp_deallocate(((void(*))__p),(__n*(sizeof(int))),int));
}
public:unsigned long max_size()const{return(((unsigned long)(~0))/(sizeof(int)));
}
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void construct(__xcodeml_template_type_0_0(*__p),void/*__args*/)
template <>void construct(int(*__p),int(*__args)){::new(((void(*))__p))__xcodeml_identity<int>::t((std::__1::forward<int>(__args)));
}
public:void destroy(int(*__p)){(int __p());
}
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class basic_ios;
template<>class basic_ios template<>class basic_ios;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class basic_streambuf;
template<>class basic_streambuf template<>class basic_streambuf;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class basic_istream;
template<>class basic_istream template<>class basic_istream;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class basic_ostream;
template<>class basic_ostream template<>class basic_ostream;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class basic_iostream;
template<>class basic_iostream template<>class basic_iostream;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class basic_stringbuf;
template<>class basic_stringbuf template<>class basic_stringbuf;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class basic_istringstream;
template<>class basic_istringstream template<>class basic_istringstream;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class basic_ostringstream;
template<>class basic_ostringstream template<>class basic_ostringstream;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class basic_stringstream;
template<>class basic_stringstream template<>class basic_stringstream;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class basic_filebuf;
template<>class basic_filebuf template<>class basic_filebuf;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class basic_ifstream;
template<>class basic_ifstream template<>class basic_ifstream;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class basic_ofstream;
template<>class basic_ofstream template<>class basic_ofstream;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class basic_fstream;
template<>class basic_fstream template<>class basic_fstream;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class istreambuf_iterator;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class ostreambuf_iterator;
;
typedef class::std::__1::basic_ios<char,class::std::__1::char_traits<char> >ios;
typedef class::std::__1::basic_ios<wchar_t,class::std::__1::char_traits<wchar_t> >wios;
typedef class::std::__1::basic_streambuf<char,class::std::__1::char_traits<char> >streambuf;
typedef class::std::__1::basic_istream<char,class::std::__1::char_traits<char> >istream;
typedef class::std::__1::basic_ostream<char,class::std::__1::char_traits<char> >ostream;
typedef class::std::__1::basic_iostream<char,class::std::__1::char_traits<char> >iostream;
typedef class::std::__1::basic_stringbuf<char,class::std::__1::char_traits<char>,class::std::__1::allocator<char> >stringbuf;
typedef class::std::__1::basic_istringstream<char,class::std::__1::char_traits<char>,class::std::__1::allocator<char> >istringstream;
typedef class::std::__1::basic_ostringstream<char,class::std::__1::char_traits<char>,class::std::__1::allocator<char> >ostringstream;
typedef class::std::__1::basic_stringstream<char,class::std::__1::char_traits<char>,class::std::__1::allocator<char> >stringstream;
typedef class::std::__1::basic_filebuf<char,class::std::__1::char_traits<char> >filebuf;
typedef class::std::__1::basic_ifstream<char,class::std::__1::char_traits<char> >ifstream;
typedef class::std::__1::basic_ofstream<char,class::std::__1::char_traits<char> >ofstream;
typedef class::std::__1::basic_fstream<char,class::std::__1::char_traits<char> >fstream;
typedef class::std::__1::basic_streambuf<wchar_t,class::std::__1::char_traits<wchar_t> >wstreambuf;
typedef class::std::__1::basic_istream<wchar_t,class::std::__1::char_traits<wchar_t> >wistream;
typedef class::std::__1::basic_ostream<wchar_t,class::std::__1::char_traits<wchar_t> >wostream;
typedef class::std::__1::basic_iostream<wchar_t,class::std::__1::char_traits<wchar_t> >wiostream;
typedef class::std::__1::basic_stringbuf<wchar_t,class::std::__1::char_traits<wchar_t>,class::std::__1::allocator<wchar_t> >wstringbuf;
typedef class::std::__1::basic_istringstream<wchar_t,class::std::__1::char_traits<wchar_t>,class::std::__1::allocator<wchar_t> >wistringstream;
typedef class::std::__1::basic_ostringstream<wchar_t,class::std::__1::char_traits<wchar_t>,class::std::__1::allocator<wchar_t> >wostringstream;
typedef class::std::__1::basic_stringstream<wchar_t,class::std::__1::char_traits<wchar_t>,class::std::__1::allocator<wchar_t> >wstringstream;
typedef class::std::__1::basic_filebuf<wchar_t,class::std::__1::char_traits<wchar_t> >wfilebuf;
typedef class::std::__1::basic_ifstream<wchar_t,class::std::__1::char_traits<wchar_t> >wifstream;
typedef class::std::__1::basic_ofstream<wchar_t,class::std::__1::char_traits<wchar_t> >wofstream;
typedef class::std::__1::basic_fstream<wchar_t,class::std::__1::char_traits<wchar_t> >wfstream;
template<typename __xcodeml_template_type_0_0>class fpos;
template<>class fpos;
typedef class::std::__1::fpos<union::__xcodeml_2>streampos;
typedef class::std::__1::fpos<union::__xcodeml_2>wstreampos;
typedef class::std::__1::fpos<union::__xcodeml_2>u16streampos;
typedef class::std::__1::fpos<union::__xcodeml_2>u32streampos;
typedef long long streamoff;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class basic_string;
template<>class basic_string template<>class basic_string;
typedef class::std::__1::basic_string<char,class::std::__1::char_traits<char>,class::std::__1::allocator<char> >string;
typedef class::std::__1::basic_string<wchar_t,class::std::__1::char_traits<wchar_t>,class::std::__1::allocator<wchar_t> >wstring;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class vector;
template<>class vector<int,class::std::__1::allocator<int> >:private __vector_base<int,class::std::__1::allocator<int> >{private:
private:typedef class::std::__1::__vector_base<int,class::std::__1::allocator<int> >__base;
private:typedef class::std::__1::allocator<int>__default_allocator_type;
public:
public:typedef class::std::__1::vector<int,class::std::__1::allocator<int> >__self;
public:typedef int value_type;
public:typedef class::std::__1::allocator<int>allocator_type;
public:typedef class::std::__1::allocator_traits<class::std::__1::allocator<int> >__alloc_traits;
public:typedef int&reference;
public:typedef int const&const_reference;
public:typedef unsigned long size_type;
public:typedef long difference_type;
public:typedef int(*pointer);
public:typedef int const(*const_pointer);
public:typedef class::std::__1::__wrap_iter<int(*)>iterator;
public:typedef class::std::__1::__wrap_iter<int const(*)>const_iterator;
public:typedef class::std::__1::reverse_iterator<class::std::__1::__wrap_iter<int(*)> >reverse_iterator;
public:typedef class::std::__1::reverse_iterator<class::std::__1::__wrap_iter<int const(*)> >const_reverse_iterator;

/* Ignored a member with no access specifier is_same::value"Allocator::value_type must be same type as value_type";*/

public:vector():__vector_base(){}
public:vector(class allocator const&__a);
public:vector(unsigned long __n);
public:vector(unsigned long __n,class allocator const&__a);
public:vector(unsigned long __n,int const&__x);
public:vector(unsigned long __n,int const&__x,class allocator const&__a);
public:template<typename __xcodeml_template_type_0_0>vector(__xcodeml_template_type_0_0 __first,typename enable_if<expression,__xcodeml_template_type_0_0>::type __last)
public:template<typename __xcodeml_template_type_0_0>vector(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,class allocator const&__a,typename enable_if<expression,void>::type(*))
public:template<typename __xcodeml_template_type_0_0>vector(__xcodeml_template_type_0_0 __first,typename enable_if<expression,__xcodeml_template_type_0_0>::type __last)
public:template<typename __xcodeml_template_type_0_0>vector(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,class allocator const&__a,typename enable_if<expression,void>::type(*))
public:~vector(){(this->__annotate_delete());
}
public:vector(class vector const&__x);
public:vector(class vector const&__x,class allocator const&__a);
public:class::std::__1::vector<int,class::std::__1::allocator<int> >&operator=(class vector const&__x);
public:vector(class::std::initializer_list<int>__il);
public:vector(class::std::initializer_list<int>__il,class allocator const&__a);
public:vector(class::std::__1::vector<int,class::std::__1::allocator<int> >(*__x));
public:vector(class::std::__1::vector<int,class::std::__1::allocator<int> >(*__x),class allocator const&__a);
public:class::std::__1::vector<int,class::std::__1::allocator<int> >&operator=(class::std::__1::vector<int,class::std::__1::allocator<int> >(*__x));
public:class::std::__1::vector<int,class::std::__1::allocator<int> >&operator=(class::std::initializer_list<int>__il);
public:template<typename __xcodeml_template_type_0_0>typename enable_if<expression,void>::type assign(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last)
public:template<typename __xcodeml_template_type_0_0>typename enable_if<expression,void>::type assign(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last)
public:void assign(unsigned long __n,int const&__u);
public:void assign(class::std::initializer_list<int>__il);
public:class::std::__1::allocator<int>get_allocator()const;
public:class::std::__1::__wrap_iter<int(*)>begin();
public:class::std::__1::__wrap_iter<int const(*)>begin()const;
public:class::std::__1::__wrap_iter<int(*)>end();
public:class::std::__1::__wrap_iter<int const(*)>end()const;
public:class::std::__1::reverse_iterator<class::std::__1::__wrap_iter<int(*)> >rbegin();
public:class::std::__1::reverse_iterator<class::std::__1::__wrap_iter<int const(*)> >rbegin()const;
public:class::std::__1::reverse_iterator<class::std::__1::__wrap_iter<int(*)> >rend();
public:class::std::__1::reverse_iterator<class::std::__1::__wrap_iter<int const(*)> >rend()const;
public:class::std::__1::__wrap_iter<int const(*)>cbegin()const;
public:class::std::__1::__wrap_iter<int const(*)>cend()const;
public:class::std::__1::reverse_iterator<class::std::__1::__wrap_iter<int const(*)> >crbegin()const;
public:class::std::__1::reverse_iterator<class::std::__1::__wrap_iter<int const(*)> >crend()const;
public:unsigned long size()const{return static_cast<unsigned long>((this->__end_-this->__begin_));
}
public:unsigned long capacity()const{return(this->__vector_base::capacity());
}
public:bool empty()const;
public:unsigned long max_size()const{return(std::__1::min<unsigned long>((allocator_traits::max_size((this->__alloc()))),(numeric_limits::max())));
}
public:void reserve(unsigned long __n);
public:void shrink_to_fit();
public:int&operator[](unsigned long __n){((void)0);
return(this->__begin_)[__n];
}
public:int const&operator[](unsigned long __n)const;
public:int&at(unsigned long __n);
public:int const&at(unsigned long __n)const;
public:int&front();
public:int const&front()const;
public:int&back();
public:int const&back()const;
public:int(*data());
public:int const(*data()const){return(std::__1::__to_raw_pointer(this->__begin_));
}
public:template<typename __xcodeml_template_type_0_0>void __emplace_back(__xcodeml_template_type_0_0(*__arg))
public:void push_back(int const&__x);
public:void push_back(int(*__x)){if((this->__end_<(this->__end_cap()))){{class::std::__1::vector<int,class::std::__1::allocator<int> >::__RAII_IncreaseAnnotator __annotator((*this),1);
(allocator_traits::construct((this->__alloc()),(std::__1::__to_raw_pointer(this->__end_)),(std::__1::move(__x))));
(__annotator.__done());
(++this->__end_);
};}else{(this->__push_back_slow_path((std::__1::move(__x))));};
}
public:template<typename __xcodeml_template_type_0_0>void emplace_back(void/*__args*/)
public:void pop_back();
public:class::std::__1::__wrap_iter<int(*)>insert(class::std::__1::__wrap_iter<int const(*)>__position,int const&__x);
public:class::std::__1::__wrap_iter<int(*)>insert(class::std::__1::__wrap_iter<int const(*)>__position,int(*__x));
public:template<typename __xcodeml_template_type_0_0>class::std::__1::__wrap_iter<int(*)>emplace(class::std::__1::__wrap_iter<int const(*)>__position,void/*__args*/)
public:class::std::__1::__wrap_iter<int(*)>insert(class::std::__1::__wrap_iter<int const(*)>__position,unsigned long __n,int const&__x);
public:template<typename __xcodeml_template_type_0_0>typename enable_if<expression,class::std::__1::__wrap_iter<int(*)> >::type insert(class::std::__1::__wrap_iter<int const(*)>__position,__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last)
public:template<typename __xcodeml_template_type_0_0>typename enable_if<expression,class::std::__1::__wrap_iter<int(*)> >::type insert(class::std::__1::__wrap_iter<int const(*)>__position,__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last)
public:class::std::__1::__wrap_iter<int(*)>insert(class::std::__1::__wrap_iter<int const(*)>__position,class::std::initializer_list<int>__il);
public:class::std::__1::__wrap_iter<int(*)>erase(class::std::__1::__wrap_iter<int const(*)>__position);
public:class::std::__1::__wrap_iter<int(*)>erase(class::std::__1::__wrap_iter<int const(*)>__first,class::std::__1::__wrap_iter<int const(*)>__last);
public:void clear();
public:void resize(unsigned long __sz);
public:void resize(unsigned long __sz,int const&__x);
public:void swap(class::std::__1::vector<int,class::std::__1::allocator<int> >&);
public:bool __invariants()const;
private:
private:void __invalidate_all_iterators(){}
private:void __invalidate_iterators_past(int(*__new_last));
private:void __vallocate(unsigned long __n);
private:void __vdeallocate();
private:unsigned long __recommend(unsigned long __new_size)const{unsigned long const __ms=(this->max_size());
if((__new_size>__ms)){(this->__throw_length_error());};
unsigned long const __cap=(this->capacity());
if((__cap>=(__ms/2))){return __ms;};
return(std::__1::max<unsigned long>((2*__cap),__new_size));
}
private:void __construct_at_end(unsigned long __n);
private:void __construct_at_end(unsigned long __n,int const&__x);
private:template<typename __xcodeml_template_type_0_0>typename enable_if<expression,void>::type __construct_at_end(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,unsigned long __n)
private:void __append(unsigned long __n);
private:void __append(unsigned long __n,int const&__x);
private:class::std::__1::__wrap_iter<int(*)>__make_iter(int(*__p));
private:class::std::__1::__wrap_iter<int const(*)>__make_iter(int const(*__p))const;
private:void __swap_out_circular_buffer(class::std::__1::__split_buffer<int,class::std::__1::allocator<int>&>&__v){(this->__annotate_delete());
(allocator_traits::__construct_backward((this->__alloc()),this->__begin_,this->__end_,__v.__begin_));
(std::__1::swap(this->__begin_,__v.__begin_));
(std::__1::swap(this->__end_,__v.__end_));
(std::__1::swap((this->__end_cap()),(__v.__end_cap())));
(__v.__first_=__v.__begin_);
(this->__annotate_new((this->size())));
(this->__invalidate_all_iterators());
}
private:int(*__swap_out_circular_buffer(class::std::__1::__split_buffer<int,class::std::__1::allocator<int>&>&__v,int(*__p)));
private:void __move_range(int(*__from_s),int(*__from_e),int(*__to));
private:void __move_assign(class::std::__1::vector<int,class::std::__1::allocator<int> >&__c,class::std::__1::integral_constant<bool,1>);
private:void __move_assign(class::std::__1::vector<int,class::std::__1::allocator<int> >&__c,class::std::__1::integral_constant<bool,0>);
private:void __destruct_at_end(int(*__new_last));
private:template<typename __xcodeml_template_type_0_0>void __push_back_slow_path(__xcodeml_template_type_0_0(*__x))
template <>void __push_back_slow_path(int(*__x)){class::std::__1::allocator<int>&__a=(this->__alloc());
class::std::__1::__split_buffer<int,class::std::__1::allocator<int>&>__v((this->__recommend(((this->size())+1))),(this->size()),__a);
(allocator_traits::construct(__a,(std::__1::__to_raw_pointer(__v.__end_)),(std::__1::forward<int>(__x))));
(__v.__end_++);
(this->__swap_out_circular_buffer(__v));
}
private:template<typename __xcodeml_template_type_0_0>void __emplace_back_slow_path(void/*__args*/)
private:void __annotate_contiguous_container(void const(*),void const(*),void const(*),void const(*))const{}
private:void __annotate_new(unsigned long __current_size)const{(this->__annotate_contiguous_container((this->data()),((this->data())+(this->capacity())),((this->data())+(this->capacity())),((this->data())+__current_size)));
}
private:void __annotate_delete()const{(this->__annotate_contiguous_container((this->data()),((this->data())+(this->capacity())),((this->data())+(this->size())),((this->data())+(this->capacity()))));
}
private:void __annotate_increase(unsigned long __n)const;
private:void __annotate_shrink(unsigned long __old_size)const;
private:class __RAII_IncreaseAnnotator{public:__RAII_IncreaseAnnotator(class vector const&,unsigned long){}
public:void __done(){}
}
;
}
;
}
}
typedef long ptrdiff_t;
typedef int rune_t;
typedef class::__xcodeml_1 max_align_t;
typedef unsigned long rsize_t;
namespace std{typedef nullptr_t nullptr_t;
}
namespace std{namespace __1{::;
::;
::;
}
}
namespace std{namespace __1{template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class pair;
template<>class pair<unsigned long,unsigned long>:private __non_trivially_copyable_base<unsigned long,unsigned long>{public:typedef unsigned long first_type;
public:typedef unsigned long second_type;
public:unsigned long first;
public:unsigned long second;
public:pair(class pair const&);
public:pair(class::std::__1::pair<unsigned long,unsigned long>(*)):__non_trivially_copyable_base(),first(),second(){}
public:template<bool _Val>using _EnableB=typename enable_if<expression,bool>::type;
public:class _CheckArgs{public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>static bool __enable_default()
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>static bool __enable_explicit()
static template <>bool __enable_explicit(){return((is_constructible::value&&is_constructible::value)&&((!is_convertible::value)||(!is_convertible::value)));
}
static template <>bool __enable_explicit(){return((is_constructible::value&&is_constructible::value)&&((!is_convertible::value)||(!is_convertible::value)));
}
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>static bool __enable_implicit()
static template <>bool __enable_implicit(){return(((is_constructible::value&&is_constructible::value)&&is_convertible::value)&&is_convertible::value);
}
static template <>bool __enable_implicit(){return(((is_constructible::value&&is_constructible::value)&&is_convertible::value)&&is_convertible::value);
}
}
;
public:template<bool _MaybeEnable>using _CheckArgsDep=typename conditional<expression,class::std::__1::pair<unsigned long,unsigned long>::_CheckArgs,class::std::__1::__check_tuple_constructor_fail>::type;
public:class _CheckTupleLikeConstructor;
public:template<typename __xcodeml_template_type_0_0>using _CheckTLC=typename conditional<expression,class::std::__1::pair<unsigned long,unsigned long>::_CheckTupleLikeConstructor,class::std::__1::__check_tuple_constructor_fail>::type;
public:template<bool _Dummy=true,typename enable_if<expression,bool>::type=false>pair()
public:template<bool _Dummy=true,typename enable_if<expression,bool>::type=false>pair(unsigned long const&__t1,unsigned long const&__t2)
public:template<bool _Dummy=true,typename enable_if<expression,bool>::type=false>pair(unsigned long const&__t1,unsigned long const&__t2)
template <>pair(unsigned long const&__t1,unsigned long const&__t2)
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename enable_if<expression,bool>::type=false>pair(__xcodeml_template_type_0_0(*__u1),__xcodeml_template_type_0_1(*__u2))
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename enable_if<expression,bool>::type=false>pair(__xcodeml_template_type_0_0(*__u1),__xcodeml_template_type_0_1(*__u2))
template <>pair(unsigned long(*__u1),unsigned long(*__u2)):__non_trivially_copyable_base(),first((std::__1::forward<unsigned long>(__u1))),second((std::__1::forward<unsigned long>(__u2))){}
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename enable_if<expression,bool>::type=false>pair(pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>)
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename enable_if<expression,bool>::type=false>pair(pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>)
template <>pair(class pair const&__p)
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename enable_if<expression,bool>::type=false>pair(pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>)
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename enable_if<expression,bool>::type=false>pair(pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>)
template <>pair(class::std::__1::pair<unsigned long,unsigned long>(*__p))
public:template<typename __xcodeml_template_type_0_0,typename enable_if<expression,bool>::type=false>pair(__xcodeml_template_type_0_0(*__p))
public:template<typename __xcodeml_template_type_0_0,typename enable_if<expression,bool>::type=false>pair(__xcodeml_template_type_0_0(*__p))
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>pair(class::std::__1::piecewise_construct_t __pc,tuple<...>,tuple<...>)
public:class::std::__1::pair<unsigned long,unsigned long>&operator=(class pair const&__p);
public:class::std::__1::pair<unsigned long,unsigned long>&operator=(class::std::__1::pair<unsigned long,unsigned long>(*__p)){(this->first=(std::__1::forward<unsigned long>(__p.first)));
(this->second=(std::__1::forward<unsigned long>(__p.second)));
return(*this);
}
public:template<typename __xcodeml_template_type_0_0,typename enable_if<expression,bool>::type=false>class::std::__1::pair<unsigned long,unsigned long>&operator=(__xcodeml_template_type_0_0(*__p))
public:void swap(class::std::__1::pair<unsigned long,unsigned long>&__p);
private:
private:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,unsigned long _I1,unsigned long _I2>pair(class::std::__1::piecewise_construct_t,tuple<...>,tuple<...>,__tuple_indices<...>,__tuple_indices<...>)
}
;
template<typename __xcodeml_template_type_0_0>class reference_wrapper;
;
template<typename __xcodeml_template_type_0_0>class hash;
;
template<typename __xcodeml_template_type_0_0,__xcodeml_template_type_0_0 __v>class integral_constant{public:constexpr static __xcodeml_template_type_0_0 const value=__v;
public:typedef __xcodeml_template_type_0_0 value_type;
public:typedef class integral_constant type;
public:operator __xcodeml_template_type_0_0()const{return value;
}
public:__xcodeml_template_type_0_0 operator()()const{return value;
}
}
;
template<>class integral_constant<bool,1>{public:constexpr static bool const value=true;
public:typedef bool value_type;
public:typedef class::std::__1::integral_constant<bool,1>type;
public:operator bool()const;
public:bool operator()()const;
}
template<>class integral_constant<bool,0>{public:constexpr static bool const value=false;
public:typedef bool value_type;
public:typedef class::std::__1::integral_constant<bool,0>type;
public:operator bool()const;
public:bool operator()()const;
}
template<>class integral_constant<unsigned long,0>{public:constexpr static unsigned long const value=__v;
public:typedef unsigned long value_type;
public:typedef class::std::__1::integral_constant<unsigned long,0>type;
public:operator unsigned long()const;
public:unsigned long operator()()const;
}
template<>class integral_constant<unsigned long,2>{public:constexpr static unsigned long const value=__v;
public:typedef unsigned long value_type;
public:typedef class::std::__1::integral_constant<unsigned long,2>type;
public:operator unsigned long()const;
public:unsigned long operator()()const;
}
template<>class integral_constant<unsigned long,9223372036854775808>{public:constexpr static unsigned long const value=__v;
public:typedef unsigned long value_type;
public:typedef class::std::__1::integral_constant<unsigned long,9223372036854775808>type;
public:operator unsigned long()const;
public:unsigned long operator()()const;
}
template<>class integral_constant<int,0>{public:constexpr static int const value=__v;
public:typedef int value_type;
public:typedef class::std::__1::integral_constant<int,0>type;
public:operator int()const;
public:int operator()()const;
}
template<>class integral_constant<int,1>{public:constexpr static int const value=__v;
public:typedef int value_type;
public:typedef class::std::__1::integral_constant<int,1>type;
public:operator int()const;
public:int operator()()const;
}
template<>class integral_constant<int,2>{public:constexpr static int const value=__v;
public:typedef int value_type;
public:typedef class::std::__1::integral_constant<int,2>type;
public:operator int()const;
public:int operator()()const;
}
template<>class integral_constant<unsigned long,8>{public:constexpr static unsigned long const value=__v;
public:typedef unsigned long value_type;
public:typedef class::std::__1::integral_constant<unsigned long,8>type;
public:operator unsigned long()const;
public:unsigned long operator()()const;
}
template<>class integral_constant<unsigned long,16>{public:constexpr static unsigned long const value=__v;
public:typedef unsigned long value_type;
public:typedef class::std::__1::integral_constant<unsigned long,16>type;
public:operator unsigned long()const;
public:unsigned long operator()()const;
}
;
constexpr __xcodeml_template_type_0_0 const integral_constant::value;
typedef class::std::__1::integral_constant<bool,1>true_type;
typedef class::std::__1::integral_constant<bool,0>false_type;
template<bool _Val>using _BoolConstant=integral_constant<bool,expression>;
template<bool>class _MetaBase;
;
template<>class _MetaBase<1>{public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>using _SelectImpl=__xcodeml_template_type_0_0;
public:template<typename __xcodeml_template_type_0_2>using _SelectApplyImpl=<...>;
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>using _FirstImpl=__xcodeml_template_type_0_0;
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>using _SecondImpl=__xcodeml_template_type_0_1;
public:template<typename __xcodeml_template_type_0_0>using _EnableIfImpl=__xcodeml_template_type_0_0;
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>using _OrImpl=void/**/;
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>using _AndImpl=void/**/;
}
;
template<>class _MetaBase<0>{public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>using _SelectImpl=__xcodeml_template_type_0_1;
public:template<typename __xcodeml_template_type_0_2>using _SelectApplyImpl=<...>;
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>using _OrImpl=__xcodeml_template_type_0_0;
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>using _AndImpl=__xcodeml_template_type_0_0;
}
;
template<bool _Cond,typename __xcodeml_template_type_0_1>using _EnableIf=void/**/;
template<bool _Cond,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>using _If=void/**/;
template<typename __xcodeml_template_type_0_0>using _Or=void/**/;
template<typename __xcodeml_template_type_0_0>using _And=void/**/;
template<typename __xcodeml_template_type_0_0>class _Not:public integral_constant<bool,expression>{}
;
;
template<typename __xcodeml_template_type_0_0>using _FirstType=void/**/;
template<typename __xcodeml_template_type_0_0>using _SecondType=void/**/;
template<typename __xcodeml_template_type_0_1>class _Lazy:public<...>{}
;
;
template<typename __xcodeml_template_type_0_1>class::std::__1::integral_constant<bool,1>__sfinae_test_impl(int)
template<typename __xcodeml_template_type_0_1>class::std::__1::integral_constant<bool,0>__sfinae_test_impl(...)
template<typename __xcodeml_template_type_0_1>using _IsValidExpansion=decltype ();
template<typename __xcodeml_template_type_0_0>class __void_t{public:typedef void type;
}
;
template<>class __void_t<int(*)>{public:typedef void type;
}
template<>class __void_t<int const(*)>{public:typedef void type;
}
template<>class __void_t<long>{public:typedef void type;
}
template<>class __void_t<unsigned long>{public:typedef void type;
}
template<>class __void_t<class::std::__1::integral_constant<bool,1> >{public:typedef void type;
}
;
template<typename __xcodeml_template_type_0_0>class __identity{public:typedef __xcodeml_template_type_0_0 type;
}
;
template<>class __identity<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>{public:typedef class::std::__1::__builtin_new_allocator::__builtin_new_deleter type;
}
;
template<typename __xcodeml_template_type_0_0,bool>class __dependent_type:public __xcodeml_template_type_0_0{}
;
template<>class __dependent_type<class::std::__1::__unique_ptr_deleter_sfinae<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>,1>:public __unique_ptr_deleter_sfinae<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>{}
template<>class __dependent_type<class::std::__1::__identity<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>,1>:public __identity<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>{}
;
template<bool _Bp,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class conditional{public:typedef __xcodeml_template_type_0_1 type;
}
;
template<>class conditional<0,class __compressed_pair_elem const(*),class::std::__1::__compressed_pair_elem<void(*),0,0> >{public:typedef class::std::__1::__compressed_pair_elem<void(*),0,0>type;
}
template<>class conditional<0,class __compressed_pair_elem const(*),class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0> >{public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0>type;
}
template<>class conditional<0,class::std::__1::__compressed_pair_elem<void(*),0,0>(*),class::std::__1::__compressed_pair_elem<void(*),0,0> >{public:typedef class::std::__1::__compressed_pair_elem<void(*),0,0>type;
}
template<>class conditional<0,class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0>(*),class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0> >{public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0>type;
}
template<>class conditional<0,class __compressed_pair const(*),class::std::__1::__compressed_pair<void(*),class::std::__1::__builtin_new_allocator::__builtin_new_deleter> >{public:typedef class::std::__1::__compressed_pair<void(*),class::std::__1::__builtin_new_allocator::__builtin_new_deleter>type;
}
template<>class conditional<0,class::std::__1::pointer_traits<int(*)>::__nat,int>{public:typedef int type;
}
template<>class conditional<1,class::std::__1::pair<unsigned long,unsigned long>,class::std::__1::__nat>{public:typedef class::std::__1::pair<unsigned long,unsigned long>type;
}
template<>class conditional<0,class::std::__1::pair<unsigned long,unsigned long>(*),class::std::__1::pair<unsigned long,unsigned long> >{public:typedef class::std::__1::pair<unsigned long,unsigned long>type;
}
template<>class conditional<0,class::std::__1::pair<unsigned long,unsigned long>::_CheckTupleLikeConstructor,class::std::__1::__check_tuple_constructor_fail>{public:typedef class::std::__1::__check_tuple_constructor_fail type;
}
template<>class conditional<1,class::std::__1::pair<unsigned long,unsigned long>::_CheckArgs,class::std::__1::__check_tuple_constructor_fail>{public:typedef class::std::__1::pair<unsigned long,unsigned long>::_CheckArgs type;
}
template<>class conditional<0,void(*(*)),void(*)>{public:typedef void(*type);
}
template<>class conditional<0,class::std::__1::__builtin_new_allocator::__builtin_new_deleter(*),class::std::__1::__builtin_new_allocator::__builtin_new_deleter>{public:typedef class::std::__1::__builtin_new_allocator::__builtin_new_deleter type;
}
template<>class conditional<0,class __compressed_pair_elem const(*),class::std::__1::__compressed_pair_elem<int(*),0,0> >{public:typedef class::std::__1::__compressed_pair_elem<int(*),0,0>type;
}
template<>class conditional<0,class __compressed_pair_elem const(*),class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1> >{public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1>type;
}
template<>class conditional<0,class::std::__1::__compressed_pair_elem<int(*),0,0>(*),class::std::__1::__compressed_pair_elem<int(*),0,0> >{public:typedef class::std::__1::__compressed_pair_elem<int(*),0,0>type;
}
template<>class conditional<0,class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1>(*),class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1> >{public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1>type;
}
template<>class conditional<0,class __compressed_pair const(*),class::std::__1::__compressed_pair<int(*),class::std::__1::allocator<int> > >{public:typedef class::std::__1::__compressed_pair<int(*),class::std::__1::allocator<int> >type;
}
template<>class conditional<0,nullptr_t(*),nullptr_t>{public:typedef nullptr_t type;
}
template<>class conditional<0,class __compressed_pair_elem const(*),class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0> >{public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0>type;
}
template<>class conditional<0,class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0>(*),class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0> >{public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0>type;
}
template<>class conditional<0,class::std::__1::allocator<int>(*),class::std::__1::allocator<int> >{public:typedef class::std::__1::allocator<int>type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class conditional<0,__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>{public:typedef __xcodeml_template_type_0_1 type;
}
;
template<bool _Bp,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>using conditional_t=typename conditional<expression,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2>::type;
template<bool,typename __xcodeml_template_type_0_1>class enable_if{}
;
template<>class enable_if<0,double>{}
template<>class enable_if<0,int>{}
template<>class enable_if<0,long long>{}
template<>class enable_if<0,long>{}
template<>class enable_if<0,void>{}
template<>class enable_if<0,bool>{}
template<>class enable_if<1,void>{public:typedef void type;
}
template<>class enable_if<1,bool>{public:typedef bool type;
}
;
template<typename __xcodeml_template_type_0_0>class enable_if<1,__xcodeml_template_type_0_0>{public:typedef __xcodeml_template_type_0_0 type;
}
;
template<bool _Bp,typename __xcodeml_template_type_0_1>using enable_if_t=typename enable_if<expression,__xcodeml_template_type_0_1>::type;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class is_same:public integral_constant<bool,0>{}
;
template<>class is_same<unsigned int,unsigned int>:public integral_constant<bool,1>{}
template<>class is_same<void(*),class::std::__1::__builtin_new_allocator::__builtin_new_deleter>:public integral_constant<bool,0>{}
template<>class is_same<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,class::std::__1::default_delete<void> >:public integral_constant<bool,0>{}
template<>class is_same<class::std::__1::__compressed_pair_elem<void(*),0,0>,class::std::__1::__compressed_pair_elem<void(*),0,0> >:public integral_constant<bool,1>{}
template<>class is_same<class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0>,class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0> >:public integral_constant<bool,1>{}
template<>class is_same<class::std::__1::__compressed_pair<void(*),class::std::__1::__builtin_new_allocator::__builtin_new_deleter>,class::std::__1::__compressed_pair<void(*),class::std::__1::__builtin_new_allocator::__builtin_new_deleter> >:public integral_constant<bool,1>{}
template<>class is_same<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,class::std::__1::__builtin_new_allocator::__builtin_new_deleter>:public integral_constant<bool,1>{}
template<>class is_same<int(*),class::std::__1::allocator<int> >:public integral_constant<bool,0>{}
template<>class is_same<int,int>:public integral_constant<bool,1>{}
template<>class is_same<class::std::__1::pair<unsigned long,unsigned long>,class::std::__1::pair<unsigned long,unsigned long> >:public integral_constant<bool,1>{}
template<>class is_same<class::std::__1::__compressed_pair_elem<void(*),0,0>,void(*)>:public integral_constant<bool,0>{}
template<>class is_same<class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0>,class::std::__1::__builtin_new_allocator::__builtin_new_deleter>:public integral_constant<bool,0>{}
template<>class is_same<class::std::__1::__compressed_pair_elem<int(*),0,0>,class::std::__1::__compressed_pair_elem<int(*),0,0> >:public integral_constant<bool,1>{}
template<>class is_same<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1>,class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1> >:public integral_constant<bool,1>{}
template<>class is_same<class::std::__1::__compressed_pair<int(*),class::std::__1::allocator<int> >,class::std::__1::__compressed_pair<int(*),class::std::__1::allocator<int> > >:public integral_constant<bool,1>{}
template<>class is_same<nullptr_t,class::std::__1::__compressed_pair<int(*),class::std::__1::allocator<int> > >:public integral_constant<bool,0>{}
template<>class is_same<class::std::__1::__compressed_pair_elem<int(*),0,0>,nullptr_t>:public integral_constant<bool,0>{}
template<>class is_same<class::std::__1::integral_constant<bool,1>,class::std::__1::integral_constant<bool,1> >:public integral_constant<bool,1>{}
template<>class is_same<int(*),class::std::__1::allocator<int>&>:public integral_constant<bool,0>{}
template<>class is_same<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0>,class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0> >:public integral_constant<bool,1>{}
template<>class is_same<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0>,class::std::__1::allocator<int> >:public integral_constant<bool,0>{}
;
template<typename __xcodeml_template_type_0_0>class is_same<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>using _IsSame=integral_constant<bool,expression>;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>using _IsNotSame=integral_constant<bool,expression>;
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0(*addressof(__xcodeml_template_type_0_0&__x)){return(__builtin_addressof(__x));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0(*addressof(__xcodeml_template_type_0_0 const(*)))
class __two{public:char __lx[2];
}
;
template<typename __xcodeml_template_type_0_0>class is_const:public integral_constant<bool,0>{}
;
template<>class is_const<unsigned long>:public integral_constant<bool,0>{}
;
template<typename __xcodeml_template_type_0_0>class is_const<__xcodeml_template_type_0_0 const>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class is_volatile:public integral_constant<bool,0>{}
;
;
template<typename __xcodeml_template_type_0_0>class is_volatile<__xcodeml_template_type_0_0 volatile>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class remove_const{public:typedef __xcodeml_template_type_0_0 type;
}
;
template<>class remove_const<unsigned long long>{public:typedef unsigned long long type;
}
template<>class remove_const<unsigned int>{public:typedef unsigned int type;
}
template<>class remove_const<unsigned long>{public:typedef unsigned long type;
}
template<>class remove_const<double>{public:typedef double type;
}
template<>class remove_const<class __compressed_pair_elem const>{public:typedef class::std::__1::__compressed_pair_elem<void(*),0,0>type;
}
template<>class remove_const<class __compressed_pair_elem const>{public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0>type;
}
template<>class remove_const<class::std::__1::__compressed_pair_elem<void(*),0,0> >{public:typedef class::std::__1::__compressed_pair_elem<void(*),0,0>type;
}
template<>class remove_const<class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0> >{public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0>type;
}
template<>class remove_const<class __compressed_pair const>{public:typedef class::std::__1::__compressed_pair<void(*),class::std::__1::__builtin_new_allocator::__builtin_new_deleter>type;
}
template<>class remove_const<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>{public:typedef class::std::__1::__builtin_new_allocator::__builtin_new_deleter type;
}
template<>class remove_const<long>{public:typedef long type;
}
template<>class remove_const<int>{public:typedef int type;
}
template<>class remove_const<unsigned long&>{public:typedef unsigned long&type;
}
template<>class remove_const<unsigned long const&>{public:typedef unsigned long const&type;
}
template<>class remove_const<unsigned long(*)>{public:typedef unsigned long(*type);
}
template<>class remove_const<class::std::__1::pair<unsigned long,unsigned long> >{public:typedef class::std::__1::pair<unsigned long,unsigned long>type;
}
template<>class remove_const<void(*)>{public:typedef void(*type);
}
template<>class remove_const<class __compressed_pair_elem const>{public:typedef class::std::__1::__compressed_pair_elem<int(*),0,0>type;
}
template<>class remove_const<class __compressed_pair_elem const>{public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1>type;
}
template<>class remove_const<class::std::__1::__compressed_pair_elem<int(*),0,0> >{public:typedef class::std::__1::__compressed_pair_elem<int(*),0,0>type;
}
template<>class remove_const<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1> >{public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1>type;
}
template<>class remove_const<class __compressed_pair const>{public:typedef class::std::__1::__compressed_pair<int(*),class::std::__1::allocator<int> >type;
}
template<>class remove_const<nullptr_t>{public:typedef nullptr_t type;
}
template<>class remove_const<class __compressed_pair_elem const>{public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0>type;
}
template<>class remove_const<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0> >{public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0>type;
}
template<>class remove_const<class::std::__1::allocator<int> >{public:typedef class::std::__1::allocator<int>type;
}
template<>class remove_const<int(*&)>{public:typedef int(*&type);
}
template<>class remove_const<int(*(*))>{public:typedef int(*(*type));
}
;
template<typename __xcodeml_template_type_0_0>class remove_const<__xcodeml_template_type_0_0 const>{public:typedef __xcodeml_template_type_0_0 type;
}
;
template<typename __xcodeml_template_type_0_0>using remove_const_t=typename remove_const<__xcodeml_template_type_0_0>::type;
template<typename __xcodeml_template_type_0_0>class remove_volatile{public:typedef __xcodeml_template_type_0_0 type;
}
;
template<>class remove_volatile<unsigned long long>{public:typedef unsigned long long type;
}
template<>class remove_volatile<unsigned int>{public:typedef unsigned int type;
}
template<>class remove_volatile<unsigned long>{public:typedef unsigned long type;
}
template<>class remove_volatile<double>{public:typedef double type;
}
template<>class remove_volatile<class::std::__1::__compressed_pair_elem<void(*),0,0> >{public:typedef class::std::__1::__compressed_pair_elem<void(*),0,0>type;
}
template<>class remove_volatile<class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0> >{public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0>type;
}
template<>class remove_volatile<class::std::__1::__compressed_pair<void(*),class::std::__1::__builtin_new_allocator::__builtin_new_deleter> >{public:typedef class::std::__1::__compressed_pair<void(*),class::std::__1::__builtin_new_allocator::__builtin_new_deleter>type;
}
template<>class remove_volatile<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>{public:typedef class::std::__1::__builtin_new_allocator::__builtin_new_deleter type;
}
template<>class remove_volatile<long>{public:typedef long type;
}
template<>class remove_volatile<int>{public:typedef int type;
}
template<>class remove_volatile<unsigned long&>{public:typedef unsigned long&type;
}
template<>class remove_volatile<unsigned long const&>{public:typedef unsigned long const&type;
}
template<>class remove_volatile<unsigned long(*)>{public:typedef unsigned long(*type);
}
template<>class remove_volatile<class::std::__1::pair<unsigned long,unsigned long> >{public:typedef class::std::__1::pair<unsigned long,unsigned long>type;
}
template<>class remove_volatile<void(*)>{public:typedef void(*type);
}
template<>class remove_volatile<class::std::__1::__compressed_pair_elem<int(*),0,0> >{public:typedef class::std::__1::__compressed_pair_elem<int(*),0,0>type;
}
template<>class remove_volatile<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1> >{public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1>type;
}
template<>class remove_volatile<class::std::__1::__compressed_pair<int(*),class::std::__1::allocator<int> > >{public:typedef class::std::__1::__compressed_pair<int(*),class::std::__1::allocator<int> >type;
}
template<>class remove_volatile<nullptr_t>{public:typedef nullptr_t type;
}
template<>class remove_volatile<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0> >{public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0>type;
}
template<>class remove_volatile<class::std::__1::allocator<int> >{public:typedef class::std::__1::allocator<int>type;
}
template<>class remove_volatile<int(*&)>{public:typedef int(*&type);
}
template<>class remove_volatile<int(*(*))>{public:typedef int(*(*type));
}
;
template<typename __xcodeml_template_type_0_0>class remove_volatile<__xcodeml_template_type_0_0 volatile>{public:typedef __xcodeml_template_type_0_0 type;
}
;
template<typename __xcodeml_template_type_0_0>using remove_volatile_t=typename remove_volatile<__xcodeml_template_type_0_0>::type;
template<typename __xcodeml_template_type_0_0>class remove_cv{public:typedef typename remove_volatile<typename remove_const<__xcodeml_template_type_0_0>::type>::type type;
}
;
template<>class remove_cv<unsigned long long>{public:typedef unsigned long long type;
}
template<>class remove_cv<unsigned int>{public:typedef unsigned int type;
}
template<>class remove_cv<unsigned long>{public:typedef unsigned long type;
}
template<>class remove_cv<double>{public:typedef double type;
}
template<>class remove_cv<class __compressed_pair_elem const>{public:typedef class::std::__1::__compressed_pair_elem<void(*),0,0>type;
}
template<>class remove_cv<class __compressed_pair_elem const>{public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0>type;
}
template<>class remove_cv<class::std::__1::__compressed_pair_elem<void(*),0,0> >{public:typedef class::std::__1::__compressed_pair_elem<void(*),0,0>type;
}
template<>class remove_cv<class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0> >{public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0>type;
}
template<>class remove_cv<class __compressed_pair const>{public:typedef class::std::__1::__compressed_pair<void(*),class::std::__1::__builtin_new_allocator::__builtin_new_deleter>type;
}
template<>class remove_cv<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>{public:typedef class::std::__1::__builtin_new_allocator::__builtin_new_deleter type;
}
template<>class remove_cv<long>{public:typedef long type;
}
template<>class remove_cv<int>{public:typedef int type;
}
template<>class remove_cv<unsigned long&>{public:typedef unsigned long&type;
}
template<>class remove_cv<unsigned long const&>{public:typedef unsigned long const&type;
}
template<>class remove_cv<unsigned long(*)>{public:typedef unsigned long(*type);
}
template<>class remove_cv<class::std::__1::pair<unsigned long,unsigned long> >{public:typedef class::std::__1::pair<unsigned long,unsigned long>type;
}
template<>class remove_cv<void(*)>{public:typedef void(*type);
}
template<>class remove_cv<class __compressed_pair_elem const>{public:typedef class::std::__1::__compressed_pair_elem<int(*),0,0>type;
}
template<>class remove_cv<class __compressed_pair_elem const>{public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1>type;
}
template<>class remove_cv<class::std::__1::__compressed_pair_elem<int(*),0,0> >{public:typedef class::std::__1::__compressed_pair_elem<int(*),0,0>type;
}
template<>class remove_cv<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1> >{public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1>type;
}
template<>class remove_cv<class __compressed_pair const>{public:typedef class::std::__1::__compressed_pair<int(*),class::std::__1::allocator<int> >type;
}
template<>class remove_cv<nullptr_t>{public:typedef nullptr_t type;
}
template<>class remove_cv<class __compressed_pair_elem const>{public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0>type;
}
template<>class remove_cv<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0> >{public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0>type;
}
template<>class remove_cv<class::std::__1::allocator<int> >{public:typedef class::std::__1::allocator<int>type;
}
template<>class remove_cv<int(*&)>{public:typedef int(*&type);
}
template<>class remove_cv<int(*(*))>{public:typedef int(*(*type));
}
;
template<typename __xcodeml_template_type_0_0>using remove_cv_t=typename remove_cv<__xcodeml_template_type_0_0>::type;
template<typename __xcodeml_template_type_0_0>class __libcpp_is_void:public integral_constant<bool,0>{}
;
template<>class __libcpp_is_void<class::std::__1::__compressed_pair_elem<void(*),0,0> >:public integral_constant<bool,0>{}
template<>class __libcpp_is_void<class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0> >:public integral_constant<bool,0>{}
template<>class __libcpp_is_void<class::std::__1::__compressed_pair<void(*),class::std::__1::__builtin_new_allocator::__builtin_new_deleter> >:public integral_constant<bool,0>{}
template<>class __libcpp_is_void<int>:public integral_constant<bool,0>{}
template<>class __libcpp_is_void<unsigned long>:public integral_constant<bool,0>{}
template<>class __libcpp_is_void<unsigned long&>:public integral_constant<bool,0>{}
template<>class __libcpp_is_void<unsigned long const&>:public integral_constant<bool,0>{}
template<>class __libcpp_is_void<unsigned long(*)>:public integral_constant<bool,0>{}
template<>class __libcpp_is_void<class::std::__1::pair<unsigned long,unsigned long> >:public integral_constant<bool,0>{}
template<>class __libcpp_is_void<void(*)>:public integral_constant<bool,0>{}
template<>class __libcpp_is_void<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>:public integral_constant<bool,0>{}
template<>class __libcpp_is_void<class::std::__1::__compressed_pair_elem<int(*),0,0> >:public integral_constant<bool,0>{}
template<>class __libcpp_is_void<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1> >:public integral_constant<bool,0>{}
template<>class __libcpp_is_void<class::std::__1::__compressed_pair<int(*),class::std::__1::allocator<int> > >:public integral_constant<bool,0>{}
template<>class __libcpp_is_void<nullptr_t>:public integral_constant<bool,0>{}
template<>class __libcpp_is_void<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0> >:public integral_constant<bool,0>{}
template<>class __libcpp_is_void<class::std::__1::allocator<int> >:public integral_constant<bool,0>{}
template<>class __libcpp_is_void<int(*&)>:public integral_constant<bool,0>{}
template<>class __libcpp_is_void<int(*(*))>:public integral_constant<bool,0>{}
;
template<>class __libcpp_is_void<void>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class is_void:public __libcpp_is_void<typename remove_cv<__xcodeml_template_type_0_0>::type>{}
;
template<>class is_void<class __compressed_pair_elem const>:public __libcpp_is_void<class::std::__1::__compressed_pair_elem<void(*),0,0> >{}
template<>class is_void<class __compressed_pair_elem const>:public __libcpp_is_void<class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0> >{}
template<>class is_void<class::std::__1::__compressed_pair_elem<void(*),0,0> >:public __libcpp_is_void<class::std::__1::__compressed_pair_elem<void(*),0,0> >{}
template<>class is_void<class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0> >:public __libcpp_is_void<class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0> >{}
template<>class is_void<class __compressed_pair const>:public __libcpp_is_void<class::std::__1::__compressed_pair<void(*),class::std::__1::__builtin_new_allocator::__builtin_new_deleter> >{}
template<>class is_void<int>:public __libcpp_is_void<int>{}
template<>class is_void<unsigned long>:public __libcpp_is_void<unsigned long>{}
template<>class is_void<unsigned long&>:public __libcpp_is_void<unsigned long&>{}
template<>class is_void<unsigned long const&>:public __libcpp_is_void<unsigned long const&>{}
template<>class is_void<unsigned long(*)>:public __libcpp_is_void<unsigned long(*)>{}
template<>class is_void<class::std::__1::pair<unsigned long,unsigned long> >:public __libcpp_is_void<class::std::__1::pair<unsigned long,unsigned long> >{}
template<>class is_void<void(*)>:public __libcpp_is_void<void(*)>{}
template<>class is_void<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>:public __libcpp_is_void<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>{}
template<>class is_void<class __compressed_pair_elem const>:public __libcpp_is_void<class::std::__1::__compressed_pair_elem<int(*),0,0> >{}
template<>class is_void<class __compressed_pair_elem const>:public __libcpp_is_void<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1> >{}
template<>class is_void<class::std::__1::__compressed_pair_elem<int(*),0,0> >:public __libcpp_is_void<class::std::__1::__compressed_pair_elem<int(*),0,0> >{}
template<>class is_void<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1> >:public __libcpp_is_void<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1> >{}
template<>class is_void<class __compressed_pair const>:public __libcpp_is_void<class::std::__1::__compressed_pair<int(*),class::std::__1::allocator<int> > >{}
template<>class is_void<nullptr_t>:public __libcpp_is_void<nullptr_t>{}
template<>class is_void<class __compressed_pair_elem const>:public __libcpp_is_void<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0> >{}
template<>class is_void<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0> >:public __libcpp_is_void<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0> >{}
template<>class is_void<class::std::__1::allocator<int> >:public __libcpp_is_void<class::std::__1::allocator<int> >{}
template<>class is_void<int(*&)>:public __libcpp_is_void<int(*&)>{}
template<>class is_void<int(*(*))>:public __libcpp_is_void<int(*(*))>{}
;
template<typename __xcodeml_template_type_0_0>class __is_nullptr_t_impl:public integral_constant<bool,0>{}
;
template<>class __is_nullptr_t_impl<class::std::__1::__compressed_pair_elem<void(*),0,0> >:public integral_constant<bool,0>{}
template<>class __is_nullptr_t_impl<class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0> >:public integral_constant<bool,0>{}
template<>class __is_nullptr_t_impl<class::std::__1::__compressed_pair<void(*),class::std::__1::__builtin_new_allocator::__builtin_new_deleter> >:public integral_constant<bool,0>{}
template<>class __is_nullptr_t_impl<unsigned long>:public integral_constant<bool,0>{}
template<>class __is_nullptr_t_impl<class::std::__1::pair<unsigned long,unsigned long> >:public integral_constant<bool,0>{}
template<>class __is_nullptr_t_impl<void(*)>:public integral_constant<bool,0>{}
template<>class __is_nullptr_t_impl<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>:public integral_constant<bool,0>{}
template<>class __is_nullptr_t_impl<class::std::__1::__compressed_pair_elem<int(*),0,0> >:public integral_constant<bool,0>{}
template<>class __is_nullptr_t_impl<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1> >:public integral_constant<bool,0>{}
template<>class __is_nullptr_t_impl<class::std::__1::__compressed_pair<int(*),class::std::__1::allocator<int> > >:public integral_constant<bool,0>{}
template<>class __is_nullptr_t_impl<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0> >:public integral_constant<bool,0>{}
template<>class __is_nullptr_t_impl<class::std::__1::allocator<int> >:public integral_constant<bool,0>{}
;
template<>class __is_nullptr_t_impl<nullptr_t>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class __is_nullptr_t:public __is_nullptr_t_impl<typename remove_cv<__xcodeml_template_type_0_0>::type>{}
;
template<>class __is_nullptr_t<class __compressed_pair_elem const>:public __is_nullptr_t_impl<class::std::__1::__compressed_pair_elem<void(*),0,0> >{}
template<>class __is_nullptr_t<class __compressed_pair_elem const>:public __is_nullptr_t_impl<class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0> >{}
template<>class __is_nullptr_t<class::std::__1::__compressed_pair_elem<void(*),0,0> >:public __is_nullptr_t_impl<class::std::__1::__compressed_pair_elem<void(*),0,0> >{}
template<>class __is_nullptr_t<class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0> >:public __is_nullptr_t_impl<class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0> >{}
template<>class __is_nullptr_t<class __compressed_pair const>:public __is_nullptr_t_impl<class::std::__1::__compressed_pair<void(*),class::std::__1::__builtin_new_allocator::__builtin_new_deleter> >{}
template<>class __is_nullptr_t<unsigned long>:public __is_nullptr_t_impl<unsigned long>{}
template<>class __is_nullptr_t<class::std::__1::pair<unsigned long,unsigned long> >:public __is_nullptr_t_impl<class::std::__1::pair<unsigned long,unsigned long> >{}
template<>class __is_nullptr_t<void(*)>:public __is_nullptr_t_impl<void(*)>{}
template<>class __is_nullptr_t<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>:public __is_nullptr_t_impl<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>{}
template<>class __is_nullptr_t<class __compressed_pair_elem const>:public __is_nullptr_t_impl<class::std::__1::__compressed_pair_elem<int(*),0,0> >{}
template<>class __is_nullptr_t<class __compressed_pair_elem const>:public __is_nullptr_t_impl<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1> >{}
template<>class __is_nullptr_t<class::std::__1::__compressed_pair_elem<int(*),0,0> >:public __is_nullptr_t_impl<class::std::__1::__compressed_pair_elem<int(*),0,0> >{}
template<>class __is_nullptr_t<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1> >:public __is_nullptr_t_impl<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1> >{}
template<>class __is_nullptr_t<class __compressed_pair const>:public __is_nullptr_t_impl<class::std::__1::__compressed_pair<int(*),class::std::__1::allocator<int> > >{}
template<>class __is_nullptr_t<nullptr_t>:public __is_nullptr_t_impl<nullptr_t>{}
template<>class __is_nullptr_t<class __compressed_pair_elem const>:public __is_nullptr_t_impl<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0> >{}
template<>class __is_nullptr_t<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0> >:public __is_nullptr_t_impl<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0> >{}
template<>class __is_nullptr_t<class::std::__1::allocator<int> >:public __is_nullptr_t_impl<class::std::__1::allocator<int> >{}
;
template<typename __xcodeml_template_type_0_0>class is_null_pointer:public __is_nullptr_t_impl<typename remove_cv<__xcodeml_template_type_0_0>::type>{}
;
;
template<typename __xcodeml_template_type_0_0>class __libcpp_is_integral:public integral_constant<bool,0>{}
;
template<>class __libcpp_is_integral<double>:public integral_constant<bool,0>{}
;
template<>class __libcpp_is_integral<bool>:public integral_constant<bool,1>{}
;
template<>class __libcpp_is_integral<char>:public integral_constant<bool,1>{}
;
template<>class __libcpp_is_integral<signed char>:public integral_constant<bool,1>{}
;
template<>class __libcpp_is_integral<unsigned char>:public integral_constant<bool,1>{}
;
template<>class __libcpp_is_integral<wchar_t>:public integral_constant<bool,1>{}
;
template<>class __libcpp_is_integral<char16_t>:public integral_constant<bool,1>{}
;
template<>class __libcpp_is_integral<char32_t>:public integral_constant<bool,1>{}
;
template<>class __libcpp_is_integral<short>:public integral_constant<bool,1>{}
;
template<>class __libcpp_is_integral<unsigned short>:public integral_constant<bool,1>{}
;
template<>class __libcpp_is_integral<int>:public integral_constant<bool,1>{}
;
template<>class __libcpp_is_integral<unsigned int>:public integral_constant<bool,1>{}
;
template<>class __libcpp_is_integral<long>:public integral_constant<bool,1>{}
;
template<>class __libcpp_is_integral<unsigned long>:public integral_constant<bool,1>{}
;
template<>class __libcpp_is_integral<long long>:public integral_constant<bool,1>{}
;
template<>class __libcpp_is_integral<unsigned long long>:public integral_constant<bool,1>{}
;
template<>class __libcpp_is_integral<__int128>:public integral_constant<bool,1>{}
;
template<>class __libcpp_is_integral<unsigned __int128>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class is_integral:public __libcpp_is_integral<typename remove_cv<__xcodeml_template_type_0_0>::type>{}
;
template<>class is_integral<unsigned long long>:public __libcpp_is_integral<unsigned long long>{}
template<>class is_integral<unsigned int>:public __libcpp_is_integral<unsigned int>{}
template<>class is_integral<unsigned long>:public __libcpp_is_integral<unsigned long>{}
template<>class is_integral<double>:public __libcpp_is_integral<double>{}
template<>class is_integral<long>:public __libcpp_is_integral<long>{}
;
template<typename __xcodeml_template_type_0_0>class __libcpp_is_floating_point:public integral_constant<bool,0>{}
;
template<>class __libcpp_is_floating_point<unsigned long long>:public integral_constant<bool,0>{}
template<>class __libcpp_is_floating_point<unsigned int>:public integral_constant<bool,0>{}
template<>class __libcpp_is_floating_point<unsigned long>:public integral_constant<bool,0>{}
template<>class __libcpp_is_floating_point<long>:public integral_constant<bool,0>{}
;
template<>class __libcpp_is_floating_point<float>:public integral_constant<bool,1>{}
;
template<>class __libcpp_is_floating_point<double>:public integral_constant<bool,1>{}
;
template<>class __libcpp_is_floating_point<long double>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class is_floating_point:public __libcpp_is_floating_point<typename remove_cv<__xcodeml_template_type_0_0>::type>{}
;
template<>class is_floating_point<unsigned long long>:public __libcpp_is_floating_point<unsigned long long>{}
template<>class is_floating_point<unsigned int>:public __libcpp_is_floating_point<unsigned int>{}
template<>class is_floating_point<unsigned long>:public __libcpp_is_floating_point<unsigned long>{}
template<>class is_floating_point<long>:public __libcpp_is_floating_point<long>{}
;
template<typename __xcodeml_template_type_0_0>class is_array:public integral_constant<bool,0>{}
;
template<>class is_array<class __compressed_pair_elem const>:public integral_constant<bool,0>{}
template<>class is_array<class __compressed_pair_elem const>:public integral_constant<bool,0>{}
template<>class is_array<class::std::__1::__compressed_pair_elem<void(*),0,0> >:public integral_constant<bool,0>{}
template<>class is_array<class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0> >:public integral_constant<bool,0>{}
template<>class is_array<class __compressed_pair const>:public integral_constant<bool,0>{}
template<>class is_array<void>:public integral_constant<bool,0>{}
template<>class is_array<class::std::__1::pair<unsigned long,unsigned long> >:public integral_constant<bool,0>{}
template<>class is_array<void(*)>:public integral_constant<bool,0>{}
template<>class is_array<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>:public integral_constant<bool,0>{}
template<>class is_array<class __compressed_pair_elem const>:public integral_constant<bool,0>{}
template<>class is_array<class __compressed_pair_elem const>:public integral_constant<bool,0>{}
template<>class is_array<class::std::__1::__compressed_pair_elem<int(*),0,0> >:public integral_constant<bool,0>{}
template<>class is_array<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1> >:public integral_constant<bool,0>{}
template<>class is_array<class __compressed_pair const>:public integral_constant<bool,0>{}
template<>class is_array<nullptr_t>:public integral_constant<bool,0>{}
template<>class is_array<class __compressed_pair_elem const>:public integral_constant<bool,0>{}
template<>class is_array<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0> >:public integral_constant<bool,0>{}
template<>class is_array<class::std::__1::allocator<int> >:public integral_constant<bool,0>{}
;
template<typename __xcodeml_template_type_0_0>class is_array<__xcodeml_template_type_0_0>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0,unsigned long _Np>class is_array<__xcodeml_template_type_0_0>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class __libcpp_is_pointer:public integral_constant<bool,0>{}
;
template<>class __libcpp_is_pointer<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>:public integral_constant<bool,0>{}
;
template<typename __xcodeml_template_type_0_0>class __libcpp_is_pointer<__xcodeml_template_type_0_0(*)>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class __libcpp_remove_objc_qualifiers{public:typedef __xcodeml_template_type_0_0 type;
}
;
template<>class __libcpp_remove_objc_qualifiers<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>{public:typedef class::std::__1::__builtin_new_allocator::__builtin_new_deleter type;
}
;
template<typename __xcodeml_template_type_0_0>class is_pointer:public __libcpp_is_pointer<typename __libcpp_remove_objc_qualifiers<typename remove_cv<__xcodeml_template_type_0_0>::type>::type>{}
;
template<>class is_pointer<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>:public __libcpp_is_pointer<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>{}
;
template<typename __xcodeml_template_type_0_0>class is_lvalue_reference:public integral_constant<bool,0>{}
;
;
template<typename __xcodeml_template_type_0_0>class is_lvalue_reference<__xcodeml_template_type_0_0&>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class is_rvalue_reference:public integral_constant<bool,0>{}
;
template<>class is_rvalue_reference<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>:public integral_constant<bool,0>{}
;
template<typename __xcodeml_template_type_0_0>class is_rvalue_reference<__xcodeml_template_type_0_0(*)>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class is_reference:public integral_constant<bool,0>{}
;
template<>class is_reference<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>:public integral_constant<bool,0>{}
template<>class is_reference<class __compressed_pair_elem const>:public integral_constant<bool,0>{}
template<>class is_reference<class __compressed_pair_elem const>:public integral_constant<bool,0>{}
template<>class is_reference<class::std::__1::__compressed_pair_elem<void(*),0,0> >:public integral_constant<bool,0>{}
template<>class is_reference<class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0> >:public integral_constant<bool,0>{}
template<>class is_reference<class __compressed_pair const>:public integral_constant<bool,0>{}
template<>class is_reference<unsigned long>:public integral_constant<bool,0>{}
template<>class is_reference<class::std::__1::pair<unsigned long,unsigned long> >:public integral_constant<bool,0>{}
template<>class is_reference<void(*)>:public integral_constant<bool,0>{}
template<>class is_reference<class __compressed_pair_elem const>:public integral_constant<bool,0>{}
template<>class is_reference<class __compressed_pair_elem const>:public integral_constant<bool,0>{}
template<>class is_reference<class::std::__1::__compressed_pair_elem<int(*),0,0> >:public integral_constant<bool,0>{}
template<>class is_reference<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1> >:public integral_constant<bool,0>{}
template<>class is_reference<class __compressed_pair const>:public integral_constant<bool,0>{}
template<>class is_reference<nullptr_t>:public integral_constant<bool,0>{}
template<>class is_reference<class __compressed_pair_elem const>:public integral_constant<bool,0>{}
template<>class is_reference<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0> >:public integral_constant<bool,0>{}
template<>class is_reference<class::std::__1::allocator<int> >:public integral_constant<bool,0>{}
;
template<typename __xcodeml_template_type_0_0>class is_reference<__xcodeml_template_type_0_0&>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class is_reference<__xcodeml_template_type_0_0(*)>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class is_union:public integral_constant<bool,expression>{}
;
template<>class is_union<class __compressed_pair_elem const>:public integral_constant<bool,0>{}
template<>class is_union<class __compressed_pair_elem const>:public integral_constant<bool,0>{}
template<>class is_union<class::std::__1::__compressed_pair_elem<void(*),0,0> >:public integral_constant<bool,0>{}
template<>class is_union<class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0> >:public integral_constant<bool,0>{}
template<>class is_union<class __compressed_pair const>:public integral_constant<bool,0>{}
template<>class is_union<unsigned long>:public integral_constant<bool,0>{}
template<>class is_union<class::std::__1::pair<unsigned long,unsigned long> >:public integral_constant<bool,0>{}
template<>class is_union<void(*)>:public integral_constant<bool,0>{}
template<>class is_union<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>:public integral_constant<bool,0>{}
template<>class is_union<class __compressed_pair_elem const>:public integral_constant<bool,0>{}
template<>class is_union<class __compressed_pair_elem const>:public integral_constant<bool,0>{}
template<>class is_union<class::std::__1::__compressed_pair_elem<int(*),0,0> >:public integral_constant<bool,0>{}
template<>class is_union<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1> >:public integral_constant<bool,0>{}
template<>class is_union<class __compressed_pair const>:public integral_constant<bool,0>{}
template<>class is_union<nullptr_t>:public integral_constant<bool,0>{}
template<>class is_union<class __compressed_pair_elem const>:public integral_constant<bool,0>{}
template<>class is_union<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0> >:public integral_constant<bool,0>{}
template<>class is_union<class::std::__1::allocator<int> >:public integral_constant<bool,0>{}
;
template<typename __xcodeml_template_type_0_0>class is_class:public integral_constant<bool,expression>{}
;
template<>class is_class<class __compressed_pair_elem const>:public integral_constant<bool,1>{}
template<>class is_class<class __compressed_pair_elem const>:public integral_constant<bool,1>{}
template<>class is_class<class::std::__1::__compressed_pair_elem<void(*),0,0> >:public integral_constant<bool,1>{}
template<>class is_class<class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0> >:public integral_constant<bool,1>{}
template<>class is_class<class __compressed_pair const>:public integral_constant<bool,1>{}
template<>class is_class<unsigned long>:public integral_constant<bool,0>{}
template<>class is_class<class::std::__1::pair<unsigned long,unsigned long> >:public integral_constant<bool,1>{}
template<>class is_class<void(*)>:public integral_constant<bool,0>{}
template<>class is_class<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>:public integral_constant<bool,1>{}
template<>class is_class<class __compressed_pair_elem const>:public integral_constant<bool,1>{}
template<>class is_class<class __compressed_pair_elem const>:public integral_constant<bool,1>{}
template<>class is_class<class::std::__1::__compressed_pair_elem<int(*),0,0> >:public integral_constant<bool,1>{}
template<>class is_class<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1> >:public integral_constant<bool,1>{}
template<>class is_class<class __compressed_pair const>:public integral_constant<bool,1>{}
template<>class is_class<nullptr_t>:public integral_constant<bool,0>{}
template<>class is_class<class __compressed_pair_elem const>:public integral_constant<bool,1>{}
template<>class is_class<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0> >:public integral_constant<bool,1>{}
template<>class is_class<class::std::__1::allocator<int> >:public integral_constant<bool,1>{}
;
namespace __libcpp_is_function_imp{class __dummy_type{}
;
template<typename __xcodeml_template_type_0_0>char __test(__xcodeml_template_type_0_0(*))
template<typename __xcodeml_template_type_0_0>char __test(class::std::__1::__libcpp_is_function_imp::__dummy_type)
template<typename __xcodeml_template_type_0_0>class::std::__1::__two __test(...)
template <>class::std::__1::__two __test(...)
template <>class::std::__1::__two __test(...)
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0&__source(int)
template <>unsigned long&__source(int)
template <>void(*&__source(int))
template<typename __xcodeml_template_type_0_0>class::std::__1::__libcpp_is_function_imp::__dummy_type __source(...)
template <>class::std::__1::__libcpp_is_function_imp::__dummy_type __source(...)
template <>class::std::__1::__libcpp_is_function_imp::__dummy_type __source(...)
}
template<typename __xcodeml_template_type_0_0,bool=((((is_class<__xcodeml_template_type_0_0>::value||is_union<__xcodeml_template_type_0_0>::value)||is_void<__xcodeml_template_type_0_0>::value)||is_reference<__xcodeml_template_type_0_0>::value)||__is_nullptr_t<__xcodeml_template_type_0_0>::value)>class __libcpp_is_function:public integral_constant<bool,expression>{}
;
template<>class __libcpp_is_function<class __compressed_pair_elem const,1>:public integral_constant<bool,0>{}
template<>class __libcpp_is_function<class __compressed_pair_elem const,1>:public integral_constant<bool,0>{}
template<>class __libcpp_is_function<class::std::__1::__compressed_pair_elem<void(*),0,0>,1>:public integral_constant<bool,0>{}
template<>class __libcpp_is_function<class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0>,1>:public integral_constant<bool,0>{}
template<>class __libcpp_is_function<class __compressed_pair const,1>:public integral_constant<bool,0>{}
template<>class __libcpp_is_function<unsigned long,0>:public integral_constant<bool,0>{}
template<>class __libcpp_is_function<class::std::__1::pair<unsigned long,unsigned long>,1>:public integral_constant<bool,0>{}
template<>class __libcpp_is_function<void(*),0>:public integral_constant<bool,0>{}
template<>class __libcpp_is_function<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1>:public integral_constant<bool,0>{}
template<>class __libcpp_is_function<class __compressed_pair_elem const,1>:public integral_constant<bool,0>{}
template<>class __libcpp_is_function<class __compressed_pair_elem const,1>:public integral_constant<bool,0>{}
template<>class __libcpp_is_function<class::std::__1::__compressed_pair_elem<int(*),0,0>,1>:public integral_constant<bool,0>{}
template<>class __libcpp_is_function<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1>,1>:public integral_constant<bool,0>{}
template<>class __libcpp_is_function<class __compressed_pair const,1>:public integral_constant<bool,0>{}
template<>class __libcpp_is_function<nullptr_t,1>:public integral_constant<bool,0>{}
template<>class __libcpp_is_function<class __compressed_pair_elem const,1>:public integral_constant<bool,0>{}
template<>class __libcpp_is_function<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0>,1>:public integral_constant<bool,0>{}
template<>class __libcpp_is_function<class::std::__1::allocator<int>,1>:public integral_constant<bool,0>{}
;
template<typename __xcodeml_template_type_0_0>class __libcpp_is_function<__xcodeml_template_type_0_0,1>:public integral_constant<bool,0>{}
;
template<typename __xcodeml_template_type_0_0>class is_function:public __libcpp_is_function<__xcodeml_template_type_0_0,expression>{}
;
template<>class is_function<class __compressed_pair_elem const>:public __libcpp_is_function<class __compressed_pair_elem const,1>{}
template<>class is_function<class __compressed_pair_elem const>:public __libcpp_is_function<class __compressed_pair_elem const,1>{}
template<>class is_function<class::std::__1::__compressed_pair_elem<void(*),0,0> >:public __libcpp_is_function<class::std::__1::__compressed_pair_elem<void(*),0,0>,1>{}
template<>class is_function<class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0> >:public __libcpp_is_function<class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0>,1>{}
template<>class is_function<class __compressed_pair const>:public __libcpp_is_function<class __compressed_pair const,1>{}
template<>class is_function<unsigned long>:public __libcpp_is_function<unsigned long,0>{}
template<>class is_function<class::std::__1::pair<unsigned long,unsigned long> >:public __libcpp_is_function<class::std::__1::pair<unsigned long,unsigned long>,1>{}
template<>class is_function<void(*)>:public __libcpp_is_function<void(*),0>{}
template<>class is_function<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>:public __libcpp_is_function<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1>{}
template<>class is_function<class __compressed_pair_elem const>:public __libcpp_is_function<class __compressed_pair_elem const,1>{}
template<>class is_function<class __compressed_pair_elem const>:public __libcpp_is_function<class __compressed_pair_elem const,1>{}
template<>class is_function<class::std::__1::__compressed_pair_elem<int(*),0,0> >:public __libcpp_is_function<class::std::__1::__compressed_pair_elem<int(*),0,0>,1>{}
template<>class is_function<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1> >:public __libcpp_is_function<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1>,1>{}
template<>class is_function<class __compressed_pair const>:public __libcpp_is_function<class __compressed_pair const,1>{}
template<>class is_function<nullptr_t>:public __libcpp_is_function<nullptr_t,1>{}
template<>class is_function<class __compressed_pair_elem const>:public __libcpp_is_function<class __compressed_pair_elem const,1>{}
template<>class is_function<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0> >:public __libcpp_is_function<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0>,1>{}
template<>class is_function<class::std::__1::allocator<int> >:public __libcpp_is_function<class::std::__1::allocator<int>,1>{}
;
template<typename __xcodeml_template_type_0_0,bool _IsMemberFunctionPtr,bool _IsMemberObjectPtr>class __member_pointer_traits_imp{}
;
;
template<typename __xcodeml_template_type_0_0>class __libcpp_is_member_function_pointer:public integral_constant<bool,0>{}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __libcpp_is_member_function_pointer<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)>:public is_function<__xcodeml_template_type_0_0>{}
;
template<typename __xcodeml_template_type_0_0>class is_member_function_pointer:public/**/{}
;
;
template<typename __xcodeml_template_type_0_0>class __libcpp_is_member_pointer:public integral_constant<bool,0>{}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __libcpp_is_member_pointer<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class is_member_pointer:public __libcpp_is_member_pointer<typename remove_cv<__xcodeml_template_type_0_0>::type>{}
;
;
template<typename __xcodeml_template_type_0_0>class is_member_object_pointer:public integral_constant<bool,expression>{}
;
;
template<typename __xcodeml_template_type_0_0>class is_enum:public integral_constant<bool,expression>{}
;
template<>class is_enum<enum __legacy_memory_order>:public integral_constant<bool,1>{}
template<>class is_enum<enum memory_order>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class is_arithmetic:public integral_constant<bool,expression>{}
;
template<>class is_arithmetic<unsigned long long>:public integral_constant<bool,1>{}
template<>class is_arithmetic<unsigned int>:public integral_constant<bool,1>{}
template<>class is_arithmetic<unsigned long>:public integral_constant<bool,1>{}
template<>class is_arithmetic<long>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class is_fundamental:public integral_constant<bool,expression>{}
;
;
template<typename __xcodeml_template_type_0_0>class is_scalar:public integral_constant<bool,expression>{}
;
;
template<>class is_scalar<nullptr_t>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class is_object:public integral_constant<bool,expression>{}
;
;
template<typename __xcodeml_template_type_0_0>class is_compound:public integral_constant<bool,expression>{}
;
;
class __is_referenceable_impl{public:template<typename __xcodeml_template_type_0_0>static __xcodeml_template_type_0_0&__test(int)
static template <>class __compressed_pair_elem const&__test(int)
static template <>class __compressed_pair_elem const&__test(int)
static template <>class::std::__1::__compressed_pair_elem<void(*),0,0>&__test(int)
static template <>class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0>&__test(int)
static template <>class __compressed_pair const&__test(int)
static template <>unsigned long&__test(int)
static template <>unsigned long const&__test(int)
static template <>class::std::__1::pair<unsigned long,unsigned long>&__test(int)
static template <>void(*&__test(int))
static template <>class::std::__1::__builtin_new_allocator::__builtin_new_deleter&__test(int)
static template <>class __compressed_pair_elem const&__test(int)
static template <>class __compressed_pair_elem const&__test(int)
static template <>class::std::__1::__compressed_pair_elem<int(*),0,0>&__test(int)
static template <>class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1>&__test(int)
static template <>class __compressed_pair const&__test(int)
static template <>nullptr_t&__test(int)
static template <>class::std::__1::allocator<int>&__test(int)
static template <>class __compressed_pair_elem const&__test(int)
static template <>class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0>&__test(int)
static template <>class::std::__1::allocator<int>&__test(int)
static template <>int&__test(int)
static template <>int(*&__test(int))
public:template<typename __xcodeml_template_type_0_0>static class::std::__1::__two __test(...)
static template <>class::std::__1::__two __test(...)
static template <>class::std::__1::__two __test(...)
static template <>class::std::__1::__two __test(...)
static template <>class::std::__1::__two __test(...)
static template <>class::std::__1::__two __test(...)
static template <>class::std::__1::__two __test(...)
static template <>class::std::__1::__two __test(...)
static template <>class::std::__1::__two __test(...)
static template <>class::std::__1::__two __test(...)
static template <>class::std::__1::__two __test(...)
static template <>class::std::__1::__two __test(...)
static template <>class::std::__1::__two __test(...)
static template <>class::std::__1::__two __test(...)
static template <>class::std::__1::__two __test(...)
static template <>class::std::__1::__two __test(...)
static template <>class::std::__1::__two __test(...)
static template <>class::std::__1::__two __test(...)
static template <>class::std::__1::__two __test(...)
static template <>class::std::__1::__two __test(...)
static template <>class::std::__1::__two __test(...)
static template <>class::std::__1::__two __test(...)
static template <>class::std::__1::__two __test(...)
static template <>class::std::__1::__two __test(...)
}
;
template<typename __xcodeml_template_type_0_0>class __is_referenceable:public integral_constant<bool,expression>{}
;
template<>class __is_referenceable<void>:public integral_constant<bool,0>{}
template<>class __is_referenceable<class __compressed_pair_elem const>:public integral_constant<bool,1>{}
template<>class __is_referenceable<class __compressed_pair_elem const>:public integral_constant<bool,1>{}
template<>class __is_referenceable<class::std::__1::__compressed_pair_elem<void(*),0,0> >:public integral_constant<bool,1>{}
template<>class __is_referenceable<class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0> >:public integral_constant<bool,1>{}
template<>class __is_referenceable<class __compressed_pair const>:public integral_constant<bool,1>{}
template<>class __is_referenceable<unsigned long>:public integral_constant<bool,1>{}
template<>class __is_referenceable<unsigned long const>:public integral_constant<bool,1>{}
template<>class __is_referenceable<class::std::__1::pair<unsigned long,unsigned long> >:public integral_constant<bool,1>{}
template<>class __is_referenceable<void(*)>:public integral_constant<bool,1>{}
template<>class __is_referenceable<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>:public integral_constant<bool,1>{}
template<>class __is_referenceable<class __compressed_pair_elem const>:public integral_constant<bool,1>{}
template<>class __is_referenceable<class __compressed_pair_elem const>:public integral_constant<bool,1>{}
template<>class __is_referenceable<class::std::__1::__compressed_pair_elem<int(*),0,0> >:public integral_constant<bool,1>{}
template<>class __is_referenceable<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1> >:public integral_constant<bool,1>{}
template<>class __is_referenceable<class __compressed_pair const>:public integral_constant<bool,1>{}
template<>class __is_referenceable<nullptr_t>:public integral_constant<bool,1>{}
template<>class __is_referenceable<class::std::__1::allocator<int>&>:public integral_constant<bool,1>{}
template<>class __is_referenceable<class __compressed_pair_elem const>:public integral_constant<bool,1>{}
template<>class __is_referenceable<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0> >:public integral_constant<bool,1>{}
template<>class __is_referenceable<class::std::__1::allocator<int> >:public integral_constant<bool,1>{}
template<>class __is_referenceable<int>:public integral_constant<bool,1>{}
template<>class __is_referenceable<int(*)>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0,bool=((is_reference<__xcodeml_template_type_0_0>::value||is_function<__xcodeml_template_type_0_0>::value)||is_const<__xcodeml_template_type_0_0>::value)>class __add_const{public:typedef __xcodeml_template_type_0_0 type;
}
;
template<>class __add_const<unsigned long,0>{public:typedef unsigned long const type;
}
;
template<typename __xcodeml_template_type_0_0>class __add_const<__xcodeml_template_type_0_0,0>{public:typedef __xcodeml_template_type_0_0 const type;
}
;
template<typename __xcodeml_template_type_0_0>class add_const{public:typedef typename __add_const<__xcodeml_template_type_0_0,expression>::type type;
}
;
template<>class add_const<unsigned long>{public:typedef unsigned long const type;
}
;
template<typename __xcodeml_template_type_0_0>using add_const_t=typename add_const<__xcodeml_template_type_0_0>::type;
template<typename __xcodeml_template_type_0_0,bool=((is_reference<__xcodeml_template_type_0_0>::value||is_function<__xcodeml_template_type_0_0>::value)||is_volatile<__xcodeml_template_type_0_0>::value)>class __add_volatile{public:typedef __xcodeml_template_type_0_0 type;
}
;
;
template<typename __xcodeml_template_type_0_0>class __add_volatile<__xcodeml_template_type_0_0,0>{public:typedef __xcodeml_template_type_0_0 volatile type;
}
;
template<typename __xcodeml_template_type_0_0>class add_volatile{public:typedef typename __add_volatile<__xcodeml_template_type_0_0,expression>::type type;
}
;
;
template<typename __xcodeml_template_type_0_0>using add_volatile_t=typename add_volatile<__xcodeml_template_type_0_0>::type;
template<typename __xcodeml_template_type_0_0>class add_cv{public:typedef typename add_const<typename add_volatile<__xcodeml_template_type_0_0>::type>::type type;
}
;
;
template<typename __xcodeml_template_type_0_0>using add_cv_t=typename add_cv<__xcodeml_template_type_0_0>::type;
template<typename __xcodeml_template_type_0_0>class remove_reference{public:typedef __xcodeml_template_type_0_0 type;
}
;
template<>class remove_reference<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>{public:typedef class::std::__1::__builtin_new_allocator::__builtin_new_deleter type;
}
template<>class remove_reference<class __compressed_pair_elem const&>{public:typedef class __compressed_pair_elem const type;
}
template<>class remove_reference<class __compressed_pair_elem const>{public:typedef class __compressed_pair_elem const type;
}
template<>class remove_reference<class __compressed_pair_elem const&>{public:typedef class __compressed_pair_elem const type;
}
template<>class remove_reference<class __compressed_pair_elem const>{public:typedef class __compressed_pair_elem const type;
}
template<>class remove_reference<class::std::__1::__compressed_pair_elem<void(*),0,0> >{public:typedef class::std::__1::__compressed_pair_elem<void(*),0,0>type;
}
template<>class remove_reference<class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0> >{public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0>type;
}
template<>class remove_reference<class __compressed_pair const&>{public:typedef class __compressed_pair const type;
}
template<>class remove_reference<class __compressed_pair const>{public:typedef class __compressed_pair const type;
}
template<>class remove_reference<class::std::__1::allocator<int> >{public:typedef class::std::__1::allocator<int>type;
}
template<>class remove_reference<class::std::__1::pair<unsigned long,unsigned long> >{public:typedef class::std::__1::pair<unsigned long,unsigned long>type;
}
template<>class remove_reference<unsigned long>{public:typedef unsigned long type;
}
template<>class remove_reference<unsigned long&>{public:typedef unsigned long type;
}
template<>class remove_reference<class::std::__1::__builtin_new_allocator::__builtin_new_deleter&>{public:typedef class::std::__1::__builtin_new_allocator::__builtin_new_deleter type;
}
template<>class remove_reference<void(*&)>{public:typedef void(*type);
}
template<>class remove_reference<void(*)>{public:typedef void(*type);
}
template<>class remove_reference<class __compressed_pair_elem const&>{public:typedef class __compressed_pair_elem const type;
}
template<>class remove_reference<class __compressed_pair_elem const>{public:typedef class __compressed_pair_elem const type;
}
template<>class remove_reference<class __compressed_pair_elem const&>{public:typedef class __compressed_pair_elem const type;
}
template<>class remove_reference<class __compressed_pair_elem const>{public:typedef class __compressed_pair_elem const type;
}
template<>class remove_reference<class::std::__1::__compressed_pair_elem<int(*),0,0> >{public:typedef class::std::__1::__compressed_pair_elem<int(*),0,0>type;
}
template<>class remove_reference<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1> >{public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1>type;
}
template<>class remove_reference<class __compressed_pair const&>{public:typedef class __compressed_pair const type;
}
template<>class remove_reference<class __compressed_pair const>{public:typedef class __compressed_pair const type;
}
template<>class remove_reference<nullptr_t>{public:typedef nullptr_t type;
}
template<>class remove_reference<int&>{public:typedef int type;
}
template<>class remove_reference<int>{public:typedef int type;
}
template<>class remove_reference<class::std::__1::allocator<int>&>{public:typedef class::std::__1::allocator<int>type;
}
template<>class remove_reference<class __compressed_pair_elem const&>{public:typedef class __compressed_pair_elem const type;
}
template<>class remove_reference<class __compressed_pair_elem const>{public:typedef class __compressed_pair_elem const type;
}
template<>class remove_reference<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0> >{public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0>type;
}
template<>class remove_reference<int(*&)>{public:typedef int(*type);
}
;
template<typename __xcodeml_template_type_0_0>class remove_reference<__xcodeml_template_type_0_0&>{public:typedef __xcodeml_template_type_0_0 type;
}
;
template<typename __xcodeml_template_type_0_0>class remove_reference<__xcodeml_template_type_0_0(*)>{public:typedef __xcodeml_template_type_0_0 type;
}
;
template<typename __xcodeml_template_type_0_0>using remove_reference_t=typename remove_reference<__xcodeml_template_type_0_0>::type;
template<typename __xcodeml_template_type_0_0,bool=__is_referenceable<__xcodeml_template_type_0_0>::value>class __add_lvalue_reference_impl{public:typedef __xcodeml_template_type_0_0 type;
}
;
template<>class __add_lvalue_reference_impl<void,0>{public:typedef void type;
}
template<>class __add_lvalue_reference_impl<unsigned long,1>{public:typedef unsigned long&type;
}
template<>class __add_lvalue_reference_impl<unsigned long const,1>{public:typedef unsigned long const&type;
}
template<>class __add_lvalue_reference_impl<class::std::__1::allocator<int>&,1>{public:typedef class::std::__1::allocator<int>&type;
}
template<>class __add_lvalue_reference_impl<int(*),1>{public:typedef int(*&type);
}
;
template<typename __xcodeml_template_type_0_0>class __add_lvalue_reference_impl<__xcodeml_template_type_0_0,1>{public:typedef __xcodeml_template_type_0_0&type;
}
;
template<typename __xcodeml_template_type_0_0>class add_lvalue_reference{public:typedef typename __add_lvalue_reference_impl<__xcodeml_template_type_0_0,expression>::type type;
}
;
template<>class add_lvalue_reference<void>{public:typedef void type;
}
template<>class add_lvalue_reference<unsigned long>{public:typedef unsigned long&type;
}
template<>class add_lvalue_reference<unsigned long const>{public:typedef unsigned long const&type;
}
template<>class add_lvalue_reference<class::std::__1::allocator<int>&>{public:typedef class::std::__1::allocator<int>&type;
}
template<>class add_lvalue_reference<int(*)>{public:typedef int(*&type);
}
;
template<typename __xcodeml_template_type_0_0>using add_lvalue_reference_t=typename add_lvalue_reference<__xcodeml_template_type_0_0>::type;
template<typename __xcodeml_template_type_0_0,bool=__is_referenceable<__xcodeml_template_type_0_0>::value>class __add_rvalue_reference_impl{public:typedef __xcodeml_template_type_0_0 type;
}
;
template<>class __add_rvalue_reference_impl<unsigned long,1>{public:typedef unsigned long(*type);
}
template<>class __add_rvalue_reference_impl<int,1>{public:typedef int(*type);
}
template<>class __add_rvalue_reference_impl<int(*),1>{public:typedef int(*(*type));
}
;
template<typename __xcodeml_template_type_0_0>class __add_rvalue_reference_impl<__xcodeml_template_type_0_0,1>{public:typedef __xcodeml_template_type_0_0(*type);
}
;
template<typename __xcodeml_template_type_0_0>class add_rvalue_reference{public:typedef typename __add_rvalue_reference_impl<__xcodeml_template_type_0_0,expression>::type type;
}
;
template<>class add_rvalue_reference<unsigned long>{public:typedef unsigned long(*type);
}
template<>class add_rvalue_reference<int>{public:typedef int(*type);
}
template<>class add_rvalue_reference<int(*)>{public:typedef int(*(*type));
}
;
template<typename __xcodeml_template_type_0_0>using add_rvalue_reference_t=typename add_rvalue_reference<__xcodeml_template_type_0_0>::type;
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0(*__declval(int))
template <>unsigned long&__declval(int)
template <>unsigned long const&__declval(int)
template <>unsigned long(*__declval(int))
template <>class::std::__1::allocator<int>(*__declval(int))
template <>int(*(*__declval(int)))
template <>int(*__declval(int))
template <>class allocator const&__declval(int)
template <>int(*&__declval(int))
template <>int(*(*__declval(int)))
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 __declval(long)
template <>unsigned long&__declval(long)
template <>unsigned long const&__declval(long)
template <>unsigned long(*__declval(long))
template <>class::std::__1::allocator<int>__declval(long)
template <>int(*__declval(long))
template <>int __declval(long)
template <>class allocator const&__declval(long)
template <>int(*&__declval(long))
template <>int(*(*__declval(long)))
template<typename __xcodeml_template_type_0_0>decltype (declval())
template <>unsigned long&declval()
template <>unsigned long const&declval()
template <>unsigned long(*declval())
template <>class::std::__1::allocator<int>(*declval())
template <>int(*(*declval()))
template <>int(*declval())
template <>class allocator const&declval()
template <>int(*&declval())
template <>int(*(*declval()))
template<typename __xcodeml_template_type_0_0>class __uncvref{public:typedef typename remove_cv<typename remove_reference<__xcodeml_template_type_0_0>::type>::type type;
}
;
template<>class __uncvref<class::std::__1::pair<unsigned long,unsigned long> >{public:typedef class::std::__1::pair<unsigned long,unsigned long>type;
}
;
template<typename __xcodeml_template_type_0_0>class __unconstref{public:typedef typename remove_const<typename remove_reference<__xcodeml_template_type_0_0>::type>::type type;
}
;
;
template<typename __xcodeml_template_type_0_0>using __uncvref_t=typename __uncvref<__xcodeml_template_type_0_0>::type;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __is_same_uncvref:public integral_constant<bool,expression>{}
;
;
class __any{public:__any(...);
}
;
template<typename __xcodeml_template_type_0_0>class remove_pointer{public:typedef __xcodeml_template_type_0_0 type;
}
;
;
template<typename __xcodeml_template_type_0_0>class remove_pointer<__xcodeml_template_type_0_0(*)>{public:typedef __xcodeml_template_type_0_0 type;
}
;
template<typename __xcodeml_template_type_0_0>class remove_pointer<__xcodeml_template_type_0_0(*const)>{public:typedef __xcodeml_template_type_0_0 type;
}
;
template<typename __xcodeml_template_type_0_0>class remove_pointer<__xcodeml_template_type_0_0(*volatile)>{public:typedef __xcodeml_template_type_0_0 type;
}
;
template<typename __xcodeml_template_type_0_0>class remove_pointer<__xcodeml_template_type_0_0(*volatile const)>{public:typedef __xcodeml_template_type_0_0 type;
}
;
template<typename __xcodeml_template_type_0_0>using remove_pointer_t=typename remove_pointer<__xcodeml_template_type_0_0>::type;
template<typename __xcodeml_template_type_0_0,bool=(__is_referenceable<__xcodeml_template_type_0_0>::value||integral_constant<bool,expression>::value)>class __add_pointer_impl{public:typedef typename remove_reference<__xcodeml_template_type_0_0>::type(*type);
}
;
template<>class __add_pointer_impl<class __compressed_pair_elem const,1>{public:typedef class __compressed_pair_elem const(*type);
}
template<>class __add_pointer_impl<class __compressed_pair_elem const,1>{public:typedef class __compressed_pair_elem const(*type);
}
template<>class __add_pointer_impl<class::std::__1::__compressed_pair_elem<void(*),0,0>,1>{public:typedef class::std::__1::__compressed_pair_elem<void(*),0,0>(*type);
}
template<>class __add_pointer_impl<class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0>,1>{public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0>(*type);
}
template<>class __add_pointer_impl<class __compressed_pair const,1>{public:typedef class __compressed_pair const(*type);
}
template<>class __add_pointer_impl<class::std::__1::pair<unsigned long,unsigned long>,1>{public:typedef class::std::__1::pair<unsigned long,unsigned long>(*type);
}
template<>class __add_pointer_impl<void(*),1>{public:typedef void(*(*type));
}
template<>class __add_pointer_impl<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1>{public:typedef class::std::__1::__builtin_new_allocator::__builtin_new_deleter(*type);
}
template<>class __add_pointer_impl<class __compressed_pair_elem const,1>{public:typedef class __compressed_pair_elem const(*type);
}
template<>class __add_pointer_impl<class __compressed_pair_elem const,1>{public:typedef class __compressed_pair_elem const(*type);
}
template<>class __add_pointer_impl<class::std::__1::__compressed_pair_elem<int(*),0,0>,1>{public:typedef class::std::__1::__compressed_pair_elem<int(*),0,0>(*type);
}
template<>class __add_pointer_impl<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1>,1>{public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1>(*type);
}
template<>class __add_pointer_impl<class __compressed_pair const,1>{public:typedef class __compressed_pair const(*type);
}
template<>class __add_pointer_impl<nullptr_t,1>{public:typedef nullptr_t(*type);
}
template<>class __add_pointer_impl<class __compressed_pair_elem const,1>{public:typedef class __compressed_pair_elem const(*type);
}
template<>class __add_pointer_impl<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0>,1>{public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0>(*type);
}
template<>class __add_pointer_impl<class::std::__1::allocator<int>,1>{public:typedef class::std::__1::allocator<int>(*type);
}
;
template<typename __xcodeml_template_type_0_0>class __add_pointer_impl<__xcodeml_template_type_0_0,0>{public:typedef __xcodeml_template_type_0_0 type;
}
;
template<typename __xcodeml_template_type_0_0>class add_pointer{public:typedef typename __add_pointer_impl<__xcodeml_template_type_0_0,expression>::type type;
}
;
template<>class add_pointer<class __compressed_pair_elem const>{public:typedef class __compressed_pair_elem const(*type);
}
template<>class add_pointer<class __compressed_pair_elem const>{public:typedef class __compressed_pair_elem const(*type);
}
template<>class add_pointer<class::std::__1::__compressed_pair_elem<void(*),0,0> >{public:typedef class::std::__1::__compressed_pair_elem<void(*),0,0>(*type);
}
template<>class add_pointer<class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0> >{public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0>(*type);
}
template<>class add_pointer<class __compressed_pair const>{public:typedef class __compressed_pair const(*type);
}
template<>class add_pointer<class::std::__1::pair<unsigned long,unsigned long> >{public:typedef class::std::__1::pair<unsigned long,unsigned long>(*type);
}
template<>class add_pointer<void(*)>{public:typedef void(*(*type));
}
template<>class add_pointer<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>{public:typedef class::std::__1::__builtin_new_allocator::__builtin_new_deleter(*type);
}
template<>class add_pointer<class __compressed_pair_elem const>{public:typedef class __compressed_pair_elem const(*type);
}
template<>class add_pointer<class __compressed_pair_elem const>{public:typedef class __compressed_pair_elem const(*type);
}
template<>class add_pointer<class::std::__1::__compressed_pair_elem<int(*),0,0> >{public:typedef class::std::__1::__compressed_pair_elem<int(*),0,0>(*type);
}
template<>class add_pointer<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1> >{public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1>(*type);
}
template<>class add_pointer<class __compressed_pair const>{public:typedef class __compressed_pair const(*type);
}
template<>class add_pointer<nullptr_t>{public:typedef nullptr_t(*type);
}
template<>class add_pointer<class __compressed_pair_elem const>{public:typedef class __compressed_pair_elem const(*type);
}
template<>class add_pointer<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0> >{public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0>(*type);
}
template<>class add_pointer<class::std::__1::allocator<int> >{public:typedef class::std::__1::allocator<int>(*type);
}
;
template<typename __xcodeml_template_type_0_0>using add_pointer_t=typename add_pointer<__xcodeml_template_type_0_0>::type;
template<typename __xcodeml_template_type_0_0,bool=is_integral<__xcodeml_template_type_0_0>::value>class __libcpp_is_signed_impl:public integral_constant<bool,expression>{}
;
template<>class __libcpp_is_signed_impl<unsigned long long,1>:public integral_constant<bool,0>{}
template<>class __libcpp_is_signed_impl<unsigned int,1>:public integral_constant<bool,0>{}
template<>class __libcpp_is_signed_impl<unsigned long,1>:public integral_constant<bool,0>{}
template<>class __libcpp_is_signed_impl<long,1>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class __libcpp_is_signed_impl<__xcodeml_template_type_0_0,0>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0,bool=is_arithmetic<__xcodeml_template_type_0_0>::value>class __libcpp_is_signed:public __libcpp_is_signed_impl<__xcodeml_template_type_0_0,expression>{}
;
template<>class __libcpp_is_signed<unsigned long long,1>:public __libcpp_is_signed_impl<unsigned long long,1>{}
template<>class __libcpp_is_signed<unsigned int,1>:public __libcpp_is_signed_impl<unsigned int,1>{}
template<>class __libcpp_is_signed<unsigned long,1>:public __libcpp_is_signed_impl<unsigned long,1>{}
template<>class __libcpp_is_signed<long,1>:public __libcpp_is_signed_impl<long,1>{}
;
template<typename __xcodeml_template_type_0_0>class __libcpp_is_signed<__xcodeml_template_type_0_0,0>:public integral_constant<bool,0>{}
;
template<typename __xcodeml_template_type_0_0>class is_signed:public __libcpp_is_signed<__xcodeml_template_type_0_0,expression>{}
;
template<>class is_signed<unsigned long long>:public __libcpp_is_signed<unsigned long long,1>{}
template<>class is_signed<unsigned int>:public __libcpp_is_signed<unsigned int,1>{}
template<>class is_signed<unsigned long>:public __libcpp_is_signed<unsigned long,1>{}
template<>class is_signed<long>:public __libcpp_is_signed<long,1>{}
;
template<typename __xcodeml_template_type_0_0,bool=is_integral<__xcodeml_template_type_0_0>::value>class __libcpp_is_unsigned_impl:public integral_constant<bool,expression>{}
;
;
template<typename __xcodeml_template_type_0_0>class __libcpp_is_unsigned_impl<__xcodeml_template_type_0_0,0>:public integral_constant<bool,0>{}
;
template<typename __xcodeml_template_type_0_0,bool=is_arithmetic<__xcodeml_template_type_0_0>::value>class __libcpp_is_unsigned:public __libcpp_is_unsigned_impl<__xcodeml_template_type_0_0,expression>{}
;
;
template<typename __xcodeml_template_type_0_0>class __libcpp_is_unsigned<__xcodeml_template_type_0_0,0>:public integral_constant<bool,0>{}
;
template<typename __xcodeml_template_type_0_0>class is_unsigned:public __libcpp_is_unsigned<__xcodeml_template_type_0_0,expression>{}
;
;
template<typename __xcodeml_template_type_0_0>class rank:public integral_constant<unsigned long,0>{}
;
;
template<typename __xcodeml_template_type_0_0>class rank<__xcodeml_template_type_0_0>:public integral_constant<unsigned long,expression>{}
;
template<typename __xcodeml_template_type_0_0,unsigned long _Np>class rank<__xcodeml_template_type_0_0>:public integral_constant<unsigned long,expression>{}
;
template<typename __xcodeml_template_type_0_0,unsigned int _Ip=0>class extent:public integral_constant<unsigned long,0>{}
;
;
template<typename __xcodeml_template_type_0_0>class extent<__xcodeml_template_type_0_0,0>:public integral_constant<unsigned long,0>{}
;
template<typename __xcodeml_template_type_0_0,unsigned int _Ip>class extent<__xcodeml_template_type_0_0,expression>:public integral_constant<unsigned long,expression>{}
;
template<typename __xcodeml_template_type_0_0,unsigned long _Np>class extent<__xcodeml_template_type_0_0,0>:public integral_constant<unsigned long,expression>{}
;
template<typename __xcodeml_template_type_0_0,unsigned long _Np,unsigned int _Ip>class extent<__xcodeml_template_type_0_0,expression>:public integral_constant<unsigned long,expression>{}
;
template<typename __xcodeml_template_type_0_0>class remove_extent{public:typedef __xcodeml_template_type_0_0 type;
}
;
template<>class remove_extent<class __compressed_pair_elem const>{public:typedef class __compressed_pair_elem const type;
}
template<>class remove_extent<class __compressed_pair_elem const>{public:typedef class __compressed_pair_elem const type;
}
template<>class remove_extent<class::std::__1::__compressed_pair_elem<void(*),0,0> >{public:typedef class::std::__1::__compressed_pair_elem<void(*),0,0>type;
}
template<>class remove_extent<class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0> >{public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0>type;
}
template<>class remove_extent<class __compressed_pair const>{public:typedef class __compressed_pair const type;
}
template<>class remove_extent<class::std::__1::pair<unsigned long,unsigned long> >{public:typedef class::std::__1::pair<unsigned long,unsigned long>type;
}
template<>class remove_extent<void(*)>{public:typedef void(*type);
}
template<>class remove_extent<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>{public:typedef class::std::__1::__builtin_new_allocator::__builtin_new_deleter type;
}
template<>class remove_extent<class __compressed_pair_elem const>{public:typedef class __compressed_pair_elem const type;
}
template<>class remove_extent<class __compressed_pair_elem const>{public:typedef class __compressed_pair_elem const type;
}
template<>class remove_extent<class::std::__1::__compressed_pair_elem<int(*),0,0> >{public:typedef class::std::__1::__compressed_pair_elem<int(*),0,0>type;
}
template<>class remove_extent<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1> >{public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1>type;
}
template<>class remove_extent<class __compressed_pair const>{public:typedef class __compressed_pair const type;
}
template<>class remove_extent<nullptr_t>{public:typedef nullptr_t type;
}
template<>class remove_extent<class __compressed_pair_elem const>{public:typedef class __compressed_pair_elem const type;
}
template<>class remove_extent<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0> >{public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0>type;
}
template<>class remove_extent<class::std::__1::allocator<int> >{public:typedef class::std::__1::allocator<int>type;
}
;
template<typename __xcodeml_template_type_0_0>class remove_extent<__xcodeml_template_type_0_0>{public:typedef __xcodeml_template_type_0_0 type;
}
;
template<typename __xcodeml_template_type_0_0,unsigned long _Np>class remove_extent<__xcodeml_template_type_0_0>{public:typedef __xcodeml_template_type_0_0 type;
}
;
template<typename __xcodeml_template_type_0_0>using remove_extent_t=typename remove_extent<__xcodeml_template_type_0_0>::type;
template<typename __xcodeml_template_type_0_0>class remove_all_extents{public:typedef __xcodeml_template_type_0_0 type;
}
;
;
template<typename __xcodeml_template_type_0_0>class remove_all_extents<__xcodeml_template_type_0_0>{public:typedef typename remove_all_extents<__xcodeml_template_type_0_0>::type type;
}
;
template<typename __xcodeml_template_type_0_0,unsigned long _Np>class remove_all_extents<__xcodeml_template_type_0_0>{public:typedef typename remove_all_extents<__xcodeml_template_type_0_0>::type type;
}
;
template<typename __xcodeml_template_type_0_0>using remove_all_extents_t=typename remove_all_extents<__xcodeml_template_type_0_0>::type;
template<typename __xcodeml_template_type_0_0,bool>class __decay{public:typedef typename remove_cv<__xcodeml_template_type_0_0>::type type;
}
;
template<>class __decay<class __compressed_pair_elem const,1>{public:
public:typedef class::std::__1::__compressed_pair_elem<void(*),0,0>type;
}
template<>class __decay<class __compressed_pair_elem const,1>{public:
public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0>type;
}
template<>class __decay<class::std::__1::__compressed_pair_elem<void(*),0,0>,1>{public:
public:typedef class::std::__1::__compressed_pair_elem<void(*),0,0>type;
}
template<>class __decay<class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0>,1>{public:
public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0>type;
}
template<>class __decay<class __compressed_pair const,1>{public:
public:typedef class::std::__1::__compressed_pair<void(*),class::std::__1::__builtin_new_allocator::__builtin_new_deleter>type;
}
template<>class __decay<class::std::__1::pair<unsigned long,unsigned long>,1>{public:
public:typedef class::std::__1::pair<unsigned long,unsigned long>type;
}
template<>class __decay<void(*),1>{public:
public:typedef void(*type);
}
template<>class __decay<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1>{public:
public:typedef class::std::__1::__builtin_new_allocator::__builtin_new_deleter type;
}
template<>class __decay<class __compressed_pair_elem const,1>{public:
public:typedef class::std::__1::__compressed_pair_elem<int(*),0,0>type;
}
template<>class __decay<class __compressed_pair_elem const,1>{public:
public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1>type;
}
template<>class __decay<class::std::__1::__compressed_pair_elem<int(*),0,0>,1>{public:
public:typedef class::std::__1::__compressed_pair_elem<int(*),0,0>type;
}
template<>class __decay<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1>,1>{public:
public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1>type;
}
template<>class __decay<class __compressed_pair const,1>{public:
public:typedef class::std::__1::__compressed_pair<int(*),class::std::__1::allocator<int> >type;
}
template<>class __decay<nullptr_t,1>{public:
public:typedef nullptr_t type;
}
template<>class __decay<class __compressed_pair_elem const,1>{public:
public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0>type;
}
template<>class __decay<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0>,1>{public:
public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0>type;
}
template<>class __decay<class::std::__1::allocator<int>,1>{public:
public:typedef class::std::__1::allocator<int>type;
}
;
template<typename __xcodeml_template_type_0_0>class __decay<__xcodeml_template_type_0_0,1>{public:
public:typedef typename conditional<expression,typename remove_extent<__xcodeml_template_type_0_0>::type(*),typename conditional<expression,typename add_pointer<__xcodeml_template_type_0_0>::type,typename remove_cv<__xcodeml_template_type_0_0>::type>::type>::type type;
}
;
template<typename __xcodeml_template_type_0_0>class decay{private:
private:typedef typename remove_reference<__xcodeml_template_type_0_0>::type _Up;
public:
public:typedef typename __decay<typename remove_reference<__xcodeml_template_type_0_0>::type,expression>::type type;
}
;
template<>class decay<class __compressed_pair_elem const&>{private:
private:typedef class __compressed_pair_elem const _Up;
public:
public:typedef class::std::__1::__compressed_pair_elem<void(*),0,0>type;
}
template<>class decay<class __compressed_pair_elem const&>{private:
private:typedef class __compressed_pair_elem const _Up;
public:
public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0>type;
}
template<>class decay<class::std::__1::__compressed_pair_elem<void(*),0,0> >{private:
private:typedef class::std::__1::__compressed_pair_elem<void(*),0,0>_Up;
public:
public:typedef class::std::__1::__compressed_pair_elem<void(*),0,0>type;
}
template<>class decay<class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0> >{private:
private:typedef class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0>_Up;
public:
public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0>type;
}
template<>class decay<class __compressed_pair const&>{private:
private:typedef class __compressed_pair const _Up;
public:
public:typedef class::std::__1::__compressed_pair<void(*),class::std::__1::__builtin_new_allocator::__builtin_new_deleter>type;
}
template<>class decay<class::std::__1::pair<unsigned long,unsigned long> >{private:
private:typedef class::std::__1::pair<unsigned long,unsigned long>_Up;
public:
public:typedef class::std::__1::pair<unsigned long,unsigned long>type;
}
template<>class decay<void(*&)>{private:
private:typedef void(*_Up);
public:
public:typedef void(*type);
}
template<>class decay<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>{private:
private:typedef class::std::__1::__builtin_new_allocator::__builtin_new_deleter _Up;
public:
public:typedef class::std::__1::__builtin_new_allocator::__builtin_new_deleter type;
}
template<>class decay<void(*)>{private:
private:typedef void(*_Up);
public:
public:typedef void(*type);
}
template<>class decay<class __compressed_pair_elem const&>{private:
private:typedef class __compressed_pair_elem const _Up;
public:
public:typedef class::std::__1::__compressed_pair_elem<int(*),0,0>type;
}
template<>class decay<class __compressed_pair_elem const&>{private:
private:typedef class __compressed_pair_elem const _Up;
public:
public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1>type;
}
template<>class decay<class::std::__1::__compressed_pair_elem<int(*),0,0> >{private:
private:typedef class::std::__1::__compressed_pair_elem<int(*),0,0>_Up;
public:
public:typedef class::std::__1::__compressed_pair_elem<int(*),0,0>type;
}
template<>class decay<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1> >{private:
private:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1>_Up;
public:
public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1>type;
}
template<>class decay<class __compressed_pair const&>{private:
private:typedef class __compressed_pair const _Up;
public:
public:typedef class::std::__1::__compressed_pair<int(*),class::std::__1::allocator<int> >type;
}
template<>class decay<nullptr_t>{private:
private:typedef nullptr_t _Up;
public:
public:typedef nullptr_t type;
}
template<>class decay<class __compressed_pair_elem const&>{private:
private:typedef class __compressed_pair_elem const _Up;
public:
public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0>type;
}
template<>class decay<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0> >{private:
private:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0>_Up;
public:
public:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0>type;
}
template<>class decay<class::std::__1::allocator<int>&>{private:
private:typedef class::std::__1::allocator<int>_Up;
public:
public:typedef class::std::__1::allocator<int>type;
}
;
template<typename __xcodeml_template_type_0_0>using decay_t=typename decay<__xcodeml_template_type_0_0>::type;
template<typename __xcodeml_template_type_0_0>class is_abstract:public integral_constant<bool,expression>{}
;
template<>class is_abstract<void(*)>:public integral_constant<bool,0>{}
template<>class is_abstract<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>:public integral_constant<bool,0>{}
template<>class is_abstract<unsigned long>:public integral_constant<bool,0>{}
;
template<typename __xcodeml_template_type_0_0>class __libcpp_is_final:public integral_constant<bool,expression>{}
;
template<>class __libcpp_is_final<void(*)>:public integral_constant<bool,0>{}
template<>class __libcpp_is_final<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>:public integral_constant<bool,0>{}
template<>class __libcpp_is_final<int(*)>:public integral_constant<bool,0>{}
template<>class __libcpp_is_final<class::std::__1::allocator<int> >:public integral_constant<bool,0>{}
template<>class __libcpp_is_final<class::std::__1::allocator<int>&>:public integral_constant<bool,0>{}
;
template<typename __xcodeml_template_type_0_0>class is_final:public integral_constant<bool,expression>{}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class is_base_of:public integral_constant<bool,expression>{}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class is_convertible:public integral_constant<bool,expression>{}
;
template<>class is_convertible<void(*),void(*)>:public integral_constant<bool,1>{}
template<>class is_convertible<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,class::std::__1::__builtin_new_allocator::__builtin_new_deleter>:public integral_constant<bool,1>{}
template<>class is_convertible<unsigned long const&,unsigned long>:public integral_constant<bool,1>{}
template<>class is_convertible<unsigned long,unsigned long>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class is_empty:public integral_constant<bool,expression>{}
;
template<>class is_empty<void(*)>:public integral_constant<bool,0>{}
template<>class is_empty<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>:public integral_constant<bool,0>{}
template<>class is_empty<int(*)>:public integral_constant<bool,0>{}
template<>class is_empty<class::std::__1::allocator<int> >:public integral_constant<bool,1>{}
template<>class is_empty<class::std::__1::allocator<int>&>:public integral_constant<bool,0>{}
;
template<typename __xcodeml_template_type_0_0>class is_polymorphic:public integral_constant<bool,expression>{}
;
;
template<typename __xcodeml_template_type_0_0>class has_virtual_destructor:public integral_constant<bool,expression>{}
;
;
template<typename __xcodeml_template_type_0_0>class alignment_of:public integral_constant<unsigned long,expression>{}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __type_list{public:typedef __xcodeml_template_type_0_0 _Head;
public:typedef __xcodeml_template_type_0_1 _Tail;
}
;
template<>class __type_list template<>class __type_list template<>class __type_list template<>class __type_list template<>class __type_list template<>class __type_list template<>class __type_list template<>class __type_list template<>class __type_list template<>class __type_list template<>class __type_list template<>class __type_list template<>class __type_list template<>class __type_list template<>class __type_list template<>class __type_list<signed char,class::std::__1::__type_list<short,class::std::__1::__type_list<int,class::std::__1::__type_list<long,class::std::__1::__type_list<long long,class::std::__1::__type_list<__int128,class::std::__1::__nat> > > > > >{public:typedef signed char _Head;
public:typedef class::std::__1::__type_list<short,class::std::__1::__type_list<int,class::std::__1::__type_list<long,class::std::__1::__type_list<long long,class::std::__1::__type_list<__int128,class::std::__1::__nat> > > > >_Tail;
}
template<>class __type_list template<>class __type_list template<>class __type_list template<>class __type_list template<>class __type_list template<>class __type_list<unsigned char,class::std::__1::__type_list<unsigned short,class::std::__1::__type_list<unsigned int,class::std::__1::__type_list<unsigned long,class::std::__1::__type_list<unsigned long long,class::std::__1::__type_list<unsigned __int128,class::std::__1::__nat> > > > > >{public:typedef unsigned char _Head;
public:typedef class::std::__1::__type_list<unsigned short,class::std::__1::__type_list<unsigned int,class::std::__1::__type_list<unsigned long,class::std::__1::__type_list<unsigned long long,class::std::__1::__type_list<unsigned __int128,class::std::__1::__nat> > > > >_Tail;
}
;
class __nat{public:__nat();
public:__nat(class __nat const&);
public:class::std::__1::__nat&operator=(class __nat const&);
public:~__nat();
}
;
template<typename __xcodeml_template_type_0_0>class __align_type{public:static unsigned long const value=__xcodeml_template_type_0_0;
public:typedef __xcodeml_template_type_0_0 type;
}
;
template<>class __align_type<unsigned char>{public:static unsigned long const value=unsigned char;
public:typedef unsigned char type;
}
template<>class __align_type<unsigned short>{public:static unsigned long const value=unsigned short;
public:typedef unsigned short type;
}
template<>class __align_type<unsigned int>{public:static unsigned long const value=unsigned int;
public:typedef unsigned int type;
}
template<>class __align_type<unsigned long>{public:static unsigned long const value=unsigned long;
public:typedef unsigned long type;
}
template<>class __align_type<unsigned long long>{public:static unsigned long const value=unsigned long long;
public:typedef unsigned long long type;
}
template<>class __align_type<double>{public:static unsigned long const value=double;
public:typedef double type;
}
template<>class __align_type<long double>{public:static unsigned long const value=long double;
public:typedef long double type;
}
template<>class __align_type<class::std::__1::__struct_double>{public:static unsigned long const value=class::std::__1::__struct_double;
public:typedef class::std::__1::__struct_double type;
}
template<>class __align_type<class::std::__1::__struct_double4>{public:static unsigned long const value=class::std::__1::__struct_double4;
public:typedef class::std::__1::__struct_double4 type;
}
template<>class __align_type<int(*)>{public:static unsigned long const value=int(*);
public:typedef int(*type);
}
;
class __struct_double{public:long double __lx;
}
;
class __struct_double4{public:double __lx[4];
}
;
typedef class::std::__1::__type_list<class::std::__1::__align_type<unsigned char>,class::std::__1::__type_list<class::std::__1::__align_type<unsigned short>,class::std::__1::__type_list<class::std::__1::__align_type<unsigned int>,class::std::__1::__type_list<class::std::__1::__align_type<unsigned long>,class::std::__1::__type_list<class::std::__1::__align_type<unsigned long long>,class::std::__1::__type_list<class::std::__1::__align_type<double>,class::std::__1::__type_list<class::std::__1::__align_type<long double>,class::std::__1::__type_list<class::std::__1::__align_type<class::std::__1::__struct_double>,class::std::__1::__type_list<class::std::__1::__align_type<class::std::__1::__struct_double4>,class::std::__1::__type_list<class::std::__1::__align_type<int(*)>,class::std::__1::__nat> > > > > > > > > >__all_types;
template<unsigned long _Align>class __fallback_overaligned{}
;
;
template<typename __xcodeml_template_type_0_0,unsigned long _Align>class __find_pod;
;
template<typename __xcodeml_template_type_0_0,unsigned long _Align>class __find_pod<__type_list<__xcodeml_template_type_0_0,class::std::__1::__nat>,expression>{public:typedef typename conditional<expression,typename __xcodeml_template_type_0_0::type,__fallback_overaligned<expression> >::type type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,unsigned long _Align>class __find_pod<__type_list<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,expression>{public:typedef typename conditional<expression,typename __xcodeml_template_type_0_0::type,typename __find_pod<__xcodeml_template_type_0_1,expression>::type>::type type;
}
;
template<typename __xcodeml_template_type_0_0,unsigned long _Len>class __find_max_align;
template<>class __find_max_align<class::std::__1::__type_list<class::std::__1::__align_type<unsigned char>,class::std::__1::__type_list<class::std::__1::__align_type<unsigned short>,class::std::__1::__type_list<class::std::__1::__align_type<unsigned int>,class::std::__1::__type_list<class::std::__1::__align_type<unsigned long>,class::std::__1::__type_list<class::std::__1::__align_type<unsigned long long>,class::std::__1::__type_list<class::std::__1::__align_type<double>,class::std::__1::__type_list<class::std::__1::__align_type<long double>,class::std::__1::__type_list<class::std::__1::__align_type<class::std::__1::__struct_double>,class::std::__1::__type_list<class::std::__1::__align_type<class::std::__1::__struct_double4>,class::std::__1::__type_list<class::std::__1::__align_type<int(*)>,class::std::__1::__nat> > > > > > > > > >,24>:public integral_constant<unsigned long,16>{}
template<>class __find_max_align<class::std::__1::__type_list<class::std::__1::__align_type<unsigned short>,class::std::__1::__type_list<class::std::__1::__align_type<unsigned int>,class::std::__1::__type_list<class::std::__1::__align_type<unsigned long>,class::std::__1::__type_list<class::std::__1::__align_type<unsigned long long>,class::std::__1::__type_list<class::std::__1::__align_type<double>,class::std::__1::__type_list<class::std::__1::__align_type<long double>,class::std::__1::__type_list<class::std::__1::__align_type<class::std::__1::__struct_double>,class::std::__1::__type_list<class::std::__1::__align_type<class::std::__1::__struct_double4>,class::std::__1::__type_list<class::std::__1::__align_type<int(*)>,class::std::__1::__nat> > > > > > > > >,24>:public integral_constant<unsigned long,16>{}
template<>class __find_max_align<class::std::__1::__type_list<class::std::__1::__align_type<unsigned int>,class::std::__1::__type_list<class::std::__1::__align_type<unsigned long>,class::std::__1::__type_list<class::std::__1::__align_type<unsigned long long>,class::std::__1::__type_list<class::std::__1::__align_type<double>,class::std::__1::__type_list<class::std::__1::__align_type<long double>,class::std::__1::__type_list<class::std::__1::__align_type<class::std::__1::__struct_double>,class::std::__1::__type_list<class::std::__1::__align_type<class::std::__1::__struct_double4>,class::std::__1::__type_list<class::std::__1::__align_type<int(*)>,class::std::__1::__nat> > > > > > > >,24>:public integral_constant<unsigned long,16>{}
template<>class __find_max_align<class::std::__1::__type_list<class::std::__1::__align_type<unsigned long>,class::std::__1::__type_list<class::std::__1::__align_type<unsigned long long>,class::std::__1::__type_list<class::std::__1::__align_type<double>,class::std::__1::__type_list<class::std::__1::__align_type<long double>,class::std::__1::__type_list<class::std::__1::__align_type<class::std::__1::__struct_double>,class::std::__1::__type_list<class::std::__1::__align_type<class::std::__1::__struct_double4>,class::std::__1::__type_list<class::std::__1::__align_type<int(*)>,class::std::__1::__nat> > > > > > >,24>:public integral_constant<unsigned long,16>{}
template<>class __find_max_align<class::std::__1::__type_list<class::std::__1::__align_type<unsigned long long>,class::std::__1::__type_list<class::std::__1::__align_type<double>,class::std::__1::__type_list<class::std::__1::__align_type<long double>,class::std::__1::__type_list<class::std::__1::__align_type<class::std::__1::__struct_double>,class::std::__1::__type_list<class::std::__1::__align_type<class::std::__1::__struct_double4>,class::std::__1::__type_list<class::std::__1::__align_type<int(*)>,class::std::__1::__nat> > > > > >,24>:public integral_constant<unsigned long,16>{}
template<>class __find_max_align<class::std::__1::__type_list<class::std::__1::__align_type<double>,class::std::__1::__type_list<class::std::__1::__align_type<long double>,class::std::__1::__type_list<class::std::__1::__align_type<class::std::__1::__struct_double>,class::std::__1::__type_list<class::std::__1::__align_type<class::std::__1::__struct_double4>,class::std::__1::__type_list<class::std::__1::__align_type<int(*)>,class::std::__1::__nat> > > > >,24>:public integral_constant<unsigned long,16>{}
template<>class __find_max_align<class::std::__1::__type_list<class::std::__1::__align_type<long double>,class::std::__1::__type_list<class::std::__1::__align_type<class::std::__1::__struct_double>,class::std::__1::__type_list<class::std::__1::__align_type<class::std::__1::__struct_double4>,class::std::__1::__type_list<class::std::__1::__align_type<int(*)>,class::std::__1::__nat> > > >,24>:public integral_constant<unsigned long,16>{}
template<>class __find_max_align<class::std::__1::__type_list<class::std::__1::__align_type<class::std::__1::__struct_double>,class::std::__1::__type_list<class::std::__1::__align_type<class::std::__1::__struct_double4>,class::std::__1::__type_list<class::std::__1::__align_type<int(*)>,class::std::__1::__nat> > >,24>:public integral_constant<unsigned long,16>{}
template<>class __find_max_align<class::std::__1::__type_list<class::std::__1::__align_type<class::std::__1::__struct_double4>,class::std::__1::__type_list<class::std::__1::__align_type<int(*)>,class::std::__1::__nat> >,24>:public integral_constant<unsigned long,8>{}
template<>class __find_max_align<class::std::__1::__type_list<class::std::__1::__align_type<int(*)>,class::std::__1::__nat>,24>:public integral_constant<unsigned long,8>{}
;
template<typename __xcodeml_template_type_0_0,unsigned long _Len>class __find_max_align<__type_list<__xcodeml_template_type_0_0,class::std::__1::__nat>,expression>:public integral_constant<unsigned long,expression>{}
;
template<unsigned long _Len,unsigned long _A1,unsigned long _A2>class __select_align{private:
private:static unsigned long const __min=((_A2<_A1)?_A2:_A1);
private:static unsigned long const __max=((_A1<_A2)?_A2:_A1);
public:
public:static unsigned long const value=((_Len<__max)?__min:__max);
}
;
template<>class __select_align<24,8,8>{private:
private:static unsigned long const __min=((_A2<_A1)?_A2:_A1);
private:static unsigned long const __max=((_A1<_A2)?_A2:_A1);
public:
public:static unsigned long const value=((_Len<__max)?__min:__max);
}
template<>class __select_align<24,16,8>{private:
private:static unsigned long const __min=((_A2<_A1)?_A2:_A1);
private:static unsigned long const __max=((_A1<_A2)?_A2:_A1);
public:
public:static unsigned long const value=((_Len<__max)?__min:__max);
}
template<>class __select_align<24,16,16>{private:
private:static unsigned long const __min=((_A2<_A1)?_A2:_A1);
private:static unsigned long const __max=((_A1<_A2)?_A2:_A1);
public:
public:static unsigned long const value=((_Len<__max)?__min:__max);
}
template<>class __select_align<24,8,16>{private:
private:static unsigned long const __min=((_A2<_A1)?_A2:_A1);
private:static unsigned long const __max=((_A1<_A2)?_A2:_A1);
public:
public:static unsigned long const value=((_Len<__max)?__min:__max);
}
template<>class __select_align<24,4,16>{private:
private:static unsigned long const __min=((_A2<_A1)?_A2:_A1);
private:static unsigned long const __max=((_A1<_A2)?_A2:_A1);
public:
public:static unsigned long const value=((_Len<__max)?__min:__max);
}
template<>class __select_align<24,2,16>{private:
private:static unsigned long const __min=((_A2<_A1)?_A2:_A1);
private:static unsigned long const __max=((_A1<_A2)?_A2:_A1);
public:
public:static unsigned long const value=((_Len<__max)?__min:__max);
}
template<>class __select_align<24,1,16>{private:
private:static unsigned long const __min=((_A2<_A1)?_A2:_A1);
private:static unsigned long const __max=((_A1<_A2)?_A2:_A1);
public:
public:static unsigned long const value=((_Len<__max)?__min:__max);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,unsigned long _Len>class __find_max_align<__type_list<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,expression>:public integral_constant<unsigned long,expression>{}
;
template<unsigned long _Len,unsigned long _Align=__find_max_align<class::std::__1::__type_list<class::std::__1::__align_type<unsigned char>,class::std::__1::__type_list<class::std::__1::__align_type<unsigned short>,class::std::__1::__type_list<class::std::__1::__align_type<unsigned int>,class::std::__1::__type_list<class::std::__1::__align_type<unsigned long>,class::std::__1::__type_list<class::std::__1::__align_type<unsigned long long>,class::std::__1::__type_list<class::std::__1::__align_type<double>,class::std::__1::__type_list<class::std::__1::__align_type<long double>,class::std::__1::__type_list<class::std::__1::__align_type<class::std::__1::__struct_double>,class::std::__1::__type_list<class::std::__1::__align_type<class::std::__1::__struct_double4>,class::std::__1::__type_list<class::std::__1::__align_type<int(*)>,class::std::__1::__nat> > > > > > > > > >,expression>::value>class aligned_storage{public:typedef typename __find_pod<class::std::__1::__type_list<class::std::__1::__align_type<unsigned char>,class::std::__1::__type_list<class::std::__1::__align_type<unsigned short>,class::std::__1::__type_list<class::std::__1::__align_type<unsigned int>,class::std::__1::__type_list<class::std::__1::__align_type<unsigned long>,class::std::__1::__type_list<class::std::__1::__align_type<unsigned long long>,class::std::__1::__type_list<class::std::__1::__align_type<double>,class::std::__1::__type_list<class::std::__1::__align_type<long double>,class::std::__1::__type_list<class::std::__1::__align_type<class::std::__1::__struct_double>,class::std::__1::__type_list<class::std::__1::__align_type<class::std::__1::__struct_double4>,class::std::__1::__type_list<class::std::__1::__align_type<int(*)>,class::std::__1::__nat> > > > > > > > > >,expression>::type _Aligner;
public:union type{public:typename __find_pod<class::std::__1::__type_list<class::std::__1::__align_type<unsigned char>,class::std::__1::__type_list<class::std::__1::__align_type<unsigned short>,class::std::__1::__type_list<class::std::__1::__align_type<unsigned int>,class::std::__1::__type_list<class::std::__1::__align_type<unsigned long>,class::std::__1::__type_list<class::std::__1::__align_type<unsigned long long>,class::std::__1::__type_list<class::std::__1::__align_type<double>,class::std::__1::__type_list<class::std::__1::__align_type<long double>,class::std::__1::__type_list<class::std::__1::__align_type<class::std::__1::__struct_double>,class::std::__1::__type_list<class::std::__1::__align_type<class::std::__1::__struct_double4>,class::std::__1::__type_list<class::std::__1::__align_type<int(*)>,class::std::__1::__nat> > > > > > > > > >,expression>::type __align;
public:unsigned char __data[((((_Len+_Align)-1)/_Align)*_Align)];
}
;
}
;
template<>class aligned_storage<24,16>{public:class type{public:unsigned char __lx[32];
}
;
}
;
template<unsigned long _Len,unsigned long _Align=__find_max_align<class::std::__1::__type_list<class::std::__1::__align_type<unsigned char>,class::std::__1::__type_list<class::std::__1::__align_type<unsigned short>,class::std::__1::__type_list<class::std::__1::__align_type<unsigned int>,class::std::__1::__type_list<class::std::__1::__align_type<unsigned long>,class::std::__1::__type_list<class::std::__1::__align_type<unsigned long long>,class::std::__1::__type_list<class::std::__1::__align_type<double>,class::std::__1::__type_list<class::std::__1::__align_type<long double>,class::std::__1::__type_list<class::std::__1::__align_type<class::std::__1::__struct_double>,class::std::__1::__type_list<class::std::__1::__align_type<class::std::__1::__struct_double4>,class::std::__1::__type_list<class::std::__1::__align_type<int(*)>,class::std::__1::__nat> > > > > > > > > >,expression>::value>using aligned_storage_t=typename aligned_storage<expression,expression>::type;
template<unsigned long _Len>class aligned_storage<expression,1>{public:class type{public:unsigned char __lx[((((_Len+0x1)-1)/0x1)*0x1)];
}
;
}
;
template<unsigned long _Len>class aligned_storage<expression,2>{public:class type{public:unsigned char __lx[((((_Len+0x2)-1)/0x2)*0x2)];
}
;
}
;
template<unsigned long _Len>class aligned_storage<expression,4>{public:class type{public:unsigned char __lx[((((_Len+0x4)-1)/0x4)*0x4)];
}
;
}
;
template<unsigned long _Len>class aligned_storage<expression,8>{public:class type{public:unsigned char __lx[((((_Len+0x8)-1)/0x8)*0x8)];
}
;
}
;
template<unsigned long _Len>class aligned_storage<expression,16>{public:class type{public:unsigned char __lx[((((_Len+0x10)-1)/0x10)*0x10)];
}
;
}
;
template<unsigned long _Len>class aligned_storage<expression,32>{public:class type{public:unsigned char __lx[((((_Len+0x20)-1)/0x20)*0x20)];
}
;
}
;
template<unsigned long _Len>class aligned_storage<expression,64>{public:class type{public:unsigned char __lx[((((_Len+0x40)-1)/0x40)*0x40)];
}
;
}
;
template<unsigned long _Len>class aligned_storage<expression,128>{public:class type{public:unsigned char __lx[((((_Len+0x80)-1)/0x80)*0x80)];
}
;
}
;
template<unsigned long _Len>class aligned_storage<expression,256>{public:class type{public:unsigned char __lx[((((_Len+0x100)-1)/0x100)*0x100)];
}
;
}
;
template<unsigned long _Len>class aligned_storage<expression,512>{public:class type{public:unsigned char __lx[((((_Len+0x200)-1)/0x200)*0x200)];
}
;
}
;
template<unsigned long _Len>class aligned_storage<expression,1024>{public:class type{public:unsigned char __lx[((((_Len+0x400)-1)/0x400)*0x400)];
}
;
}
;
template<unsigned long _Len>class aligned_storage<expression,2048>{public:class type{public:unsigned char __lx[((((_Len+0x800)-1)/0x800)*0x800)];
}
;
}
;
template<unsigned long _Len>class aligned_storage<expression,4096>{public:class type{public:unsigned char __lx[((((_Len+0x1000)-1)/0x1000)*0x1000)];
}
;
}
;
template<unsigned long _Len>class aligned_storage<expression,8192>{public:class type{public:unsigned char __lx[((((_Len+0x2000)-1)/0x2000)*0x2000)];
}
;
}
;
template<unsigned long _Len>class aligned_storage<expression,16384>{public:class type{public:unsigned char __lx[((((_Len+0x4000)-1)/0x4000)*0x4000)];
}
;
}
;
template<unsigned long _I0,unsigned long _In>class __static_max;
;
template<unsigned long _I0>class __static_max<expression,...>{public:static unsigned long const value=_I0;
}
;
template<unsigned long _I0,unsigned long _I1,unsigned long _In>class __static_max<expression,...>{public:static unsigned long const value=((_I0>=_I1)?__static_max<expression,...>::value:__static_max<expression,...>::value);
}
;
template<unsigned long _Len,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class aligned_union{public:static unsigned long const alignment_value=__static_max<expression,...>::value;
public:static unsigned long const __len=__static_max<expression,...>::value;
public:typedef typename aligned_storage<expression,expression>::type type;
}
;
;
template<unsigned long _Len,typename __xcodeml_template_type_0_1>using aligned_union_t=typename aligned_union<expression,void/**/>::type;
template<typename __xcodeml_template_type_0_0>class __numeric_type{public:static void __test(...);
public:static float __test(float);
public:static double __test(char);
public:static double __test(int);
public:static double __test(unsigned int);
public:static double __test(long);
public:static double __test(unsigned long);
public:static double __test(long long);
public:static double __test(unsigned long long);
public:static double __test(double);
public:static long double __test(long double);
public:typedef decltype (type);
public:static bool const value=integral_constant<bool,expression>::value;
}
;
;
template<>class __numeric_type<void>{public:static bool const value=true;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,bool=((__numeric_type<__xcodeml_template_type_0_0>::value&&__numeric_type<__xcodeml_template_type_0_1>::value)&&__numeric_type<__xcodeml_template_type_0_2>::value)>class __promote_imp{public:
public:static bool const value=false;
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __promote_imp<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2,1>{private:
private:typedef typename __promote_imp<__xcodeml_template_type_0_0,void,void,expression>::type __type1;
private:typedef typename __promote_imp<__xcodeml_template_type_0_1,void,void,expression>::type __type2;
private:typedef typename __promote_imp<__xcodeml_template_type_0_2,void,void,expression>::type __type3;
public:
public:typedef decltype (type);
public:static bool const value=true;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __promote_imp<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void,1>{private:
private:typedef typename __promote_imp<__xcodeml_template_type_0_0,void,void,expression>::type __type1;
private:typedef typename __promote_imp<__xcodeml_template_type_0_1,void,void,expression>::type __type2;
public:
public:typedef decltype (type);
public:static bool const value=true;
}
;
template<typename __xcodeml_template_type_0_0>class __promote_imp<__xcodeml_template_type_0_0,void,void,1>{public:
public:typedef typename __numeric_type<__xcodeml_template_type_0_0>::type type;
public:static bool const value=true;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __promote:public __promote_imp<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2,expression>{}
;
;
typedef class::std::__1::__type_list<signed char,class::std::__1::__type_list<short,class::std::__1::__type_list<int,class::std::__1::__type_list<long,class::std::__1::__type_list<long long,class::std::__1::__type_list<__int128,class::std::__1::__nat> > > > > >__signed_types;
typedef class::std::__1::__type_list<unsigned char,class::std::__1::__type_list<unsigned short,class::std::__1::__type_list<unsigned int,class::std::__1::__type_list<unsigned long,class::std::__1::__type_list<unsigned long long,class::std::__1::__type_list<unsigned __int128,class::std::__1::__nat> > > > > >__unsigned_types;
template<typename __xcodeml_template_type_0_0,unsigned long _Size,bool=(_Size<=(sizeof(typename __xcodeml_template_type_0_0::_Head)))>class __find_first;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,unsigned long _Size>class __find_first<__type_list<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,expression,1>{public:typedef __xcodeml_template_type_0_0 type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,unsigned long _Size>class __find_first<__type_list<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,expression,0>{public:typedef typename __find_first<__xcodeml_template_type_0_1,expression,expression>::type type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,bool=is_const<typename remove_reference<__xcodeml_template_type_0_0>::type>::value,bool=is_volatile<typename remove_reference<__xcodeml_template_type_0_0>::type>::value>class __apply_cv{public:typedef __xcodeml_template_type_0_1 type;
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __apply_cv<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,1,0>{public:typedef __xcodeml_template_type_0_1 const type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __apply_cv<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,0,1>{public:typedef __xcodeml_template_type_0_1 volatile type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __apply_cv<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,1,1>{public:typedef __xcodeml_template_type_0_1 volatile const type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __apply_cv<__xcodeml_template_type_0_0&,__xcodeml_template_type_0_1,0,0>{public:typedef __xcodeml_template_type_0_1&type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __apply_cv<__xcodeml_template_type_0_0&,__xcodeml_template_type_0_1,1,0>{public:typedef __xcodeml_template_type_0_1 const&type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __apply_cv<__xcodeml_template_type_0_0&,__xcodeml_template_type_0_1,0,1>{public:typedef __xcodeml_template_type_0_1 volatile&type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __apply_cv<__xcodeml_template_type_0_0&,__xcodeml_template_type_0_1,1,1>{public:typedef __xcodeml_template_type_0_1 volatile const&type;
}
;
template<typename __xcodeml_template_type_0_0,bool=(is_integral<__xcodeml_template_type_0_0>::value||is_enum<__xcodeml_template_type_0_0>::value)>class __make_signed{}
;
;
template<typename __xcodeml_template_type_0_0>class __make_signed<__xcodeml_template_type_0_0,1>{public:typedef typename __find_first<class::std::__1::__type_list<signed char,class::std::__1::__type_list<short,class::std::__1::__type_list<int,class::std::__1::__type_list<long,class::std::__1::__type_list<long long,class::std::__1::__type_list<__int128,class::std::__1::__nat> > > > > >,expression,expression>::type type;
}
;
template<>class __make_signed<bool,1>{}
;
template<>class __make_signed<short,1>{public:typedef short type;
}
;
template<>class __make_signed<unsigned short,1>{public:typedef short type;
}
;
template<>class __make_signed<int,1>{public:typedef int type;
}
;
template<>class __make_signed<unsigned int,1>{public:typedef int type;
}
;
template<>class __make_signed<long,1>{public:typedef long type;
}
;
template<>class __make_signed<unsigned long,1>{public:typedef long type;
}
;
template<>class __make_signed<long long,1>{public:typedef long long type;
}
;
template<>class __make_signed<unsigned long long,1>{public:typedef long long type;
}
;
template<>class __make_signed<__int128,1>{public:typedef __int128 type;
}
;
template<>class __make_signed<unsigned __int128,1>{public:typedef __int128 type;
}
;
template<typename __xcodeml_template_type_0_0>class make_signed{public:typedef typename __apply_cv<__xcodeml_template_type_0_0,typename __make_signed<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::type,expression,expression>::type type;
}
;
;
template<typename __xcodeml_template_type_0_0>using make_signed_t=typename make_signed<__xcodeml_template_type_0_0>::type;
template<typename __xcodeml_template_type_0_0,bool=(is_integral<__xcodeml_template_type_0_0>::value||is_enum<__xcodeml_template_type_0_0>::value)>class __make_unsigned{}
;
;
template<typename __xcodeml_template_type_0_0>class __make_unsigned<__xcodeml_template_type_0_0,1>{public:typedef typename __find_first<class::std::__1::__type_list<unsigned char,class::std::__1::__type_list<unsigned short,class::std::__1::__type_list<unsigned int,class::std::__1::__type_list<unsigned long,class::std::__1::__type_list<unsigned long long,class::std::__1::__type_list<unsigned __int128,class::std::__1::__nat> > > > > >,expression,expression>::type type;
}
;
template<>class __make_unsigned<bool,1>{}
;
template<>class __make_unsigned<short,1>{public:typedef unsigned short type;
}
;
template<>class __make_unsigned<unsigned short,1>{public:typedef unsigned short type;
}
;
template<>class __make_unsigned<int,1>{public:typedef unsigned int type;
}
;
template<>class __make_unsigned<unsigned int,1>{public:typedef unsigned int type;
}
;
template<>class __make_unsigned<long,1>{public:typedef unsigned long type;
}
;
template<>class __make_unsigned<unsigned long,1>{public:typedef unsigned long type;
}
;
template<>class __make_unsigned<long long,1>{public:typedef unsigned long long type;
}
;
template<>class __make_unsigned<unsigned long long,1>{public:typedef unsigned long long type;
}
;
template<>class __make_unsigned<__int128,1>{public:typedef unsigned __int128 type;
}
;
template<>class __make_unsigned<unsigned __int128,1>{public:typedef unsigned __int128 type;
}
;
template<typename __xcodeml_template_type_0_0>class make_unsigned{public:typedef typename __apply_cv<__xcodeml_template_type_0_0,typename __make_unsigned<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::type,expression,expression>::type type;
}
;
;
template<typename __xcodeml_template_type_0_0>using make_unsigned_t=typename make_unsigned<__xcodeml_template_type_0_0>::type;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __common_type2_imp{}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __common_type2_imp<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,typename __void_t<decltype ()>::type>{public:typedef typename decay<decltype ()>::type type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __common_type_impl{}
;
;
template<typename __xcodeml_template_type_0_0>class __common_types;
;
template<typename __xcodeml_template_type_0_0>class common_type;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __common_type_impl<__common_types<...>,typename __void_t<typename common_type<...>::type>::type>{public:typedef typename common_type<...>::type type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>class __common_type_impl<__common_types<...>,typename __void_t<typename common_type<...>::type>::type>:public __common_type_impl<__common_types<...>,void>{}
;
template<>class common_type<...>{}
;
template<typename __xcodeml_template_type_0_0>class common_type<...>:public common_type<...>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class common_type<...>:public/**/{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>class common_type<...>:public __common_type_impl<__common_types<...>,void>{}
;
template<typename __xcodeml_template_type_0_0>using common_type_t=typename common_type<...>::type;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __select_2nd{public:typedef __xcodeml_template_type_0_1 type;
}
;
template<>class __select_2nd<unsigned long&,class::std::__1::integral_constant<bool,1> >{public:typedef class::std::__1::integral_constant<bool,1>type;
}
template<>class __select_2nd<int(*&),class::std::__1::integral_constant<bool,1> >{public:typedef class::std::__1::integral_constant<bool,1>type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename __select_2nd<decltype (),class::std::__1::integral_constant<bool,1> >::type __is_assignable_test(int)
template <>class::std::__1::integral_constant<bool,1>__is_assignable_test(int)
template <>class::std::__1::integral_constant<bool,1>__is_assignable_test(int)
template <>class::std::__1::integral_constant<bool,1>__is_assignable_test(int)
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class::std::__1::integral_constant<bool,0>__is_assignable_test(...)
template <>class::std::__1::integral_constant<bool,0>__is_assignable_test(...)
template <>class::std::__1::integral_constant<bool,0>__is_assignable_test(...)
template <>class::std::__1::integral_constant<bool,0>__is_assignable_test(...)
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,bool=(is_void<__xcodeml_template_type_0_0>::value||is_void<__xcodeml_template_type_0_1>::value)>class __is_assignable_imp:public/**/{}
;
template<>class __is_assignable_imp<unsigned long&,unsigned long const&,0>:public integral_constant<bool,1>{}
template<>class __is_assignable_imp<unsigned long&,unsigned long(*),0>:public integral_constant<bool,1>{}
template<>class __is_assignable_imp<int(*&),int(*(*)),0>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __is_assignable_imp<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,1>:public integral_constant<bool,0>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class is_assignable:public __is_assignable_imp<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,expression>{}
;
template<>class is_assignable<unsigned long&,unsigned long const&>:public __is_assignable_imp<unsigned long&,unsigned long const&,0>{}
template<>class is_assignable<unsigned long&,unsigned long(*)>:public __is_assignable_imp<unsigned long&,unsigned long(*),0>{}
template<>class is_assignable<int(*&),int(*(*))>:public __is_assignable_imp<int(*&),int(*(*)),0>{}
;
template<typename __xcodeml_template_type_0_0>class is_copy_assignable:public is_assignable<typename add_lvalue_reference<__xcodeml_template_type_0_0>::type,typename add_lvalue_reference<typename add_const<__xcodeml_template_type_0_0>::type>::type>{}
;
template<>class is_copy_assignable<unsigned long>:public is_assignable<unsigned long&,unsigned long const&>{}
;
template<typename __xcodeml_template_type_0_0>class is_move_assignable:public is_assignable<typename add_lvalue_reference<__xcodeml_template_type_0_0>::type,typename add_rvalue_reference<__xcodeml_template_type_0_0>::type>{}
;
template<>class is_move_assignable<unsigned long>:public is_assignable<unsigned long&,unsigned long(*)>{}
template<>class is_move_assignable<int(*)>:public is_assignable<int(*&),int(*(*))>{}
;
template<typename __xcodeml_template_type_0_0>class __is_destructible_apply{public:typedef int type;
}
;
;
template<typename __xcodeml_template_type_0_0>class __is_destructor_wellformed{public:template<typename __xcodeml_template_type_1_0>static char __test(typename __is_destructible_apply<decltype ()>::type)
public:template<typename __xcodeml_template_type_1_0>static class::std::__1::__two __test(...)
public:static bool const value=((sizeof((__xcodeml_template_type_0_0(12))))==(sizeof(char)));
}
;
;
template<typename __xcodeml_template_type_0_0,bool>class __destructible_imp;
;
template<typename __xcodeml_template_type_0_0>class __destructible_imp<__xcodeml_template_type_0_0,0>:public integral_constant<bool,expression>{}
;
template<typename __xcodeml_template_type_0_0>class __destructible_imp<__xcodeml_template_type_0_0,1>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0,bool>class __destructible_false;
;
template<typename __xcodeml_template_type_0_0>class __destructible_false<__xcodeml_template_type_0_0,0>:public __destructible_imp<__xcodeml_template_type_0_0,expression>{}
;
template<typename __xcodeml_template_type_0_0>class __destructible_false<__xcodeml_template_type_0_0,1>:public integral_constant<bool,0>{}
;
template<typename __xcodeml_template_type_0_0>class is_destructible:public __destructible_false<__xcodeml_template_type_0_0,expression>{}
;
;
template<typename __xcodeml_template_type_0_0>class is_destructible<__xcodeml_template_type_0_0>:public integral_constant<bool,0>{}
;
template<>class is_destructible<void>:public integral_constant<bool,0>{}
;
template<typename __xcodeml_template_type_0_0>typename remove_reference<__xcodeml_template_type_0_0>::type(*move(__xcodeml_template_type_0_0(*__t))){typedef typename remove_reference<__xcodeml_template_type_0_0>::type _Up;
return static_cast<typename remove_reference<__xcodeml_template_type_0_0>::type(*)>(__t);
}
template <>unsigned long(*move(unsigned long&__t)){typedef unsigned long _Up;
return static_cast<unsigned long(*)>(__t);
}
template <>class::std::__1::__builtin_new_allocator::__builtin_new_deleter(*move(class::std::__1::__builtin_new_allocator::__builtin_new_deleter&__t)){typedef class::std::__1::__builtin_new_allocator::__builtin_new_deleter _Up;
return static_cast<class::std::__1::__builtin_new_allocator::__builtin_new_deleter(*)>(__t);
}
template <>int(*move(int&__t)){typedef int _Up;
return static_cast<int(*)>(__t);
}
template <>int(*(*move(int(*&__t)))){typedef int(*_Up);
return static_cast<int(*(*))>(__t);
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0(*forward(typename remove_reference<__xcodeml_template_type_0_0>::type&__t)){return static_cast<__xcodeml_template_type_0_0(*)>(__t);
}
template <>unsigned long(*forward(unsigned long&__t)){return static_cast<unsigned long(*)>(__t);
}
template <>void(*&forward(void(*&__t))){return static_cast<void(*&)>(__t);
}
template <>class::std::__1::__builtin_new_allocator::__builtin_new_deleter(*forward(class::std::__1::__builtin_new_allocator::__builtin_new_deleter&__t)){return static_cast<class::std::__1::__builtin_new_allocator::__builtin_new_deleter(*)>(__t);
}
template <>void(*(*forward(void(*&__t)))){return static_cast<void(*(*))>(__t);
}
template <>nullptr_t(*forward(nullptr_t&__t)){return static_cast<nullptr_t(*)>(__t);
}
template <>int(*forward(int&__t)){return static_cast<int(*)>(__t);
}
template <>class::std::__1::allocator<int>&forward(class::std::__1::allocator<int>&__t){return static_cast<class::std::__1::allocator<int>&>(__t);
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0(*forward(typename remove_reference<__xcodeml_template_type_0_0>::type(*__t))){(!is_lvalue_reference<__xcodeml_template_type_0_0>::value)"can not forward an rvalue as an lvalue";
return static_cast<__xcodeml_template_type_0_0(*)>(__t);
}
template<typename __xcodeml_template_type_0_0>typename decay<__xcodeml_template_type_0_0>::type __decay_copy(__xcodeml_template_type_0_0(*__t)){return(std::__1::__xcodeml_template_type_0_0(__t));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __member_pointer_traits_imp<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)(void/**/),1,0>{public:typedef __xcodeml_template_type_0_1 _ClassType;
public:typedef __xcodeml_template_type_0_0 _ReturnType;
public:typedef __xcodeml_template_type_0_0 _FnType(void/**/);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __member_pointer_traits_imp<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)(void/**/,...),1,0>{public:typedef __xcodeml_template_type_0_1 _ClassType;
public:typedef __xcodeml_template_type_0_0 _ReturnType;
public:typedef __xcodeml_template_type_0_0 _FnType(void/**/,...);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __member_pointer_traits_imp<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)(void/**/)const,1,0>{public:typedef __xcodeml_template_type_0_1 const _ClassType;
public:typedef __xcodeml_template_type_0_0 _ReturnType;
public:typedef __xcodeml_template_type_0_0 _FnType(void/**/);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __member_pointer_traits_imp<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)(void/**/,...)const,1,0>{public:typedef __xcodeml_template_type_0_1 const _ClassType;
public:typedef __xcodeml_template_type_0_0 _ReturnType;
public:typedef __xcodeml_template_type_0_0 _FnType(void/**/,...);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __member_pointer_traits_imp<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)(void/**/)volatile,1,0>{public:typedef __xcodeml_template_type_0_1 volatile _ClassType;
public:typedef __xcodeml_template_type_0_0 _ReturnType;
public:typedef __xcodeml_template_type_0_0 _FnType(void/**/);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __member_pointer_traits_imp<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)(void/**/,...)volatile,1,0>{public:typedef __xcodeml_template_type_0_1 volatile _ClassType;
public:typedef __xcodeml_template_type_0_0 _ReturnType;
public:typedef __xcodeml_template_type_0_0 _FnType(void/**/,...);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __member_pointer_traits_imp<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)(void/**/)const volatile,1,0>{public:typedef __xcodeml_template_type_0_1 volatile const _ClassType;
public:typedef __xcodeml_template_type_0_0 _ReturnType;
public:typedef __xcodeml_template_type_0_0 _FnType(void/**/);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __member_pointer_traits_imp<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)(void/**/,...)const volatile,1,0>{public:typedef __xcodeml_template_type_0_1 volatile const _ClassType;
public:typedef __xcodeml_template_type_0_0 _ReturnType;
public:typedef __xcodeml_template_type_0_0 _FnType(void/**/,...);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __member_pointer_traits_imp<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)(void/**/),1,0>{public:typedef __xcodeml_template_type_0_1&_ClassType;
public:typedef __xcodeml_template_type_0_0 _ReturnType;
public:typedef __xcodeml_template_type_0_0 _FnType(void/**/);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __member_pointer_traits_imp<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)(void/**/,...),1,0>{public:typedef __xcodeml_template_type_0_1&_ClassType;
public:typedef __xcodeml_template_type_0_0 _ReturnType;
public:typedef __xcodeml_template_type_0_0 _FnType(void/**/,...);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __member_pointer_traits_imp<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)(void/**/)const,1,0>{public:typedef __xcodeml_template_type_0_1 const&_ClassType;
public:typedef __xcodeml_template_type_0_0 _ReturnType;
public:typedef __xcodeml_template_type_0_0 _FnType(void/**/);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __member_pointer_traits_imp<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)(void/**/,...)const,1,0>{public:typedef __xcodeml_template_type_0_1 const&_ClassType;
public:typedef __xcodeml_template_type_0_0 _ReturnType;
public:typedef __xcodeml_template_type_0_0 _FnType(void/**/,...);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __member_pointer_traits_imp<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)(void/**/)volatile,1,0>{public:typedef __xcodeml_template_type_0_1 volatile&_ClassType;
public:typedef __xcodeml_template_type_0_0 _ReturnType;
public:typedef __xcodeml_template_type_0_0 _FnType(void/**/);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __member_pointer_traits_imp<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)(void/**/,...)volatile,1,0>{public:typedef __xcodeml_template_type_0_1 volatile&_ClassType;
public:typedef __xcodeml_template_type_0_0 _ReturnType;
public:typedef __xcodeml_template_type_0_0 _FnType(void/**/,...);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __member_pointer_traits_imp<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)(void/**/)const volatile,1,0>{public:typedef __xcodeml_template_type_0_1 volatile const&_ClassType;
public:typedef __xcodeml_template_type_0_0 _ReturnType;
public:typedef __xcodeml_template_type_0_0 _FnType(void/**/);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __member_pointer_traits_imp<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)(void/**/,...)const volatile,1,0>{public:typedef __xcodeml_template_type_0_1 volatile const&_ClassType;
public:typedef __xcodeml_template_type_0_0 _ReturnType;
public:typedef __xcodeml_template_type_0_0 _FnType(void/**/,...);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __member_pointer_traits_imp<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)(void/**/),1,0>{public:typedef __xcodeml_template_type_0_1(*_ClassType);
public:typedef __xcodeml_template_type_0_0 _ReturnType;
public:typedef __xcodeml_template_type_0_0 _FnType(void/**/);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __member_pointer_traits_imp<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)(void/**/,...),1,0>{public:typedef __xcodeml_template_type_0_1(*_ClassType);
public:typedef __xcodeml_template_type_0_0 _ReturnType;
public:typedef __xcodeml_template_type_0_0 _FnType(void/**/,...);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __member_pointer_traits_imp<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)(void/**/)const,1,0>{public:typedef __xcodeml_template_type_0_1 const(*_ClassType);
public:typedef __xcodeml_template_type_0_0 _ReturnType;
public:typedef __xcodeml_template_type_0_0 _FnType(void/**/);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __member_pointer_traits_imp<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)(void/**/,...)const,1,0>{public:typedef __xcodeml_template_type_0_1 const(*_ClassType);
public:typedef __xcodeml_template_type_0_0 _ReturnType;
public:typedef __xcodeml_template_type_0_0 _FnType(void/**/,...);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __member_pointer_traits_imp<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)(void/**/)volatile,1,0>{public:typedef __xcodeml_template_type_0_1 volatile(*_ClassType);
public:typedef __xcodeml_template_type_0_0 _ReturnType;
public:typedef __xcodeml_template_type_0_0 _FnType(void/**/);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __member_pointer_traits_imp<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)(void/**/,...)volatile,1,0>{public:typedef __xcodeml_template_type_0_1 volatile(*_ClassType);
public:typedef __xcodeml_template_type_0_0 _ReturnType;
public:typedef __xcodeml_template_type_0_0 _FnType(void/**/,...);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __member_pointer_traits_imp<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)(void/**/)const volatile,1,0>{public:typedef __xcodeml_template_type_0_1 volatile const(*_ClassType);
public:typedef __xcodeml_template_type_0_0 _ReturnType;
public:typedef __xcodeml_template_type_0_0 _FnType(void/**/);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __member_pointer_traits_imp<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)(void/**/,...)const volatile,1,0>{public:typedef __xcodeml_template_type_0_1 volatile const(*_ClassType);
public:typedef __xcodeml_template_type_0_0 _ReturnType;
public:typedef __xcodeml_template_type_0_0 _FnType(void/**/,...);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __member_pointer_traits_imp<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*),0,1>{public:typedef __xcodeml_template_type_0_1 _ClassType;
public:typedef __xcodeml_template_type_0_0 _ReturnType;
}
;
template<typename __xcodeml_template_type_0_0>class __member_pointer_traits:public __member_pointer_traits_imp<typename remove_cv<__xcodeml_template_type_0_0>::type,expression,expression>{}
;
;
template<typename __xcodeml_template_type_0_0>class __member_pointer_class_type{}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __member_pointer_class_type<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)>{public:typedef __xcodeml_template_type_0_1 type;
}
;
template<typename __xcodeml_template_type_0_0>class result_of;
;
namespace __is_construct{class __nat{}
;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class is_constructible:public integral_constant<bool,expression>{}
;
template<>class is_constructible<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,...>:public integral_constant<bool,1>{}
template<>class is_constructible<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,...>:public integral_constant<bool,1>{}
template<>class is_constructible<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,...>:public integral_constant<bool,0>{}
template<>class is_constructible<unsigned long,...>:public integral_constant<bool,1>{}
template<>class is_constructible<unsigned long,...>:public integral_constant<bool,1>{}
template<>class is_constructible<unsigned long,...>:public integral_constant<bool,1>{}
template<>class is_constructible<int(*),...>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class is_default_constructible:public is_constructible<__xcodeml_template_type_0_0,...>{}
;
template<>class is_default_constructible template<>class is_default_constructible<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>:public is_constructible<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,...>{}
template<>class is_default_constructible template<>class is_default_constructible template<>class is_default_constructible;
template<typename __xcodeml_template_type_0_0>class is_copy_constructible:public is_constructible<__xcodeml_template_type_0_0,...>{}
;
;
template<typename __xcodeml_template_type_0_0>class is_move_constructible:public is_constructible<__xcodeml_template_type_0_0,...>{}
;
template<>class is_move_constructible<unsigned long>:public is_constructible<unsigned long,...>{}
template<>class is_move_constructible<int(*)>:public is_constructible<int(*),...>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class is_trivially_constructible:public integral_constant<bool,expression>{}
;
template<>class is_trivially_constructible<int,...>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class is_trivially_default_constructible:public is_trivially_constructible<__xcodeml_template_type_0_0,...>{}
;
;
template<typename __xcodeml_template_type_0_0>class is_trivially_copy_constructible:public is_trivially_constructible<__xcodeml_template_type_0_0,...>{}
;
;
template<typename __xcodeml_template_type_0_0>class is_trivially_move_constructible:public is_trivially_constructible<__xcodeml_template_type_0_0,...>{}
;
template<>class is_trivially_move_constructible<int>:public is_trivially_constructible<int,...>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class is_trivially_assignable:public integral_constant<bool,expression>{}
;
;
template<typename __xcodeml_template_type_0_0>class is_trivially_copy_assignable:public is_trivially_assignable<typename add_lvalue_reference<__xcodeml_template_type_0_0>::type,typename add_lvalue_reference<typename add_const<__xcodeml_template_type_0_0>::type>::type>{}
;
;
template<typename __xcodeml_template_type_0_0>class is_trivially_move_assignable:public is_trivially_assignable<typename add_lvalue_reference<__xcodeml_template_type_0_0>::type,typename add_rvalue_reference<__xcodeml_template_type_0_0>::type>{}
;
;
template<typename __xcodeml_template_type_0_0>class is_trivially_destructible:public integral_constant<bool,expression>{}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class is_nothrow_constructible:public integral_constant<bool,expression>{}
;
template<>class is_nothrow_constructible<class::std::__1::allocator<int>,...>:public integral_constant<bool,1>{}
template<>class is_nothrow_constructible<unsigned long,...>:public integral_constant<bool,1>{}
template<>class is_nothrow_constructible<unsigned long,...>:public integral_constant<bool,1>{}
template<>class is_nothrow_constructible<int(*),...>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class is_nothrow_default_constructible:public is_nothrow_constructible<__xcodeml_template_type_0_0,...>{}
;
template<>class is_nothrow_default_constructible<class::std::__1::allocator<int> >:public is_nothrow_constructible<class::std::__1::allocator<int>,...>{}
;
template<typename __xcodeml_template_type_0_0>class is_nothrow_copy_constructible:public is_nothrow_constructible<__xcodeml_template_type_0_0,...>{}
;
;
template<typename __xcodeml_template_type_0_0>class is_nothrow_move_constructible:public is_nothrow_constructible<__xcodeml_template_type_0_0,...>{}
;
template<>class is_nothrow_move_constructible<unsigned long>:public is_nothrow_constructible<unsigned long,...>{}
template<>class is_nothrow_move_constructible<int(*)>:public is_nothrow_constructible<int(*),...>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class is_nothrow_assignable:public integral_constant<bool,expression>{}
;
template<>class is_nothrow_assignable<unsigned long&,unsigned long(*)>:public integral_constant<bool,1>{}
template<>class is_nothrow_assignable<int(*&),int(*(*))>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class is_nothrow_copy_assignable:public is_nothrow_assignable<typename add_lvalue_reference<__xcodeml_template_type_0_0>::type,typename add_lvalue_reference<typename add_const<__xcodeml_template_type_0_0>::type>::type>{}
;
;
template<typename __xcodeml_template_type_0_0>class is_nothrow_move_assignable:public is_nothrow_assignable<typename add_lvalue_reference<__xcodeml_template_type_0_0>::type,typename add_rvalue_reference<__xcodeml_template_type_0_0>::type>{}
;
template<>class is_nothrow_move_assignable<unsigned long>:public is_nothrow_assignable<unsigned long&,unsigned long(*)>{}
template<>class is_nothrow_move_assignable<int(*)>:public is_nothrow_assignable<int(*&),int(*(*))>{}
;
template<bool,typename __xcodeml_template_type_0_1>class __libcpp_is_nothrow_destructible;
;
template<typename __xcodeml_template_type_0_0>class __libcpp_is_nothrow_destructible<0,__xcodeml_template_type_0_0>:public integral_constant<bool,0>{}
;
template<typename __xcodeml_template_type_0_0>class __libcpp_is_nothrow_destructible<1,__xcodeml_template_type_0_0>:public integral_constant<bool,expression>{}
;
template<typename __xcodeml_template_type_0_0>class is_nothrow_destructible:public __libcpp_is_nothrow_destructible<expression,__xcodeml_template_type_0_0>{}
;
;
template<typename __xcodeml_template_type_0_0,unsigned long _Ns>class is_nothrow_destructible<__xcodeml_template_type_0_0>:public is_nothrow_destructible<__xcodeml_template_type_0_0>{}
;
template<typename __xcodeml_template_type_0_0>class is_nothrow_destructible<__xcodeml_template_type_0_0&>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class is_nothrow_destructible<__xcodeml_template_type_0_0(*)>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class is_pod:public integral_constant<bool,expression>{}
;
;
template<typename __xcodeml_template_type_0_0>class is_literal_type:public integral_constant<bool,expression>{}
;
;
template<typename __xcodeml_template_type_0_0>class is_standard_layout:public integral_constant<bool,expression>{}
;
;
template<typename __xcodeml_template_type_0_0>class is_trivially_copyable:public integral_constant<bool,expression>{}
;
;
template<typename __xcodeml_template_type_0_0>class is_trivial:public integral_constant<bool,expression>{}
;
;
template<typename __xcodeml_template_type_0_0>class __is_reference_wrapper_impl:public integral_constant<bool,0>{}
;
;
template<typename __xcodeml_template_type_0_0>class __is_reference_wrapper_impl<reference_wrapper<__xcodeml_template_type_0_0> >:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class __is_reference_wrapper:public __is_reference_wrapper_impl<typename remove_cv<__xcodeml_template_type_0_0>::type>{}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3,typename __xcodeml_template_type_0_4>using __enable_if_bullet1=typename enable_if<expression,void>::type;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>using __enable_if_bullet2=typename enable_if<expression,void>::type;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3,typename __xcodeml_template_type_0_4>using __enable_if_bullet3=typename enable_if<expression,void>::type;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3,typename __xcodeml_template_type_0_4>using __enable_if_bullet4=typename enable_if<expression,void>::type;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>using __enable_if_bullet5=typename enable_if<expression,void>::type;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3,typename __xcodeml_template_type_0_4>using __enable_if_bullet6=typename enable_if<expression,void>::type;
template<typename __xcodeml_template_type_0_0>class::std::__1::__nat __invoke(class::std::__1::__any,void/*__args*/)
template<typename __xcodeml_template_type_0_0>class::std::__1::__nat __invoke_constexpr(class::std::__1::__any,void/*__args*/)
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>decltype (__invoke(__xcodeml_template_type_0_0(*__f),__xcodeml_template_type_0_1(*__a0),void/*__args*/)){return(((std::__1::__xcodeml_template_type_0_1(__a0)).*__f)((std::__1::__xcodeml_template_type_0_2(__args))));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>decltype (__invoke_constexpr(__xcodeml_template_type_0_0(*__f),__xcodeml_template_type_0_1(*__a0),void/*__args*/)){return(((std::__1::__xcodeml_template_type_0_1(__a0)).*__f)((std::__1::__xcodeml_template_type_0_2(__args))));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>decltype (__invoke(__xcodeml_template_type_0_0(*__f),__xcodeml_template_type_0_1(*__a0),void/*__args*/)){return(((__a0.get()).*__f)((std::__1::__xcodeml_template_type_0_2(__args))));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>decltype (__invoke_constexpr(__xcodeml_template_type_0_0(*__f),__xcodeml_template_type_0_1(*__a0),void/*__args*/)){return(((__a0.get()).*__f)((std::__1::__xcodeml_template_type_0_2(__args))));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>decltype (__invoke(__xcodeml_template_type_0_0(*__f),__xcodeml_template_type_0_1(*__a0),void/*__args*/)){return(((*(std::__1::__xcodeml_template_type_0_1(__a0))).*__f)((std::__1::__xcodeml_template_type_0_2(__args))));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>decltype (__invoke_constexpr(__xcodeml_template_type_0_0(*__f),__xcodeml_template_type_0_1(*__a0),void/*__args*/)){return(((*(std::__1::__xcodeml_template_type_0_1(__a0))).*__f)((std::__1::__xcodeml_template_type_0_2(__args))));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>decltype (__invoke(__xcodeml_template_type_0_0(*__f),__xcodeml_template_type_0_1(*__a0))){return((std::__1::__xcodeml_template_type_0_1(__a0)).*__f);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>decltype (__invoke_constexpr(__xcodeml_template_type_0_0(*__f),__xcodeml_template_type_0_1(*__a0))){return((std::__1::__xcodeml_template_type_0_1(__a0)).*__f);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>decltype (__invoke(__xcodeml_template_type_0_0(*__f),__xcodeml_template_type_0_1(*__a0))){return((__a0.get()).*__f);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>decltype (__invoke_constexpr(__xcodeml_template_type_0_0(*__f),__xcodeml_template_type_0_1(*__a0))){return((__a0.get()).*__f);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>decltype (__invoke(__xcodeml_template_type_0_0(*__f),__xcodeml_template_type_0_1(*__a0))){return((*(std::__1::__xcodeml_template_type_0_1(__a0))).*__f);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>decltype (__invoke_constexpr(__xcodeml_template_type_0_0(*__f),__xcodeml_template_type_0_1(*__a0))){return((*(std::__1::__xcodeml_template_type_0_1(__a0))).*__f);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>decltype (__invoke(__xcodeml_template_type_0_0(*__f),void/*__args*/)){return((std::__1::__xcodeml_template_type_0_0(__f))((std::__1::__xcodeml_template_type_0_1(__args))));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>decltype (__invoke_constexpr(__xcodeml_template_type_0_0(*__f),void/*__args*/)){return((std::__1::__xcodeml_template_type_0_0(__f))((std::__1::__xcodeml_template_type_0_1(__args))));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __invokable_r{public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>static decltype (__try_call(int))
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>static class::std::__1::__nat __try_call(...)
public:using _Result=decltype ();
public:using type=typename conditional<expression,typename conditional<expression,class::std::__1::integral_constant<bool,1>,is_convertible<decltype (),__xcodeml_template_type_0_0> >::type,class::std::__1::integral_constant<bool,0> >::type;
public:static bool const value=typename conditional<expression,typename conditional<expression,class::std::__1::integral_constant<bool,1>,is_convertible<decltype (),__xcodeml_template_type_0_0> >::type,class::std::__1::integral_constant<bool,0> >::type::value;
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>using __invokable=__invokable_r<void,__xcodeml_template_type_0_0,...>;
template<bool _IsInvokable,bool _IsCVVoid,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3,typename __xcodeml_template_type_0_4>class __nothrow_invokable_r_imp{public:static bool const value=false;
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __nothrow_invokable_r_imp<1,0,__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,...>{public:typedef class __nothrow_invokable_r_imp<1,0,__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,...>_ThisT;
public:template<typename __xcodeml_template_type_1_0>static void __test_noexcept(__xcodeml_template_type_1_0)
public:static bool const value=(__nothrow_invokable_r_imp::__xcodeml_template_type_0_0((std::__1::((std::__1::__xcodeml_template_type_0_1()),(std::__1::__xcodeml_template_type_0_2())))));
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __nothrow_invokable_r_imp<1,1,__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,...>{public:static bool const value=(std::__1::((std::__1::__xcodeml_template_type_0_1()),(std::__1::__xcodeml_template_type_0_2())));
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>using __nothrow_invokable_r=__nothrow_invokable_r_imp<expression,expression,__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,...>;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>using __nothrow_invokable=__nothrow_invokable_r_imp<expression,1,void,__xcodeml_template_type_0_0,...>;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __invoke_of:public enable_if<expression,typename __invokable_r<void,__xcodeml_template_type_0_0,...>::_Result>{}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class result_of<__xcodeml_template_type_0_0(void/**/)>:public __invoke_of<__xcodeml_template_type_0_0,...>{}
;
template<typename __xcodeml_template_type_0_0>using result_of_t=typename result_of<__xcodeml_template_type_0_0>::type;
template<typename __xcodeml_template_type_0_0>class __is_swappable;
;
template<typename __xcodeml_template_type_0_0>class __is_nothrow_swappable;
;
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,void>::type swap(__xcodeml_template_type_0_0&__x,__xcodeml_template_type_0_0&__y){__xcodeml_template_type_0_0 __t=(std::__1::(__x));
(__x=(std::__1::(__y)));
(__y=(std::__1::(__t)));
}
template <>void swap(unsigned long&__x,unsigned long&__y){unsigned long __t=(std::__1::move(__x));
(__x=(std::__1::move(__y)));
(__y=(std::__1::move(__t)));
}
template <>void swap(int(*&__x),int(*&__y)){int(*__t)=(std::__1::move(__x));
(__x=(std::__1::move(__y)));
(__y=(std::__1::move(__t)));
}
template<typename __xcodeml_template_type_0_0,unsigned long _Np>typename enable_if<expression,void>::type swap(__xcodeml_template_type_0_0&__a,__xcodeml_template_type_0_0&__b)
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void iter_swap(__xcodeml_template_type_0_0 __a,__xcodeml_template_type_0_1 __b){(((*__a),(*__b)));
}
namespace __detail{template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,bool _NotVoid=((!is_void<__xcodeml_template_type_0_0>::value)&&(!is_void<__xcodeml_template_type_0_1>::value))>class __swappable_with{public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>static decltype (__test_swap(int))
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>static class::std::__1::__nat __test_swap(long)
public:typedef decltype (__swap1);
public:typedef decltype (__swap2);
public:static bool const value=(integral_constant<bool,expression>::value&&integral_constant<bool,expression>::value);
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __swappable_with<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,0>:public integral_constant<bool,0>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,bool _Swappable=__swappable_with<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,expression>::value>class __nothrow_swappable_with{public:static bool const value=((((std::__1::__xcodeml_template_type_0_0()),(std::__1::__xcodeml_template_type_0_1())))&&(((std::__1::__xcodeml_template_type_0_1()),(std::__1::__xcodeml_template_type_0_0()))));
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __nothrow_swappable_with<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,0>:public integral_constant<bool,0>{}
;
}
template<typename __xcodeml_template_type_0_0>class __is_swappable:public integral_constant<bool,expression>{}
;
;
template<typename __xcodeml_template_type_0_0>class __is_nothrow_swappable:public integral_constant<bool,expression>{}
;
;
template<typename __xcodeml_template_type_0_0,bool=is_enum<__xcodeml_template_type_0_0>::value>class __underlying_type_impl;
template<>class __underlying_type_impl<enum __legacy_memory_order,1>{public:typedef unsigned int type;
}
template<>class __underlying_type_impl<enum memory_order,1>{public:typedef unsigned int type;
}
;
template<typename __xcodeml_template_type_0_0>class __underlying_type_impl<__xcodeml_template_type_0_0,0>{}
;
template<typename __xcodeml_template_type_0_0>class __underlying_type_impl<__xcodeml_template_type_0_0,1>{public:typedef void/*type*/;
}
;
template<typename __xcodeml_template_type_0_0>class underlying_type:public __underlying_type_impl<__xcodeml_template_type_0_0,expression>{}
;
template<>class underlying_type<enum __legacy_memory_order>:public __underlying_type_impl<enum __legacy_memory_order,1>{}
template<>class underlying_type<enum memory_order>:public __underlying_type_impl<enum memory_order,1>{}
;
template<typename __xcodeml_template_type_0_0>using underlying_type_t=typename underlying_type<__xcodeml_template_type_0_0>::type;
template<typename __xcodeml_template_type_0_0,bool=is_enum<__xcodeml_template_type_0_0>::value>class __sfinae_underlying_type{public:typedef typename underlying_type<__xcodeml_template_type_0_0>::type type;
public:typedef decltype (__promoted_type);
}
;
;
template<typename __xcodeml_template_type_0_0>class __sfinae_underlying_type<__xcodeml_template_type_0_0,0>{}
;
int __convert_to_integral(int __val){return __val;
}
unsigned int __convert_to_integral(unsigned int __val){return __val;
}
long __convert_to_integral(long __val){return __val;
}
unsigned long __convert_to_integral(unsigned long __val){return __val;
}
long long __convert_to_integral(long long __val){return __val;
}
unsigned long long __convert_to_integral(unsigned long long __val){return __val;
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,long long>::type __convert_to_integral(__xcodeml_template_type_0_0 __val){return __val;
}
__int128 __convert_to_integral(__int128 __val){return __val;
}
unsigned __int128 __convert_to_integral(unsigned __int128 __val){return __val;
}
template<typename __xcodeml_template_type_0_0>typename __sfinae_underlying_type<__xcodeml_template_type_0_0,expression>::__promoted_type __convert_to_integral(__xcodeml_template_type_0_0 __val){return __val;
}
template<typename __xcodeml_template_type_0_0>class __has_operator_addressof_member_imp{public:template<typename __xcodeml_template_type_1_0>static typename __select_2nd<decltype (),class::std::__1::integral_constant<bool,1> >::type __test(int)
public:template<typename __xcodeml_template_type_1_0>static class::std::__1::integral_constant<bool,0>__test(long)
public:static bool const value=decltype ()::value;
}
;
;
template<typename __xcodeml_template_type_0_0>class __has_operator_addressof_free_imp{public:template<typename __xcodeml_template_type_1_0>static typename __select_2nd<decltype (),class::std::__1::integral_constant<bool,1> >::type __test(int)
public:template<typename __xcodeml_template_type_1_0>static class::std::__1::integral_constant<bool,0>__test(long)
public:static bool const value=decltype ()::value;
}
;
;
template<typename __xcodeml_template_type_0_0>class __has_operator_addressof:public integral_constant<bool,expression>{}
;
;
class __extract_key_fail_tag{}
;
class __extract_key_self_tag{}
;
class __extract_key_first_tag{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __can_extract_key:public/**/{}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>class __can_extract_key<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,pair<__xcodeml_template_type_0_2,__xcodeml_template_type_0_3> >:public/**/{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>class __can_extract_map_key:public integral_constant<bool,expression>{}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __can_extract_map_key<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2>:public integral_constant<bool,0>{}
;
bool __libcpp_is_constant_evaluated(){return(__builtin_is_constant_evaluated());
}
template<typename __xcodeml_template_type_0_0>using _IsCharLikeType=void/**/;
constexpr bool const integral_constant::value;
constexpr bool const integral_constant::value;
constexpr unsigned long const integral_constant::value;
constexpr unsigned long const integral_constant::value;
constexpr unsigned long const integral_constant::value;
constexpr unsigned long const integral_constant::value;
}
}
namespace std{namespace __1{enum float_round_style{round_indeterminate=(-1),round_toward_zero=0,round_to_nearest=1,round_toward_infinity=2,round_toward_neg_infinity=3};
enum float_denorm_style{denorm_indeterminate=(-1),denorm_absent=0,denorm_present=1};
template<typename __xcodeml_template_type_0_0,bool=is_arithmetic<__xcodeml_template_type_0_0>::value>class __libcpp_numeric_limits{protected:
protected:typedef __xcodeml_template_type_0_0 type;
protected:constexpr static bool const is_specialized=false;
protected:static __xcodeml_template_type_0_0 min(){return __xcodeml_identity<__xcodeml_template_type_0_0>::t();
}
protected:static __xcodeml_template_type_0_0 max(){return __xcodeml_identity<__xcodeml_template_type_0_0>::t();
}
protected:static __xcodeml_template_type_0_0 lowest(){return __xcodeml_identity<__xcodeml_template_type_0_0>::t();
}
protected:constexpr static int const digits=0;
protected:constexpr static int const digits10=0;
protected:constexpr static int const max_digits10=0;
protected:constexpr static bool const is_signed=false;
protected:constexpr static bool const is_integer=false;
protected:constexpr static bool const is_exact=false;
protected:constexpr static int const radix=0;
protected:static __xcodeml_template_type_0_0 epsilon(){return __xcodeml_identity<__xcodeml_template_type_0_0>::t();
}
protected:static __xcodeml_template_type_0_0 round_error(){return __xcodeml_identity<__xcodeml_template_type_0_0>::t();
}
protected:constexpr static int const min_exponent=0;
protected:constexpr static int const min_exponent10=0;
protected:constexpr static int const max_exponent=0;
protected:constexpr static int const max_exponent10=0;
protected:constexpr static bool const has_infinity=false;
protected:constexpr static bool const has_quiet_NaN=false;
protected:constexpr static bool const has_signaling_NaN=false;
protected:constexpr static enum float_denorm_style const has_denorm=denorm_absent;
protected:constexpr static bool const has_denorm_loss=false;
protected:static __xcodeml_template_type_0_0 infinity(){return __xcodeml_identity<__xcodeml_template_type_0_0>::t();
}
protected:static __xcodeml_template_type_0_0 quiet_NaN(){return __xcodeml_identity<__xcodeml_template_type_0_0>::t();
}
protected:static __xcodeml_template_type_0_0 signaling_NaN(){return __xcodeml_identity<__xcodeml_template_type_0_0>::t();
}
protected:static __xcodeml_template_type_0_0 denorm_min(){return __xcodeml_identity<__xcodeml_template_type_0_0>::t();
}
protected:constexpr static bool const is_iec559=false;
protected:constexpr static bool const is_bounded=false;
protected:constexpr static bool const is_modulo=false;
protected:constexpr static bool const traps=false;
protected:constexpr static bool const tinyness_before=false;
protected:constexpr static enum float_round_style const round_style=round_toward_zero;
}
;
template<>class __libcpp_numeric_limits<unsigned long long,1>{protected:
protected:typedef unsigned long long type;
protected:constexpr static bool const is_specialized=true;
protected:constexpr static bool const is_signed=((()(-1))<(()0));
protected:constexpr static int const digits=static_cast<>((((sizeof(unsigned long long))*8)-is_signed));
protected:constexpr static int const digits10=((digits*3)/10);
protected:constexpr static int const max_digits10=0;
protected:constexpr static unsigned long long const __min=__libcpp_compute_min::value;
protected:constexpr static unsigned long long const __max=(is_signed?(()((()(~0))^__min)):(()(~0)));
protected:static unsigned long long min();
protected:static unsigned long long max();
protected:static unsigned long long lowest();
protected:constexpr static bool const is_integer=true;
protected:constexpr static bool const is_exact=true;
protected:constexpr static int const radix=2;
protected:static unsigned long long epsilon();
protected:static unsigned long long round_error();
protected:constexpr static int const min_exponent=0;
protected:constexpr static int const min_exponent10=0;
protected:constexpr static int const max_exponent=0;
protected:constexpr static int const max_exponent10=0;
protected:constexpr static bool const has_infinity=false;
protected:constexpr static bool const has_quiet_NaN=false;
protected:constexpr static bool const has_signaling_NaN=false;
protected:constexpr static enum float_denorm_style const has_denorm=denorm_absent;
protected:constexpr static bool const has_denorm_loss=false;
protected:static unsigned long long infinity();
protected:static unsigned long long quiet_NaN();
protected:static unsigned long long signaling_NaN();
protected:static unsigned long long denorm_min();
protected:constexpr static bool const is_iec559=false;
protected:constexpr static bool const is_bounded=true;
protected:constexpr static bool const is_modulo=(!std::__1::is_signed::value);
protected:constexpr static bool const traps=true;
protected:constexpr static bool const tinyness_before=false;
protected:constexpr static enum float_round_style const round_style=round_toward_zero;
}
template<>class __libcpp_numeric_limits<unsigned int,1>{protected:
protected:typedef unsigned int type;
protected:constexpr static bool const is_specialized=true;
protected:constexpr static bool const is_signed=((()(-1))<(()0));
protected:constexpr static int const digits=static_cast<>((((sizeof(unsigned int))*8)-is_signed));
protected:constexpr static int const digits10=((digits*3)/10);
protected:constexpr static int const max_digits10=0;
protected:constexpr static unsigned int const __min=__libcpp_compute_min::value;
protected:constexpr static unsigned int const __max=(is_signed?(()((()(~0))^__min)):(()(~0)));
protected:static unsigned int min();
protected:static unsigned int max();
protected:static unsigned int lowest();
protected:constexpr static bool const is_integer=true;
protected:constexpr static bool const is_exact=true;
protected:constexpr static int const radix=2;
protected:static unsigned int epsilon();
protected:static unsigned int round_error();
protected:constexpr static int const min_exponent=0;
protected:constexpr static int const min_exponent10=0;
protected:constexpr static int const max_exponent=0;
protected:constexpr static int const max_exponent10=0;
protected:constexpr static bool const has_infinity=false;
protected:constexpr static bool const has_quiet_NaN=false;
protected:constexpr static bool const has_signaling_NaN=false;
protected:constexpr static enum float_denorm_style const has_denorm=denorm_absent;
protected:constexpr static bool const has_denorm_loss=false;
protected:static unsigned int infinity();
protected:static unsigned int quiet_NaN();
protected:static unsigned int signaling_NaN();
protected:static unsigned int denorm_min();
protected:constexpr static bool const is_iec559=false;
protected:constexpr static bool const is_bounded=true;
protected:constexpr static bool const is_modulo=(!std::__1::is_signed::value);
protected:constexpr static bool const traps=true;
protected:constexpr static bool const tinyness_before=false;
protected:constexpr static enum float_round_style const round_style=round_toward_zero;
}
template<>class __libcpp_numeric_limits<unsigned long,1>{protected:
protected:typedef unsigned long type;
protected:constexpr static bool const is_specialized=true;
protected:constexpr static bool const is_signed=((()(-1))<(()0));
protected:constexpr static int const digits=static_cast<>((((sizeof(unsigned long))*8)-is_signed));
protected:constexpr static int const digits10=((digits*3)/10);
protected:constexpr static int const max_digits10=0;
protected:constexpr static unsigned long const __min=__libcpp_compute_min::value;
protected:constexpr static unsigned long const __max=(is_signed?(()((()(~0))^__min)):(()(~0)));
protected:static unsigned long min();
protected:static unsigned long max();
protected:static unsigned long lowest();
protected:constexpr static bool const is_integer=true;
protected:constexpr static bool const is_exact=true;
protected:constexpr static int const radix=2;
protected:static unsigned long epsilon();
protected:static unsigned long round_error();
protected:constexpr static int const min_exponent=0;
protected:constexpr static int const min_exponent10=0;
protected:constexpr static int const max_exponent=0;
protected:constexpr static int const max_exponent10=0;
protected:constexpr static bool const has_infinity=false;
protected:constexpr static bool const has_quiet_NaN=false;
protected:constexpr static bool const has_signaling_NaN=false;
protected:constexpr static enum float_denorm_style const has_denorm=denorm_absent;
protected:constexpr static bool const has_denorm_loss=false;
protected:static unsigned long infinity();
protected:static unsigned long quiet_NaN();
protected:static unsigned long signaling_NaN();
protected:static unsigned long denorm_min();
protected:constexpr static bool const is_iec559=false;
protected:constexpr static bool const is_bounded=true;
protected:constexpr static bool const is_modulo=(!std::__1::is_signed::value);
protected:constexpr static bool const traps=true;
protected:constexpr static bool const tinyness_before=false;
protected:constexpr static enum float_round_style const round_style=round_toward_zero;
}
template<>class __libcpp_numeric_limits<long,1>{protected:
protected:typedef long type;
protected:constexpr static bool const is_specialized=true;
protected:constexpr static bool const is_signed=((()(-1))<(()0));
protected:constexpr static int const digits=static_cast<>((((sizeof(long))*8)-is_signed));
protected:constexpr static int const digits10=((digits*3)/10);
protected:constexpr static int const max_digits10=0;
protected:constexpr static long const __min=__libcpp_compute_min::value;
protected:constexpr static long const __max=(is_signed?(()((()(~0))^__min)):(()(~0)));
protected:static long min();
protected:static long max(){return __max;
}
protected:static long lowest();
protected:constexpr static bool const is_integer=true;
protected:constexpr static bool const is_exact=true;
protected:constexpr static int const radix=2;
protected:static long epsilon();
protected:static long round_error();
protected:constexpr static int const min_exponent=0;
protected:constexpr static int const min_exponent10=0;
protected:constexpr static int const max_exponent=0;
protected:constexpr static int const max_exponent10=0;
protected:constexpr static bool const has_infinity=false;
protected:constexpr static bool const has_quiet_NaN=false;
protected:constexpr static bool const has_signaling_NaN=false;
protected:constexpr static enum float_denorm_style const has_denorm=denorm_absent;
protected:constexpr static bool const has_denorm_loss=false;
protected:static long infinity();
protected:static long quiet_NaN();
protected:static long signaling_NaN();
protected:static long denorm_min();
protected:constexpr static bool const is_iec559=false;
protected:constexpr static bool const is_bounded=true;
protected:constexpr static bool const is_modulo=(!std::__1::is_signed::value);
protected:constexpr static bool const traps=true;
protected:constexpr static bool const tinyness_before=false;
protected:constexpr static enum float_round_style const round_style=round_toward_zero;
}
;
template<typename __xcodeml_template_type_0_0,int __digits,bool _IsSigned>class __libcpp_compute_min{public:constexpr static __xcodeml_template_type_0_0 const value=__xcodeml_identity<__xcodeml_template_type_0_0>::t((__xcodeml_identity<__xcodeml_template_type_0_0>::t(1)<<__digits));
}
;
template<>class __libcpp_compute_min<unsigned long long,64,0>{public:constexpr static unsigned long long const value=(()0);
}
template<>class __libcpp_compute_min<unsigned int,32,0>{public:constexpr static unsigned int const value=(()0);
}
template<>class __libcpp_compute_min<unsigned long,64,0>{public:constexpr static unsigned long const value=(()0);
}
template<>class __libcpp_compute_min<long,63,1>{public:constexpr static long const value=(()((()1)<<__digits));
}
;
template<typename __xcodeml_template_type_0_0,int __digits>class __libcpp_compute_min<__xcodeml_template_type_0_0,expression,0>{public:constexpr static __xcodeml_template_type_0_0 const value=__xcodeml_identity<__xcodeml_template_type_0_0>::t(0);
}
;
template<typename __xcodeml_template_type_0_0>class __libcpp_numeric_limits<__xcodeml_template_type_0_0,1>{protected:
protected:typedef __xcodeml_template_type_0_0 type;
protected:constexpr static bool const is_specialized=true;
protected:constexpr static bool const is_signed=(__xcodeml_identity<__xcodeml_template_type_0_0>::t((-1))<__xcodeml_identity<__xcodeml_template_type_0_0>::t(0));
protected:constexpr static int const digits=static_cast<>((((sizeof(__xcodeml_template_type_0_0))*8)-is_signed));
protected:constexpr static int const digits10=((digits*3)/10);
protected:constexpr static int const max_digits10=0;
protected:constexpr static __xcodeml_template_type_0_0 const __min=__libcpp_compute_min<__xcodeml_template_type_0_0,expression,expression>::value;
protected:constexpr static __xcodeml_template_type_0_0 const __max=(is_signed?__xcodeml_identity<__xcodeml_template_type_0_0>::t((__xcodeml_identity<__xcodeml_template_type_0_0>::t((~0))^__min)):__xcodeml_identity<__xcodeml_template_type_0_0>::t((~0)));
protected:static __xcodeml_template_type_0_0 min(){return __min;
}
protected:static __xcodeml_template_type_0_0 max(){return __max;
}
protected:static __xcodeml_template_type_0_0 lowest(){return(min());
}
protected:constexpr static bool const is_integer=true;
protected:constexpr static bool const is_exact=true;
protected:constexpr static int const radix=2;
protected:static __xcodeml_template_type_0_0 epsilon(){return __xcodeml_identity<__xcodeml_template_type_0_0>::t(0);
}
protected:static __xcodeml_template_type_0_0 round_error(){return __xcodeml_identity<__xcodeml_template_type_0_0>::t(0);
}
protected:constexpr static int const min_exponent=0;
protected:constexpr static int const min_exponent10=0;
protected:constexpr static int const max_exponent=0;
protected:constexpr static int const max_exponent10=0;
protected:constexpr static bool const has_infinity=false;
protected:constexpr static bool const has_quiet_NaN=false;
protected:constexpr static bool const has_signaling_NaN=false;
protected:constexpr static enum float_denorm_style const has_denorm=denorm_absent;
protected:constexpr static bool const has_denorm_loss=false;
protected:static __xcodeml_template_type_0_0 infinity(){return __xcodeml_identity<__xcodeml_template_type_0_0>::t(0);
}
protected:static __xcodeml_template_type_0_0 quiet_NaN(){return __xcodeml_identity<__xcodeml_template_type_0_0>::t(0);
}
protected:static __xcodeml_template_type_0_0 signaling_NaN(){return __xcodeml_identity<__xcodeml_template_type_0_0>::t(0);
}
protected:static __xcodeml_template_type_0_0 denorm_min(){return __xcodeml_identity<__xcodeml_template_type_0_0>::t(0);
}
protected:constexpr static bool const is_iec559=false;
protected:constexpr static bool const is_bounded=true;
protected:constexpr static bool const is_modulo=(!std::__1::is_signed<__xcodeml_template_type_0_0>::value);
protected:constexpr static bool const traps=true;
protected:constexpr static bool const tinyness_before=false;
protected:constexpr static enum float_round_style const round_style=round_toward_zero;
}
;
template<>class __libcpp_numeric_limits<bool,1>{protected:
protected:typedef bool type;
protected:constexpr static bool const is_specialized=true;
protected:constexpr static bool const is_signed=false;
protected:constexpr static int const digits=1;
protected:constexpr static int const digits10=0;
protected:constexpr static int const max_digits10=0;
protected:constexpr static bool const __min=false;
protected:constexpr static bool const __max=true;
protected:static bool min(){return __min;
}
protected:static bool max(){return __max;
}
protected:static bool lowest(){return(min());
}
protected:constexpr static bool const is_integer=true;
protected:constexpr static bool const is_exact=true;
protected:constexpr static int const radix=2;
protected:static bool epsilon(){return((bool)0);
}
protected:static bool round_error(){return((bool)0);
}
protected:constexpr static int const min_exponent=0;
protected:constexpr static int const min_exponent10=0;
protected:constexpr static int const max_exponent=0;
protected:constexpr static int const max_exponent10=0;
protected:constexpr static bool const has_infinity=false;
protected:constexpr static bool const has_quiet_NaN=false;
protected:constexpr static bool const has_signaling_NaN=false;
protected:constexpr static enum float_denorm_style const has_denorm=denorm_absent;
protected:constexpr static bool const has_denorm_loss=false;
protected:static bool infinity(){return((bool)0);
}
protected:static bool quiet_NaN(){return((bool)0);
}
protected:static bool signaling_NaN(){return((bool)0);
}
protected:static bool denorm_min(){return((bool)0);
}
protected:constexpr static bool const is_iec559=false;
protected:constexpr static bool const is_bounded=true;
protected:constexpr static bool const is_modulo=false;
protected:constexpr static bool const traps=false;
protected:constexpr static bool const tinyness_before=false;
protected:constexpr static enum float_round_style const round_style=round_toward_zero;
}
;
template<>class __libcpp_numeric_limits<float,1>{protected:
protected:typedef float type;
protected:constexpr static bool const is_specialized=true;
protected:constexpr static bool const is_signed=true;
protected:constexpr static int const digits=24;
protected:constexpr static int const digits10=6;
protected:constexpr static int const max_digits10=(2+((digits*30103l)/100000l));
protected:static float min(){return;
}
protected:static float max(){return;
}
protected:static float lowest(){return(-(max()));
}
protected:constexpr static bool const is_integer=false;
protected:constexpr static bool const is_exact=false;
protected:constexpr static int const radix=2;
protected:static float epsilon(){return;
}
protected:static float round_error(){return 0.5F;
}
protected:constexpr static int const min_exponent=(-125);
protected:constexpr static int const min_exponent10=(-37);
protected:constexpr static int const max_exponent=128;
protected:constexpr static int const max_exponent10=38;
protected:constexpr static bool const has_infinity=true;
protected:constexpr static bool const has_quiet_NaN=true;
protected:constexpr static bool const has_signaling_NaN=true;
protected:constexpr static enum float_denorm_style const has_denorm=denorm_present;
protected:constexpr static bool const has_denorm_loss=false;
protected:static float infinity(){return(__builtin_huge_valf());
}
protected:static float quiet_NaN(){return(__builtin_nanf(""));
}
protected:static float signaling_NaN(){return(__builtin_nansf(""));
}
protected:static float denorm_min(){return;
}
protected:constexpr static bool const is_iec559=true;
protected:constexpr static bool const is_bounded=true;
protected:constexpr static bool const is_modulo=false;
protected:constexpr static bool const traps=false;
protected:constexpr static bool const tinyness_before=false;
protected:constexpr static enum float_round_style const round_style=round_to_nearest;
}
;
template<>class __libcpp_numeric_limits<double,1>{protected:
protected:typedef double type;
protected:constexpr static bool const is_specialized=true;
protected:constexpr static bool const is_signed=true;
protected:constexpr static int const digits=53;
protected:constexpr static int const digits10=15;
protected:constexpr static int const max_digits10=(2+((digits*30103l)/100000l));
protected:static double min(){return;
}
protected:static double max(){return;
}
protected:static double lowest(){return(-(max()));
}
protected:constexpr static bool const is_integer=false;
protected:constexpr static bool const is_exact=false;
protected:constexpr static int const radix=2;
protected:static double epsilon(){return;
}
protected:static double round_error(){return 0.5;
}
protected:constexpr static int const min_exponent=(-1021);
protected:constexpr static int const min_exponent10=(-307);
protected:constexpr static int const max_exponent=1024;
protected:constexpr static int const max_exponent10=308;
protected:constexpr static bool const has_infinity=true;
protected:constexpr static bool const has_quiet_NaN=true;
protected:constexpr static bool const has_signaling_NaN=true;
protected:constexpr static enum float_denorm_style const has_denorm=denorm_present;
protected:constexpr static bool const has_denorm_loss=false;
protected:static double infinity(){return(__builtin_huge_val());
}
protected:static double quiet_NaN(){return(__builtin_nan(""));
}
protected:static double signaling_NaN(){return(__builtin_nans(""));
}
protected:static double denorm_min(){return;
}
protected:constexpr static bool const is_iec559=true;
protected:constexpr static bool const is_bounded=true;
protected:constexpr static bool const is_modulo=false;
protected:constexpr static bool const traps=false;
protected:constexpr static bool const tinyness_before=false;
protected:constexpr static enum float_round_style const round_style=round_to_nearest;
}
;
template<>class __libcpp_numeric_limits<long double,1>{protected:
protected:typedef long double type;
protected:constexpr static bool const is_specialized=true;
protected:constexpr static bool const is_signed=true;
protected:constexpr static int const digits=64;
protected:constexpr static int const digits10=18;
protected:constexpr static int const max_digits10=(2+((digits*30103l)/100000l));
protected:static long double min(){return;
}
protected:static long double max(){return;
}
protected:static long double lowest(){return(-(max()));
}
protected:constexpr static bool const is_integer=false;
protected:constexpr static bool const is_exact=false;
protected:constexpr static int const radix=2;
protected:static long double epsilon(){return;
}
protected:static long double round_error(){return 0.5L;
}
protected:constexpr static int const min_exponent=(-16381);
protected:constexpr static int const min_exponent10=(-4931);
protected:constexpr static int const max_exponent=16384;
protected:constexpr static int const max_exponent10=4932;
protected:constexpr static bool const has_infinity=true;
protected:constexpr static bool const has_quiet_NaN=true;
protected:constexpr static bool const has_signaling_NaN=true;
protected:constexpr static enum float_denorm_style const has_denorm=denorm_present;
protected:constexpr static bool const has_denorm_loss=false;
protected:static long double infinity(){return(__builtin_huge_vall());
}
protected:static long double quiet_NaN(){return(__builtin_nanl(""));
}
protected:static long double signaling_NaN(){return(__builtin_nansl(""));
}
protected:static long double denorm_min(){return;
}
protected:constexpr static bool const is_iec559=true;
protected:constexpr static bool const is_bounded=true;
protected:constexpr static bool const is_modulo=false;
protected:constexpr static bool const traps=false;
protected:constexpr static bool const tinyness_before=false;
protected:constexpr static enum float_round_style const round_style=round_to_nearest;
}
;
template<typename __xcodeml_template_type_0_0>class numeric_limits:private __libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>{private:typedef __libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>;
private:typedef typename __libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::type type;
public:
public:constexpr static bool const is_specialized=__libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::is_specialized;
public:static typename __libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::type min(){return(__libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::min());
}
public:static typename __libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::type max(){return(__libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::max());
}
public:static typename __libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::type lowest(){return(__libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::lowest());
}
public:constexpr static int const digits=__libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::digits;
public:constexpr static int const digits10=__libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::digits10;
public:constexpr static int const max_digits10=__libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::max_digits10;
public:constexpr static bool const is_signed=__libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::is_signed;
public:constexpr static bool const is_integer=__libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::is_integer;
public:constexpr static bool const is_exact=__libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::is_exact;
public:constexpr static int const radix=__libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::radix;
public:static typename __libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::type epsilon(){return(__libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::epsilon());
}
public:static typename __libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::type round_error(){return(__libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::round_error());
}
public:constexpr static int const min_exponent=__libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::min_exponent;
public:constexpr static int const min_exponent10=__libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::min_exponent10;
public:constexpr static int const max_exponent=__libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::max_exponent;
public:constexpr static int const max_exponent10=__libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::max_exponent10;
public:constexpr static bool const has_infinity=__libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::has_infinity;
public:constexpr static bool const has_quiet_NaN=__libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::has_quiet_NaN;
public:constexpr static bool const has_signaling_NaN=__libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::has_signaling_NaN;
public:constexpr static enum float_denorm_style const has_denorm=__libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::has_denorm;
public:constexpr static bool const has_denorm_loss=__libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::has_denorm_loss;
public:static typename __libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::type infinity(){return(__libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::infinity());
}
public:static typename __libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::type quiet_NaN(){return(__libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::quiet_NaN());
}
public:static typename __libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::type signaling_NaN(){return(__libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::signaling_NaN());
}
public:static typename __libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::type denorm_min(){return(__libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::denorm_min());
}
public:constexpr static bool const is_iec559=__libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::is_iec559;
public:constexpr static bool const is_bounded=__libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::is_bounded;
public:constexpr static bool const is_modulo=__libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::is_modulo;
public:constexpr static bool const traps=__libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::traps;
public:constexpr static bool const tinyness_before=__libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::tinyness_before;
public:constexpr static enum float_round_style const round_style=__libcpp_numeric_limits<typename remove_cv<__xcodeml_template_type_0_0>::type,expression>::round_style;
}
;
template<>class numeric_limits<unsigned long long>:private __libcpp_numeric_limits<unsigned long long,1>{private:typedef class::std::__1::__libcpp_numeric_limits<unsigned long long,1>__base;
private:typedef unsigned long long type;
public:
public:constexpr static bool const is_specialized=__libcpp_numeric_limits::is_specialized;
public:static unsigned long long min();
public:static unsigned long long max();
public:static unsigned long long lowest();
public:constexpr static int const digits=__libcpp_numeric_limits::digits;
public:constexpr static int const digits10=__libcpp_numeric_limits::digits10;
public:constexpr static int const max_digits10=__libcpp_numeric_limits::max_digits10;
public:constexpr static bool const is_signed=__libcpp_numeric_limits::is_signed;
public:constexpr static bool const is_integer=__libcpp_numeric_limits::is_integer;
public:constexpr static bool const is_exact=__libcpp_numeric_limits::is_exact;
public:constexpr static int const radix=__libcpp_numeric_limits::radix;
public:static unsigned long long epsilon();
public:static unsigned long long round_error();
public:constexpr static int const min_exponent=__libcpp_numeric_limits::min_exponent;
public:constexpr static int const min_exponent10=__libcpp_numeric_limits::min_exponent10;
public:constexpr static int const max_exponent=__libcpp_numeric_limits::max_exponent;
public:constexpr static int const max_exponent10=__libcpp_numeric_limits::max_exponent10;
public:constexpr static bool const has_infinity=__libcpp_numeric_limits::has_infinity;
public:constexpr static bool const has_quiet_NaN=__libcpp_numeric_limits::has_quiet_NaN;
public:constexpr static bool const has_signaling_NaN=__libcpp_numeric_limits::has_signaling_NaN;
public:constexpr static enum float_denorm_style const has_denorm=__libcpp_numeric_limits::has_denorm;
public:constexpr static bool const has_denorm_loss=__libcpp_numeric_limits::has_denorm_loss;
public:static unsigned long long infinity();
public:static unsigned long long quiet_NaN();
public:static unsigned long long signaling_NaN();
public:static unsigned long long denorm_min();
public:constexpr static bool const is_iec559=__libcpp_numeric_limits::is_iec559;
public:constexpr static bool const is_bounded=__libcpp_numeric_limits::is_bounded;
public:constexpr static bool const is_modulo=__libcpp_numeric_limits::is_modulo;
public:constexpr static bool const traps=__libcpp_numeric_limits::traps;
public:constexpr static bool const tinyness_before=__libcpp_numeric_limits::tinyness_before;
public:constexpr static enum float_round_style const round_style=__libcpp_numeric_limits::round_style;
}
template<>class numeric_limits<unsigned int>:private __libcpp_numeric_limits<unsigned int,1>{private:typedef class::std::__1::__libcpp_numeric_limits<unsigned int,1>__base;
private:typedef unsigned int type;
public:
public:constexpr static bool const is_specialized=__libcpp_numeric_limits::is_specialized;
public:static unsigned int min();
public:static unsigned int max();
public:static unsigned int lowest();
public:constexpr static int const digits=__libcpp_numeric_limits::digits;
public:constexpr static int const digits10=__libcpp_numeric_limits::digits10;
public:constexpr static int const max_digits10=__libcpp_numeric_limits::max_digits10;
public:constexpr static bool const is_signed=__libcpp_numeric_limits::is_signed;
public:constexpr static bool const is_integer=__libcpp_numeric_limits::is_integer;
public:constexpr static bool const is_exact=__libcpp_numeric_limits::is_exact;
public:constexpr static int const radix=__libcpp_numeric_limits::radix;
public:static unsigned int epsilon();
public:static unsigned int round_error();
public:constexpr static int const min_exponent=__libcpp_numeric_limits::min_exponent;
public:constexpr static int const min_exponent10=__libcpp_numeric_limits::min_exponent10;
public:constexpr static int const max_exponent=__libcpp_numeric_limits::max_exponent;
public:constexpr static int const max_exponent10=__libcpp_numeric_limits::max_exponent10;
public:constexpr static bool const has_infinity=__libcpp_numeric_limits::has_infinity;
public:constexpr static bool const has_quiet_NaN=__libcpp_numeric_limits::has_quiet_NaN;
public:constexpr static bool const has_signaling_NaN=__libcpp_numeric_limits::has_signaling_NaN;
public:constexpr static enum float_denorm_style const has_denorm=__libcpp_numeric_limits::has_denorm;
public:constexpr static bool const has_denorm_loss=__libcpp_numeric_limits::has_denorm_loss;
public:static unsigned int infinity();
public:static unsigned int quiet_NaN();
public:static unsigned int signaling_NaN();
public:static unsigned int denorm_min();
public:constexpr static bool const is_iec559=__libcpp_numeric_limits::is_iec559;
public:constexpr static bool const is_bounded=__libcpp_numeric_limits::is_bounded;
public:constexpr static bool const is_modulo=__libcpp_numeric_limits::is_modulo;
public:constexpr static bool const traps=__libcpp_numeric_limits::traps;
public:constexpr static bool const tinyness_before=__libcpp_numeric_limits::tinyness_before;
public:constexpr static enum float_round_style const round_style=__libcpp_numeric_limits::round_style;
}
template<>class numeric_limits<unsigned long>:private __libcpp_numeric_limits<unsigned long,1>{private:typedef class::std::__1::__libcpp_numeric_limits<unsigned long,1>__base;
private:typedef unsigned long type;
public:
public:constexpr static bool const is_specialized=__libcpp_numeric_limits::is_specialized;
public:static unsigned long min();
public:static unsigned long max();
public:static unsigned long lowest();
public:constexpr static int const digits=__libcpp_numeric_limits::digits;
public:constexpr static int const digits10=__libcpp_numeric_limits::digits10;
public:constexpr static int const max_digits10=__libcpp_numeric_limits::max_digits10;
public:constexpr static bool const is_signed=__libcpp_numeric_limits::is_signed;
public:constexpr static bool const is_integer=__libcpp_numeric_limits::is_integer;
public:constexpr static bool const is_exact=__libcpp_numeric_limits::is_exact;
public:constexpr static int const radix=__libcpp_numeric_limits::radix;
public:static unsigned long epsilon();
public:static unsigned long round_error();
public:constexpr static int const min_exponent=__libcpp_numeric_limits::min_exponent;
public:constexpr static int const min_exponent10=__libcpp_numeric_limits::min_exponent10;
public:constexpr static int const max_exponent=__libcpp_numeric_limits::max_exponent;
public:constexpr static int const max_exponent10=__libcpp_numeric_limits::max_exponent10;
public:constexpr static bool const has_infinity=__libcpp_numeric_limits::has_infinity;
public:constexpr static bool const has_quiet_NaN=__libcpp_numeric_limits::has_quiet_NaN;
public:constexpr static bool const has_signaling_NaN=__libcpp_numeric_limits::has_signaling_NaN;
public:constexpr static enum float_denorm_style const has_denorm=__libcpp_numeric_limits::has_denorm;
public:constexpr static bool const has_denorm_loss=__libcpp_numeric_limits::has_denorm_loss;
public:static unsigned long infinity();
public:static unsigned long quiet_NaN();
public:static unsigned long signaling_NaN();
public:static unsigned long denorm_min();
public:constexpr static bool const is_iec559=__libcpp_numeric_limits::is_iec559;
public:constexpr static bool const is_bounded=__libcpp_numeric_limits::is_bounded;
public:constexpr static bool const is_modulo=__libcpp_numeric_limits::is_modulo;
public:constexpr static bool const traps=__libcpp_numeric_limits::traps;
public:constexpr static bool const tinyness_before=__libcpp_numeric_limits::tinyness_before;
public:constexpr static enum float_round_style const round_style=__libcpp_numeric_limits::round_style;
}
template<>class numeric_limits<long>:private __libcpp_numeric_limits<long,1>{private:typedef class::std::__1::__libcpp_numeric_limits<long,1>__base;
private:typedef long type;
public:
public:constexpr static bool const is_specialized=__libcpp_numeric_limits::is_specialized;
public:static long min();
public:static long max(){return(__libcpp_numeric_limits::max());
}
public:static long lowest();
public:constexpr static int const digits=__libcpp_numeric_limits::digits;
public:constexpr static int const digits10=__libcpp_numeric_limits::digits10;
public:constexpr static int const max_digits10=__libcpp_numeric_limits::max_digits10;
public:constexpr static bool const is_signed=__libcpp_numeric_limits::is_signed;
public:constexpr static bool const is_integer=__libcpp_numeric_limits::is_integer;
public:constexpr static bool const is_exact=__libcpp_numeric_limits::is_exact;
public:constexpr static int const radix=__libcpp_numeric_limits::radix;
public:static long epsilon();
public:static long round_error();
public:constexpr static int const min_exponent=__libcpp_numeric_limits::min_exponent;
public:constexpr static int const min_exponent10=__libcpp_numeric_limits::min_exponent10;
public:constexpr static int const max_exponent=__libcpp_numeric_limits::max_exponent;
public:constexpr static int const max_exponent10=__libcpp_numeric_limits::max_exponent10;
public:constexpr static bool const has_infinity=__libcpp_numeric_limits::has_infinity;
public:constexpr static bool const has_quiet_NaN=__libcpp_numeric_limits::has_quiet_NaN;
public:constexpr static bool const has_signaling_NaN=__libcpp_numeric_limits::has_signaling_NaN;
public:constexpr static enum float_denorm_style const has_denorm=__libcpp_numeric_limits::has_denorm;
public:constexpr static bool const has_denorm_loss=__libcpp_numeric_limits::has_denorm_loss;
public:static long infinity();
public:static long quiet_NaN();
public:static long signaling_NaN();
public:static long denorm_min();
public:constexpr static bool const is_iec559=__libcpp_numeric_limits::is_iec559;
public:constexpr static bool const is_bounded=__libcpp_numeric_limits::is_bounded;
public:constexpr static bool const is_modulo=__libcpp_numeric_limits::is_modulo;
public:constexpr static bool const traps=__libcpp_numeric_limits::traps;
public:constexpr static bool const tinyness_before=__libcpp_numeric_limits::tinyness_before;
public:constexpr static enum float_round_style const round_style=__libcpp_numeric_limits::round_style;
}
;
constexpr bool const numeric_limits::is_specialized;
constexpr int const numeric_limits::digits;
constexpr int const numeric_limits::digits10;
constexpr int const numeric_limits::max_digits10;
constexpr bool const numeric_limits::is_signed;
constexpr bool const numeric_limits::is_integer;
constexpr bool const numeric_limits::is_exact;
constexpr int const numeric_limits::radix;
constexpr int const numeric_limits::min_exponent;
constexpr int const numeric_limits::min_exponent10;
constexpr int const numeric_limits::max_exponent;
constexpr int const numeric_limits::max_exponent10;
constexpr bool const numeric_limits::has_infinity;
constexpr bool const numeric_limits::has_quiet_NaN;
constexpr bool const numeric_limits::has_signaling_NaN;
constexpr enum float_denorm_style const numeric_limits::has_denorm;
constexpr bool const numeric_limits::has_denorm_loss;
constexpr bool const numeric_limits::is_iec559;
constexpr bool const numeric_limits::is_bounded;
constexpr bool const numeric_limits::is_modulo;
constexpr bool const numeric_limits::traps;
constexpr bool const numeric_limits::tinyness_before;
constexpr enum float_round_style const numeric_limits::round_style;
template<typename __xcodeml_template_type_0_0>class numeric_limits<__xcodeml_template_type_0_0 const>:private numeric_limits<__xcodeml_template_type_0_0>{private:typedef numeric_limits<__xcodeml_template_type_0_0>;
private:typedef __xcodeml_template_type_0_0 type;
public:
public:constexpr static bool const is_specialized=numeric_limits<__xcodeml_template_type_0_0>::is_specialized;
public:static __xcodeml_template_type_0_0 min(){return(numeric_limits<__xcodeml_template_type_0_0>::min());
}
public:static __xcodeml_template_type_0_0 max(){return(numeric_limits<__xcodeml_template_type_0_0>::max());
}
public:static __xcodeml_template_type_0_0 lowest(){return(numeric_limits<__xcodeml_template_type_0_0>::lowest());
}
public:constexpr static int const digits=numeric_limits<__xcodeml_template_type_0_0>::digits;
public:constexpr static int const digits10=numeric_limits<__xcodeml_template_type_0_0>::digits10;
public:constexpr static int const max_digits10=numeric_limits<__xcodeml_template_type_0_0>::max_digits10;
public:constexpr static bool const is_signed=numeric_limits<__xcodeml_template_type_0_0>::is_signed;
public:constexpr static bool const is_integer=numeric_limits<__xcodeml_template_type_0_0>::is_integer;
public:constexpr static bool const is_exact=numeric_limits<__xcodeml_template_type_0_0>::is_exact;
public:constexpr static int const radix=numeric_limits<__xcodeml_template_type_0_0>::radix;
public:static __xcodeml_template_type_0_0 epsilon(){return(numeric_limits<__xcodeml_template_type_0_0>::epsilon());
}
public:static __xcodeml_template_type_0_0 round_error(){return(numeric_limits<__xcodeml_template_type_0_0>::round_error());
}
public:constexpr static int const min_exponent=numeric_limits<__xcodeml_template_type_0_0>::min_exponent;
public:constexpr static int const min_exponent10=numeric_limits<__xcodeml_template_type_0_0>::min_exponent10;
public:constexpr static int const max_exponent=numeric_limits<__xcodeml_template_type_0_0>::max_exponent;
public:constexpr static int const max_exponent10=numeric_limits<__xcodeml_template_type_0_0>::max_exponent10;
public:constexpr static bool const has_infinity=numeric_limits<__xcodeml_template_type_0_0>::has_infinity;
public:constexpr static bool const has_quiet_NaN=numeric_limits<__xcodeml_template_type_0_0>::has_quiet_NaN;
public:constexpr static bool const has_signaling_NaN=numeric_limits<__xcodeml_template_type_0_0>::has_signaling_NaN;
public:constexpr static enum float_denorm_style const has_denorm=numeric_limits<__xcodeml_template_type_0_0>::has_denorm;
public:constexpr static bool const has_denorm_loss=numeric_limits<__xcodeml_template_type_0_0>::has_denorm_loss;
public:static __xcodeml_template_type_0_0 infinity(){return(numeric_limits<__xcodeml_template_type_0_0>::infinity());
}
public:static __xcodeml_template_type_0_0 quiet_NaN(){return(numeric_limits<__xcodeml_template_type_0_0>::quiet_NaN());
}
public:static __xcodeml_template_type_0_0 signaling_NaN(){return(numeric_limits<__xcodeml_template_type_0_0>::signaling_NaN());
}
public:static __xcodeml_template_type_0_0 denorm_min(){return(numeric_limits<__xcodeml_template_type_0_0>::denorm_min());
}
public:constexpr static bool const is_iec559=numeric_limits<__xcodeml_template_type_0_0>::is_iec559;
public:constexpr static bool const is_bounded=numeric_limits<__xcodeml_template_type_0_0>::is_bounded;
public:constexpr static bool const is_modulo=numeric_limits<__xcodeml_template_type_0_0>::is_modulo;
public:constexpr static bool const traps=numeric_limits<__xcodeml_template_type_0_0>::traps;
public:constexpr static bool const tinyness_before=numeric_limits<__xcodeml_template_type_0_0>::tinyness_before;
public:constexpr static enum float_round_style const round_style=numeric_limits<__xcodeml_template_type_0_0>::round_style;
}
;
constexpr bool const numeric_limits::is_specialized;
constexpr int const numeric_limits::digits;
constexpr int const numeric_limits::digits10;
constexpr int const numeric_limits::max_digits10;
constexpr bool const numeric_limits::is_signed;
constexpr bool const numeric_limits::is_integer;
constexpr bool const numeric_limits::is_exact;
constexpr int const numeric_limits::radix;
constexpr int const numeric_limits::min_exponent;
constexpr int const numeric_limits::min_exponent10;
constexpr int const numeric_limits::max_exponent;
constexpr int const numeric_limits::max_exponent10;
constexpr bool const numeric_limits::has_infinity;
constexpr bool const numeric_limits::has_quiet_NaN;
constexpr bool const numeric_limits::has_signaling_NaN;
constexpr enum float_denorm_style const numeric_limits::has_denorm;
constexpr bool const numeric_limits::has_denorm_loss;
constexpr bool const numeric_limits::is_iec559;
constexpr bool const numeric_limits::is_bounded;
constexpr bool const numeric_limits::is_modulo;
constexpr bool const numeric_limits::traps;
constexpr bool const numeric_limits::tinyness_before;
constexpr enum float_round_style const numeric_limits::round_style;
template<typename __xcodeml_template_type_0_0>class numeric_limits<__xcodeml_template_type_0_0 volatile>:private numeric_limits<__xcodeml_template_type_0_0>{private:typedef numeric_limits<__xcodeml_template_type_0_0>;
private:typedef __xcodeml_template_type_0_0 type;
public:
public:constexpr static bool const is_specialized=numeric_limits<__xcodeml_template_type_0_0>::is_specialized;
public:static __xcodeml_template_type_0_0 min(){return(numeric_limits<__xcodeml_template_type_0_0>::min());
}
public:static __xcodeml_template_type_0_0 max(){return(numeric_limits<__xcodeml_template_type_0_0>::max());
}
public:static __xcodeml_template_type_0_0 lowest(){return(numeric_limits<__xcodeml_template_type_0_0>::lowest());
}
public:constexpr static int const digits=numeric_limits<__xcodeml_template_type_0_0>::digits;
public:constexpr static int const digits10=numeric_limits<__xcodeml_template_type_0_0>::digits10;
public:constexpr static int const max_digits10=numeric_limits<__xcodeml_template_type_0_0>::max_digits10;
public:constexpr static bool const is_signed=numeric_limits<__xcodeml_template_type_0_0>::is_signed;
public:constexpr static bool const is_integer=numeric_limits<__xcodeml_template_type_0_0>::is_integer;
public:constexpr static bool const is_exact=numeric_limits<__xcodeml_template_type_0_0>::is_exact;
public:constexpr static int const radix=numeric_limits<__xcodeml_template_type_0_0>::radix;
public:static __xcodeml_template_type_0_0 epsilon(){return(numeric_limits<__xcodeml_template_type_0_0>::epsilon());
}
public:static __xcodeml_template_type_0_0 round_error(){return(numeric_limits<__xcodeml_template_type_0_0>::round_error());
}
public:constexpr static int const min_exponent=numeric_limits<__xcodeml_template_type_0_0>::min_exponent;
public:constexpr static int const min_exponent10=numeric_limits<__xcodeml_template_type_0_0>::min_exponent10;
public:constexpr static int const max_exponent=numeric_limits<__xcodeml_template_type_0_0>::max_exponent;
public:constexpr static int const max_exponent10=numeric_limits<__xcodeml_template_type_0_0>::max_exponent10;
public:constexpr static bool const has_infinity=numeric_limits<__xcodeml_template_type_0_0>::has_infinity;
public:constexpr static bool const has_quiet_NaN=numeric_limits<__xcodeml_template_type_0_0>::has_quiet_NaN;
public:constexpr static bool const has_signaling_NaN=numeric_limits<__xcodeml_template_type_0_0>::has_signaling_NaN;
public:constexpr static enum float_denorm_style const has_denorm=numeric_limits<__xcodeml_template_type_0_0>::has_denorm;
public:constexpr static bool const has_denorm_loss=numeric_limits<__xcodeml_template_type_0_0>::has_denorm_loss;
public:static __xcodeml_template_type_0_0 infinity(){return(numeric_limits<__xcodeml_template_type_0_0>::infinity());
}
public:static __xcodeml_template_type_0_0 quiet_NaN(){return(numeric_limits<__xcodeml_template_type_0_0>::quiet_NaN());
}
public:static __xcodeml_template_type_0_0 signaling_NaN(){return(numeric_limits<__xcodeml_template_type_0_0>::signaling_NaN());
}
public:static __xcodeml_template_type_0_0 denorm_min(){return(numeric_limits<__xcodeml_template_type_0_0>::denorm_min());
}
public:constexpr static bool const is_iec559=numeric_limits<__xcodeml_template_type_0_0>::is_iec559;
public:constexpr static bool const is_bounded=numeric_limits<__xcodeml_template_type_0_0>::is_bounded;
public:constexpr static bool const is_modulo=numeric_limits<__xcodeml_template_type_0_0>::is_modulo;
public:constexpr static bool const traps=numeric_limits<__xcodeml_template_type_0_0>::traps;
public:constexpr static bool const tinyness_before=numeric_limits<__xcodeml_template_type_0_0>::tinyness_before;
public:constexpr static enum float_round_style const round_style=numeric_limits<__xcodeml_template_type_0_0>::round_style;
}
;
constexpr bool const numeric_limits::is_specialized;
constexpr int const numeric_limits::digits;
constexpr int const numeric_limits::digits10;
constexpr int const numeric_limits::max_digits10;
constexpr bool const numeric_limits::is_signed;
constexpr bool const numeric_limits::is_integer;
constexpr bool const numeric_limits::is_exact;
constexpr int const numeric_limits::radix;
constexpr int const numeric_limits::min_exponent;
constexpr int const numeric_limits::min_exponent10;
constexpr int const numeric_limits::max_exponent;
constexpr int const numeric_limits::max_exponent10;
constexpr bool const numeric_limits::has_infinity;
constexpr bool const numeric_limits::has_quiet_NaN;
constexpr bool const numeric_limits::has_signaling_NaN;
constexpr enum float_denorm_style const numeric_limits::has_denorm;
constexpr bool const numeric_limits::has_denorm_loss;
constexpr bool const numeric_limits::is_iec559;
constexpr bool const numeric_limits::is_bounded;
constexpr bool const numeric_limits::is_modulo;
constexpr bool const numeric_limits::traps;
constexpr bool const numeric_limits::tinyness_before;
constexpr enum float_round_style const numeric_limits::round_style;
template<typename __xcodeml_template_type_0_0>class numeric_limits<__xcodeml_template_type_0_0 volatile const>:private numeric_limits<__xcodeml_template_type_0_0>{private:typedef numeric_limits<__xcodeml_template_type_0_0>;
private:typedef __xcodeml_template_type_0_0 type;
public:
public:constexpr static bool const is_specialized=numeric_limits<__xcodeml_template_type_0_0>::is_specialized;
public:static __xcodeml_template_type_0_0 min(){return(numeric_limits<__xcodeml_template_type_0_0>::min());
}
public:static __xcodeml_template_type_0_0 max(){return(numeric_limits<__xcodeml_template_type_0_0>::max());
}
public:static __xcodeml_template_type_0_0 lowest(){return(numeric_limits<__xcodeml_template_type_0_0>::lowest());
}
public:constexpr static int const digits=numeric_limits<__xcodeml_template_type_0_0>::digits;
public:constexpr static int const digits10=numeric_limits<__xcodeml_template_type_0_0>::digits10;
public:constexpr static int const max_digits10=numeric_limits<__xcodeml_template_type_0_0>::max_digits10;
public:constexpr static bool const is_signed=numeric_limits<__xcodeml_template_type_0_0>::is_signed;
public:constexpr static bool const is_integer=numeric_limits<__xcodeml_template_type_0_0>::is_integer;
public:constexpr static bool const is_exact=numeric_limits<__xcodeml_template_type_0_0>::is_exact;
public:constexpr static int const radix=numeric_limits<__xcodeml_template_type_0_0>::radix;
public:static __xcodeml_template_type_0_0 epsilon(){return(numeric_limits<__xcodeml_template_type_0_0>::epsilon());
}
public:static __xcodeml_template_type_0_0 round_error(){return(numeric_limits<__xcodeml_template_type_0_0>::round_error());
}
public:constexpr static int const min_exponent=numeric_limits<__xcodeml_template_type_0_0>::min_exponent;
public:constexpr static int const min_exponent10=numeric_limits<__xcodeml_template_type_0_0>::min_exponent10;
public:constexpr static int const max_exponent=numeric_limits<__xcodeml_template_type_0_0>::max_exponent;
public:constexpr static int const max_exponent10=numeric_limits<__xcodeml_template_type_0_0>::max_exponent10;
public:constexpr static bool const has_infinity=numeric_limits<__xcodeml_template_type_0_0>::has_infinity;
public:constexpr static bool const has_quiet_NaN=numeric_limits<__xcodeml_template_type_0_0>::has_quiet_NaN;
public:constexpr static bool const has_signaling_NaN=numeric_limits<__xcodeml_template_type_0_0>::has_signaling_NaN;
public:constexpr static enum float_denorm_style const has_denorm=numeric_limits<__xcodeml_template_type_0_0>::has_denorm;
public:constexpr static bool const has_denorm_loss=numeric_limits<__xcodeml_template_type_0_0>::has_denorm_loss;
public:static __xcodeml_template_type_0_0 infinity(){return(numeric_limits<__xcodeml_template_type_0_0>::infinity());
}
public:static __xcodeml_template_type_0_0 quiet_NaN(){return(numeric_limits<__xcodeml_template_type_0_0>::quiet_NaN());
}
public:static __xcodeml_template_type_0_0 signaling_NaN(){return(numeric_limits<__xcodeml_template_type_0_0>::signaling_NaN());
}
public:static __xcodeml_template_type_0_0 denorm_min(){return(numeric_limits<__xcodeml_template_type_0_0>::denorm_min());
}
public:constexpr static bool const is_iec559=numeric_limits<__xcodeml_template_type_0_0>::is_iec559;
public:constexpr static bool const is_bounded=numeric_limits<__xcodeml_template_type_0_0>::is_bounded;
public:constexpr static bool const is_modulo=numeric_limits<__xcodeml_template_type_0_0>::is_modulo;
public:constexpr static bool const traps=numeric_limits<__xcodeml_template_type_0_0>::traps;
public:constexpr static bool const tinyness_before=numeric_limits<__xcodeml_template_type_0_0>::tinyness_before;
public:constexpr static enum float_round_style const round_style=numeric_limits<__xcodeml_template_type_0_0>::round_style;
}
;
constexpr bool const numeric_limits::is_specialized;
constexpr int const numeric_limits::digits;
constexpr int const numeric_limits::digits10;
constexpr int const numeric_limits::max_digits10;
constexpr bool const numeric_limits::is_signed;
constexpr bool const numeric_limits::is_integer;
constexpr bool const numeric_limits::is_exact;
constexpr int const numeric_limits::radix;
constexpr int const numeric_limits::min_exponent;
constexpr int const numeric_limits::min_exponent10;
constexpr int const numeric_limits::max_exponent;
constexpr int const numeric_limits::max_exponent10;
constexpr bool const numeric_limits::has_infinity;
constexpr bool const numeric_limits::has_quiet_NaN;
constexpr bool const numeric_limits::has_signaling_NaN;
constexpr enum float_denorm_style const numeric_limits::has_denorm;
constexpr bool const numeric_limits::has_denorm_loss;
constexpr bool const numeric_limits::is_iec559;
constexpr bool const numeric_limits::is_bounded;
constexpr bool const numeric_limits::is_modulo;
constexpr bool const numeric_limits::traps;
constexpr bool const numeric_limits::tinyness_before;
constexpr enum float_round_style const numeric_limits::round_style;
constexpr int const numeric_limits::digits;
constexpr int const numeric_limits::digits;
constexpr int const numeric_limits::digits;
}
}
namespace std{namespace __1{class __libcpp_debug_info{public:__libcpp_debug_info():__file_(nullptr),__line_((-1)),__pred_(nullptr),__msg_(nullptr){}
public:__libcpp_debug_info(char const(*__f),int __l,char const(*__p),char const(*__m)):__file_(__f),__line_(__l),__pred_(__p),__msg_(__m){}
public:class::std::__1::basic_string<char,class::std::__1::char_traits<char>,class::std::__1::allocator<char> >what()const;
public:char const(*__file_);
public:int __line_;
public:char const(*__pred_);
public:char const(*__msg_);
}
;
typedef void(*__libcpp_debug_function_type)(class __libcpp_debug_info const&);
extern void(*__libcpp_debug_function)(class __libcpp_debug_info const&);
void __libcpp_abort_debug_function(class __libcpp_debug_info const&);
bool __libcpp_set_debug_function(void(*__func)(class __libcpp_debug_info const&));
}
}
namespace std{namespace __1{int __libcpp_ctz(unsigned int __x){return(__builtin_ctz(__x));
}
int __libcpp_ctz(unsigned long __x){return(__builtin_ctzl(__x));
}
int __libcpp_ctz(unsigned long long __x){return(__builtin_ctzll(__x));
}
int __libcpp_clz(unsigned int __x){return(__builtin_clz(__x));
}
int __libcpp_clz(unsigned long __x){return(__builtin_clzl(__x));
}
int __libcpp_clz(unsigned long long __x){return(__builtin_clzll(__x));
}
int __libcpp_popcount(unsigned int __x){return(__builtin_popcount(__x));
}
int __libcpp_popcount(unsigned long __x){return(__builtin_popcountl(__x));
}
int __libcpp_popcount(unsigned long long __x){return(__builtin_popcountll(__x));
}
template<typename __xcodeml_template_type_0_0>using __bitop_unsigned_integer=integral_constant<bool,expression>;
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 __rotl(__xcodeml_template_type_0_0 __t,unsigned int __cnt){integral_constant<bool,expression>::value"__rotl requires unsigned";
unsigned int const __dig=numeric_limits<__xcodeml_template_type_0_0>::digits;
if(((__cnt%__dig)==0)){return __t;};
return((__t<<(__cnt%__dig))|(__t>>(__dig-(__cnt%__dig))));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 __rotr(__xcodeml_template_type_0_0 __t,unsigned int __cnt){integral_constant<bool,expression>::value"__rotr requires unsigned";
unsigned int const __dig=numeric_limits<__xcodeml_template_type_0_0>::digits;
if(((__cnt%__dig)==0)){return __t;};
return((__t>>(__cnt%__dig))|(__t<<(__dig-(__cnt%__dig))));
}
template<typename __xcodeml_template_type_0_0>int __countr_zero(__xcodeml_template_type_0_0 __t){integral_constant<bool,expression>::value"__countr_zero requires unsigned";
if((__t==0)){return numeric_limits<__xcodeml_template_type_0_0>::digits;};
if(((sizeof(__xcodeml_template_type_0_0))<=(sizeof(unsigned int)))){return(__libcpp_ctz(static_cast<unsigned int>(__t)));}else{if(((sizeof(__xcodeml_template_type_0_0))<=(sizeof(unsigned long)))){return(__libcpp_ctz(static_cast<unsigned long>(__t)));}else{if(((sizeof(__xcodeml_template_type_0_0))<=(sizeof(unsigned long long)))){return(__libcpp_ctz(static_cast<unsigned long long>(__t)));}else{{int __ret=0;
int __iter=0;
unsigned int const __ulldigits=numeric_limits::digits;
while(((__iter=(__libcpp_ctz(static_cast<unsigned long long>(__t))))==__ulldigits)){{(__ret+=__iter);
(__t>>=__ulldigits);
};};
return(__ret+__iter);
};};};};
}
template<typename __xcodeml_template_type_0_0>int __countl_zero(__xcodeml_template_type_0_0 __t){integral_constant<bool,expression>::value"__countl_zero requires unsigned";
if((__t==0)){return numeric_limits<__xcodeml_template_type_0_0>::digits;};
if(((sizeof(__xcodeml_template_type_0_0))<=(sizeof(unsigned int)))){return((__libcpp_clz(static_cast<unsigned int>(__t)))-(numeric_limits::digits-numeric_limits<__xcodeml_template_type_0_0>::digits));}else{if(((sizeof(__xcodeml_template_type_0_0))<=(sizeof(unsigned long)))){return((__libcpp_clz(static_cast<unsigned long>(__t)))-(numeric_limits::digits-numeric_limits<__xcodeml_template_type_0_0>::digits));}else{if(((sizeof(__xcodeml_template_type_0_0))<=(sizeof(unsigned long long)))){return((__libcpp_clz(static_cast<unsigned long long>(__t)))-(numeric_limits::digits-numeric_limits<__xcodeml_template_type_0_0>::digits));}else{{int __ret=0;
int __iter=0;
unsigned int const __ulldigits=numeric_limits::digits;
while(true){{(__t=((__t,__ulldigits)));
if(((__iter=(__countl_zero(static_cast<unsigned long long>(__t))))!=__ulldigits)){break;};
(__ret+=__iter);
};};
return(__ret+__iter);
};};};};
}
template <>int __countl_zero(unsigned long long __t)
template<typename __xcodeml_template_type_0_0>int __countl_one(__xcodeml_template_type_0_0 __t){integral_constant<bool,expression>::value"__countl_one requires unsigned";
return((__t!=(numeric_limits<__xcodeml_template_type_0_0>::max()))?((static_cast<__xcodeml_template_type_0_0>((~__t)))):numeric_limits<__xcodeml_template_type_0_0>::digits);
}
template<typename __xcodeml_template_type_0_0>int __countr_one(__xcodeml_template_type_0_0 __t){integral_constant<bool,expression>::value"__countr_one requires unsigned";
return((__t!=(numeric_limits<__xcodeml_template_type_0_0>::max()))?((static_cast<__xcodeml_template_type_0_0>((~__t)))):numeric_limits<__xcodeml_template_type_0_0>::digits);
}
template<typename __xcodeml_template_type_0_0>int __popcount(__xcodeml_template_type_0_0 __t){integral_constant<bool,expression>::value"__libcpp_popcount requires unsigned";
if(((sizeof(__xcodeml_template_type_0_0))<=(sizeof(unsigned int)))){return(__libcpp_popcount(static_cast<unsigned int>(__t)));}else{if(((sizeof(__xcodeml_template_type_0_0))<=(sizeof(unsigned long)))){return(__libcpp_popcount(static_cast<unsigned long>(__t)));}else{if(((sizeof(__xcodeml_template_type_0_0))<=(sizeof(unsigned long long)))){return(__libcpp_popcount(static_cast<unsigned long long>(__t)));}else{{int __ret=0;
while((__t!=0)){{(__ret+=(__libcpp_popcount(static_cast<unsigned long long>(__t))));
(__t>>=numeric_limits::digits);
};};
return __ret;
};};};};
}
template<typename __xcodeml_template_type_0_0>unsigned int __bit_log2(__xcodeml_template_type_0_0 __t){integral_constant<bool,expression>::value"__bit_log2 requires unsigned";
return((std::numeric_limits<__xcodeml_template_type_0_0>::digits-1)-((__t)));
}
template<typename __xcodeml_template_type_0_0>bool __ispow2(__xcodeml_template_type_0_0 __t){integral_constant<bool,expression>::value"__ispow2 requires unsigned";
return((__t!=0)&&((__t&(__t-1))==0));
}
}
}
namespace std{template<typename __xcodeml_template_type_0_0>class initializer_list{private:__xcodeml_template_type_0_0 const(*__begin_);
private:unsigned long __size_;
private:initializer_list(__xcodeml_template_type_0_0 const(*__b),unsigned long __s):__begin_(__b),__size_(__s){}
public:
public:typedef __xcodeml_template_type_0_0 value_type;
public:typedef __xcodeml_template_type_0_0 const&reference;
public:typedef __xcodeml_template_type_0_0 const&const_reference;
public:typedef unsigned long size_type;
public:typedef __xcodeml_template_type_0_0 const(*iterator);
public:typedef __xcodeml_template_type_0_0 const(*const_iterator);
public:initializer_list():__begin_(nullptr),__size_(0){}
public:unsigned long size()const{return this->__size_;
}
public:__xcodeml_template_type_0_0 const(*begin()const){return this->__begin_;
}
public:__xcodeml_template_type_0_0 const(*end()const){return(this->__begin_+this->__size_);
}
}
;
template<>class initializer_list<bool>{private:bool const(*__begin_);
private:unsigned long __size_;
private:initializer_list(bool const(*__b),unsigned long __s);
public:
public:typedef bool value_type;
public:typedef bool const&reference;
public:typedef bool const&const_reference;
public:typedef unsigned long size_type;
public:typedef bool const(*iterator);
public:typedef bool const(*const_iterator);
public:initializer_list();
public:unsigned long size()const{return this->__size_;
}
public:bool const(*begin()const){return this->__begin_;
}
public:bool const(*end()const){return(this->__begin_+this->__size_);
}
}
template<>class initializer_list template<>class initializer_list<unsigned long>{private:unsigned long const(*__begin_);
private:unsigned long __size_;
private:initializer_list(unsigned long const(*__b),unsigned long __s);
public:
public:typedef unsigned long value_type;
public:typedef unsigned long const&reference;
public:typedef unsigned long const&const_reference;
public:typedef unsigned long size_type;
public:typedef unsigned long const(*iterator);
public:typedef unsigned long const(*const_iterator);
public:initializer_list();
public:unsigned long size()const;
public:unsigned long const(*begin()const);
public:unsigned long const(*end()const);
}
;
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 const(*begin(initializer_list<__xcodeml_template_type_0_0>)){return(__il.begin());
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 const(*end(initializer_list<__xcodeml_template_type_0_0>)){return(__il.end());
}
}
extern"C"{int bcmp(void const(*),void const(*),unsigned long);};
extern"C"{void bcopy(void const(*),void(*),unsigned long);};
extern"C"{void bzero(void(*),unsigned long);};
extern"C"{void explicit_bzero(void(*),unsigned long);};
extern"C"{int ffs(int);};
extern"C"{int ffsl(long);};
extern"C"{int ffsll(long long);};
extern"C"{int fls(int);};
extern"C"{int flsl(long);};
extern"C"{int flsll(long long);};
extern"C"{char(*index(char const(*),int));};
extern"C"{char(*rindex(char const(*),int));};
extern"C"{int strcasecmp(char const(*),char const(*));};
extern"C"{int strncasecmp(char const(*),char const(*),unsigned long);};
extern"C"{int strcasecmp_l(char const(*),char const(*),class::_xlocale(*));};
extern"C"{int strncasecmp_l(char const(*),char const(*),unsigned long,class::_xlocale(*));};

extern"C"{void(*memccpy(void(*),void const(*),int,unsigned long));};
extern"C"{void(*memchr(void const(*),int,unsigned long));};
extern"C"{void(*memrchr(void const(*),int,unsigned long));};
extern"C"{int memcmp(void const(*),void const(*),unsigned long);};
extern"C"{void(*memcpy(void(*),void const(*),unsigned long));};
extern"C"{void(*memmem(void const(*),unsigned long,void const(*),unsigned long));};
extern"C"{void(*memmove(void(*),void const(*),unsigned long));};
extern"C"{void(*memset(void(*),int,unsigned long));};
extern"C"{char(*stpcpy(char(*),char const(*)));};
extern"C"{char(*stpncpy(char(*),char const(*),unsigned long));};
extern"C"{char(*strcasestr(char const(*),char const(*)));};
extern"C"{char(*strcat(char(*),char const(*)));};
extern"C"{char(*strchr(char const(*),int));};
extern"C"{char(*strchrnul(char const(*),int));};
extern"C"{int strcmp(char const(*),char const(*));};
extern"C"{int strcoll(char const(*),char const(*));};
extern"C"{char(*strcpy(char(*),char const(*)));};
extern"C"{unsigned long strcspn(char const(*),char const(*));};
extern"C"{char(*strdup(char const(*)));};
extern"C"{char(*strerror(int));};
extern"C"{int strerror_r(int,char(*),unsigned long);};
extern"C"{unsigned long strlcat(char(*),char const(*),unsigned long);};
extern"C"{unsigned long strlcpy(char(*),char const(*),unsigned long);};
extern"C"{unsigned long strlen(char const(*));};
extern"C"{void strmode(int,char(*));};
extern"C"{char(*strncat(char(*),char const(*),unsigned long));};
extern"C"{int strncmp(char const(*),char const(*),unsigned long);};
extern"C"{char(*strncpy(char(*),char const(*),unsigned long));};
extern"C"{char(*strndup(char const(*),unsigned long));};
extern"C"{unsigned long strnlen(char const(*),unsigned long);};
extern"C"{char(*strnstr(char const(*),char const(*),unsigned long));};
extern"C"{char(*strpbrk(char const(*),char const(*)));};
extern"C"{char(*strrchr(char const(*),int));};
extern"C"{char(*strsep(char(*(*)),char const(*)));};
extern"C"{char(*strsignal(int));};
extern"C"{unsigned long strspn(char const(*),char const(*));};
extern"C"{char(*strstr(char const(*),char const(*)));};
extern"C"{char(*strtok(char(*),char const(*)));};
extern"C"{char(*strtok_r(char(*),char const(*),char(*(*))));};
extern"C"{unsigned long strxfrm(char(*),char const(*),unsigned long);};
typedef long ssize_t;
extern"C"{void swab(void const(*),void(*),long);};
extern"C"{int timingsafe_bcmp(void const(*),void const(*),unsigned long);};
extern"C"{int timingsafe_memcmp(void const(*),void const(*),unsigned long);};
extern"C"{int strcoll_l(char const(*),char const(*),class::_xlocale(*));};
extern"C"{unsigned long strxfrm_l(char(*),char const(*),unsigned long,class::_xlocale(*));};
typedef int errno_t;
extern"C"{int memset_s(void(*),unsigned long,int,unsigned long);};

char(*__libcpp_strchr(char const(*__s),int __c)){return((char(*))(strchr(__s,__c)));
}
char const(*strchr(char const(*__s),int __c)){return(__libcpp_strchr(__s,__c));
}
char(*strchr(char(*__s),int __c)){return(__libcpp_strchr(__s,__c));
}
char(*__libcpp_strpbrk(char const(*__s1),char const(*__s2))){return((char(*))(strpbrk(__s1,__s2)));
}
char const(*strpbrk(char const(*__s1),char const(*__s2))){return(__libcpp_strpbrk(__s1,__s2));
}
char(*strpbrk(char(*__s1),char const(*__s2))){return(__libcpp_strpbrk(__s1,__s2));
}
char(*__libcpp_strrchr(char const(*__s),int __c)){return((char(*))(strrchr(__s,__c)));
}
char const(*strrchr(char const(*__s),int __c)){return(__libcpp_strrchr(__s,__c));
}
char(*strrchr(char(*__s),int __c)){return(__libcpp_strrchr(__s,__c));
}
void(*__libcpp_memchr(void const(*__s),int __c,unsigned long __n)){return((void(*))(memchr(__s,__c,__n)));
}
void const(*memchr(void const(*__s),int __c,unsigned long __n)){return(__libcpp_memchr(__s,__c,__n));
}
void(*memchr(void(*__s),int __c,unsigned long __n)){return(__libcpp_memchr(__s,__c,__n));
}
char(*__libcpp_strstr(char const(*__s1),char const(*__s2))){return((char(*))(strstr(__s1,__s2)));
}
char const(*strstr(char const(*__s1),char const(*__s2))){return(__libcpp_strstr(__s1,__s2));
}
char(*strstr(char(*__s1),char const(*__s2))){return(__libcpp_strstr(__s1,__s2));
}

namespace std{namespace __1{::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
}
}
namespace std{namespace __1{template<typename __xcodeml_template_type_0_0>class tuple_size;
template<>class tuple_size<class::std::__1::pair<unsigned long,unsigned long> >:public integral_constant<unsigned long,2>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>using __enable_if_tuple_size_imp=__xcodeml_template_type_0_0;
template<typename __xcodeml_template_type_0_0>class tuple_size<__xcodeml_template_type_0_0 const>:public integral_constant<unsigned long,expression>{}
;
template<typename __xcodeml_template_type_0_0>class tuple_size<__xcodeml_template_type_0_0 volatile>:public integral_constant<unsigned long,expression>{}
;
template<typename __xcodeml_template_type_0_0>class tuple_size<__xcodeml_template_type_0_0 volatile const>:public integral_constant<unsigned long,expression>{}
;
template<unsigned long _Ip,typename __xcodeml_template_type_0_1>class tuple_element;
;
template<unsigned long _Ip,typename __xcodeml_template_type_0_1>class tuple_element<expression,__xcodeml_template_type_0_1 const>{public:typedef typename add_const<typename tuple_element<expression,__xcodeml_template_type_0_1>::type>::type type;
}
;
template<unsigned long _Ip,typename __xcodeml_template_type_0_1>class tuple_element<expression,__xcodeml_template_type_0_1 volatile>{public:typedef typename add_volatile<typename tuple_element<expression,__xcodeml_template_type_0_1>::type>::type type;
}
;
template<unsigned long _Ip,typename __xcodeml_template_type_0_1>class tuple_element<expression,__xcodeml_template_type_0_1 volatile const>{public:typedef typename add_cv<typename tuple_element<expression,__xcodeml_template_type_0_1>::type>::type type;
}
;
template<typename __xcodeml_template_type_0_0>class __tuple_like:public integral_constant<bool,0>{}
;
template<>class __tuple_like<class::std::__1::pair<unsigned long,unsigned long> >:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class __tuple_like<__xcodeml_template_type_0_0 const>:public __tuple_like<__xcodeml_template_type_0_0>{}
;
template<typename __xcodeml_template_type_0_0>class __tuple_like<__xcodeml_template_type_0_0 volatile>:public __tuple_like<__xcodeml_template_type_0_0>{}
;
template<typename __xcodeml_template_type_0_0>class __tuple_like<__xcodeml_template_type_0_0 volatile const>:public __tuple_like<__xcodeml_template_type_0_0>{}
;
template<unsigned long>class __tuple_indices{}
;
template<>class __tuple_indices<...>{}
;
template<typename __xcodeml_template_type_0_0,__xcodeml_template_type_0_0 _Values>class __integer_sequence{public:template<typename __xcodeml_template_type_1_1>using __convert=<__xcodeml_template_type_1_1,...>;
public:template<unsigned long _Sp>using __to_tuple_indices=__tuple_indices<...>;
}
;
template<>class __integer_sequence<unsigned long,...>{public:template<typename __xcodeml_template_type_0_1>using __convert=<__xcodeml_template_type_0_1,...>;
public:template<unsigned long _Sp>using __to_tuple_indices=class::std::__1::__tuple_indices<...>;
}
;
template<unsigned long _Ep,unsigned long _Sp>using __make_indices_imp=void/**/;
template<unsigned long _Ep,unsigned long _Sp=0>class __make_tuple_indices{
/* Ignored a member with no access specifier (_Sp<=_Ep)"__make_tuple_indices input error";*/

public:typedef void/*type*/;
}
;
template<>class __make_tuple_indices<0,0>{
/* Ignored a member with no access specifier (_Sp<=_Ep)"__make_tuple_indices input error";*/

public:typedef class::std::__1::__tuple_indices<...>type;
}
;
template<typename __xcodeml_template_type_0_0>class tuple;
;
template<typename __xcodeml_template_type_0_0>class __tuple_like<tuple<...> >:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class tuple_size<tuple<...> >:public integral_constant<unsigned long,expression>{}
;
template<unsigned long _Ip,typename __xcodeml_template_type_0_1>typename tuple_element<expression,tuple<...> >::type&get(tuple<...>)
template<unsigned long _Ip,typename __xcodeml_template_type_0_1>typename tuple_element<expression,tuple<...> >::type const&get(tuple<...>)
template<unsigned long _Ip,typename __xcodeml_template_type_0_1>typename tuple_element<expression,tuple<...> >::type(*get(tuple<...>))
template<unsigned long _Ip,typename __xcodeml_template_type_0_1>typename tuple_element<expression,tuple<...> >::type const(*get(tuple<...>))
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __tuple_like<pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1> >:public integral_constant<bool,1>{}
;
template<unsigned long _Ip,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>typename tuple_element<expression,pair<__xcodeml_template_type_0_1,__xcodeml_template_type_0_2> >::type&get(pair<__xcodeml_template_type_0_1,__xcodeml_template_type_0_2>)
template<unsigned long _Ip,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>typename tuple_element<expression,pair<__xcodeml_template_type_0_1,__xcodeml_template_type_0_2> >::type const&get(pair<__xcodeml_template_type_0_1,__xcodeml_template_type_0_2>)
template<unsigned long _Ip,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>typename tuple_element<expression,pair<__xcodeml_template_type_0_1,__xcodeml_template_type_0_2> >::type(*get(pair<__xcodeml_template_type_0_1,__xcodeml_template_type_0_2>))
template<unsigned long _Ip,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>typename tuple_element<expression,pair<__xcodeml_template_type_0_1,__xcodeml_template_type_0_2> >::type const(*get(pair<__xcodeml_template_type_0_1,__xcodeml_template_type_0_2>))
template<typename __xcodeml_template_type_0_0,unsigned long _Size>class array;
;
template<typename __xcodeml_template_type_0_0,unsigned long _Size>class __tuple_like<array<__xcodeml_template_type_0_0,expression> >:public integral_constant<bool,1>{}
;
template<unsigned long _Ip,typename __xcodeml_template_type_0_1,unsigned long _Size>__xcodeml_template_type_0_1&get(array<__xcodeml_template_type_0_1,expression>)
template<unsigned long _Ip,typename __xcodeml_template_type_0_1,unsigned long _Size>__xcodeml_template_type_0_1 const&get(array<__xcodeml_template_type_0_1,expression>)
template<unsigned long _Ip,typename __xcodeml_template_type_0_1,unsigned long _Size>__xcodeml_template_type_0_1(*get(array<__xcodeml_template_type_0_1,expression>))
template<unsigned long _Ip,typename __xcodeml_template_type_0_1,unsigned long _Size>__xcodeml_template_type_0_1 const(*get(array<__xcodeml_template_type_0_1,expression>))
template<typename __xcodeml_template_type_0_0>class __tuple_types{}
;
template<>class __tuple_types<...>{}
;
template<unsigned long _Ip,typename __xcodeml_template_type_0_1>class tuple_element<expression,__tuple_types<...> >{
/* Ignored a member with no access specifier (_Ip<)"tuple_element index out of range";*/

public:typedef __type_pack_element<expression,...>;
}
;
template<typename __xcodeml_template_type_0_0>class tuple_size<__tuple_types<...> >:public integral_constant<unsigned long,expression>{}
;
template<typename __xcodeml_template_type_0_0>class __tuple_like<__tuple_types<...> >:public integral_constant<bool,1>{}
;
template<bool _ApplyLV,bool _ApplyConst,bool _ApplyVolatile>class __apply_cv_mf;
;
template<>class __apply_cv_mf<0,0,0>{public:template<typename __xcodeml_template_type_0_0>using __apply=__xcodeml_template_type_0_0;
}
;
template<>class __apply_cv_mf<0,1,0>{public:template<typename __xcodeml_template_type_0_0>using __apply=__xcodeml_template_type_0_0 const;
}
;
template<>class __apply_cv_mf<0,0,1>{public:template<typename __xcodeml_template_type_0_0>using __apply=__xcodeml_template_type_0_0 volatile;
}
;
template<>class __apply_cv_mf<0,1,1>{public:template<typename __xcodeml_template_type_0_0>using __apply=__xcodeml_template_type_0_0 volatile const;
}
;
template<>class __apply_cv_mf<1,0,0>{public:template<typename __xcodeml_template_type_0_0>using __apply=__xcodeml_template_type_0_0&;
}
;
template<>class __apply_cv_mf<1,1,0>{public:template<typename __xcodeml_template_type_0_0>using __apply=__xcodeml_template_type_0_0 const&;
}
;
template<>class __apply_cv_mf<1,0,1>{public:template<typename __xcodeml_template_type_0_0>using __apply=__xcodeml_template_type_0_0 volatile&;
}
;
template<>class __apply_cv_mf<1,1,1>{public:template<typename __xcodeml_template_type_0_0>using __apply=__xcodeml_template_type_0_0 volatile const&;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>using __apply_cv_t=__apply_cv_mf<expression,expression,expression>;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __make_tuple_types_flat;
;
template<typename __xcodeml_template_type_0_1,unsigned long _Idx>class __make_tuple_types_flat< <...>,__tuple_indices<...> >{public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>using __apply_quals=__tuple_types<...>;
}
;
template<typename __xcodeml_template_type_0_0,unsigned long _Np,unsigned long _Idx>class __make_tuple_types_flat<array<__xcodeml_template_type_0_0,expression>,__tuple_indices<...> >{public:template<unsigned long>using __value_type=__xcodeml_template_type_0_0;
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>using __apply_quals=__tuple_types<...>;
}
;
template<typename __xcodeml_template_type_0_0,unsigned long _Ep=tuple_size<typename remove_reference<__xcodeml_template_type_0_0>::type>::value,unsigned long _Sp=0,bool _SameSize=(_Ep==tuple_size<typename remove_reference<__xcodeml_template_type_0_0>::type>::value)>class __make_tuple_types{
/* Ignored a member with no access specifier (_Sp<=_Ep)"__make_tuple_types input error";*/

public:using _RawTp=typename remove_cv<typename remove_reference<__xcodeml_template_type_0_0>::type>::type;
public:using _Maker=__make_tuple_types_flat<typename remove_cv<typename remove_reference<__xcodeml_template_type_0_0>::type>::type,typename __make_tuple_indices<expression,expression>::type>;
public:using type=void/**/;
}
;
;
template<typename __xcodeml_template_type_0_0,unsigned long _Ep>class __make_tuple_types<tuple<...>,expression,0,1>{public:typedef __tuple_types<...>;
}
;
template<typename __xcodeml_template_type_0_0,unsigned long _Ep>class __make_tuple_types<__tuple_types<...>,expression,0,1>{public:typedef __tuple_types<...>;
}
;
template<bool _Preds>class __all_dummy;
;
template<bool _Pred>using __all=integral_constant<bool,expression>;
class __tuple_sfinae_base{public:template<typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>static integral_constant<bool,expression>
public:template<>static class::std::__1::integral_constant<bool,0>__do_test(...)
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>using __constructible=decltype ();
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>using __convertible=decltype ();
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>using __assignable=decltype ();
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,bool=__tuple_like<typename remove_reference<__xcodeml_template_type_0_0>::type>::value,bool=__tuple_like<__xcodeml_template_type_0_1>::value>class __tuple_convertible:public integral_constant<bool,0>{}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __tuple_convertible<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,1,1>:public/**/{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,bool=__tuple_like<typename remove_reference<__xcodeml_template_type_0_0>::type>::value,bool=__tuple_like<__xcodeml_template_type_0_1>::value>class __tuple_constructible:public integral_constant<bool,0>{}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __tuple_constructible<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,1,1>:public/**/{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,bool=__tuple_like<typename remove_reference<__xcodeml_template_type_0_0>::type>::value,bool=__tuple_like<__xcodeml_template_type_0_1>::value>class __tuple_assignable:public integral_constant<bool,0>{}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __tuple_assignable<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,1,1>:public/**/{}
;
template<unsigned long _Ip,typename __xcodeml_template_type_0_1>class tuple_element<expression,tuple<...> >{public:typedef typename tuple_element<expression,__tuple_types<...> >::type type;
}
;
template<unsigned long _Ip,typename __xcodeml_template_type_0_1>using tuple_element_t=typename tuple_element<expression,void/**/>::type;
template<bool _IsTuple,typename __xcodeml_template_type_0_1,unsigned long _Expected>class __tuple_like_with_size_imp:public integral_constant<bool,0>{}
;
template<>class __tuple_like_with_size_imp<1,class::std::__1::tuple_size<class::std::__1::pair<unsigned long,unsigned long> >,2>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0,unsigned long _Expected>class __tuple_like_with_size_imp<1,__xcodeml_template_type_0_0,expression>:public integral_constant<bool,expression>{}
;
template<typename __xcodeml_template_type_0_0,unsigned long _ExpectedSize,typename __xcodeml_template_type_0_2>using __tuple_like_with_size=__tuple_like_with_size_imp<expression,tuple_size<__xcodeml_template_type_0_2>,expression>;
class __check_tuple_constructor_fail{public:template<typename __xcodeml_template_type_0_0>static bool __enable_default(){return false;
}
public:template<typename __xcodeml_template_type_0_0>static bool __enable_explicit(){return false;
}
public:template<typename __xcodeml_template_type_0_0>static bool __enable_implicit(){return false;
}
static template <>bool __enable_implicit(){return false;
}
public:template<typename __xcodeml_template_type_0_0>static bool __enable_assign(){return false;
}
static template <>bool __enable_assign(){return false;
}
}
;
}
}
typedef signed char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef long int64_t;
typedef long intptr_t;
typedef unsigned long uintptr_t;
typedef long intmax_t;
typedef unsigned long uintmax_t;
typedef signed char int_least8_t;
typedef short int_least16_t;
typedef int int_least32_t;
typedef long int_least64_t;
typedef unsigned char uint_least8_t;
typedef unsigned short uint_least16_t;
typedef unsigned int uint_least32_t;
typedef unsigned long uint_least64_t;
typedef int int_fast8_t;
typedef int int_fast16_t;
typedef int int_fast32_t;
typedef long int_fast64_t;
typedef unsigned int uint_fast8_t;
typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
typedef unsigned long uint_fast64_t;
namespace std{namespace __1{::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
}
}
namespace std{namespace __1{namespace rel_ops{template<typename __xcodeml_template_type_0_0>bool operator!=(__xcodeml_template_type_0_0 const&__x,__xcodeml_template_type_0_0 const&__y){return(!(__x==__y));
}
template<typename __xcodeml_template_type_0_0>bool operator>(__xcodeml_template_type_0_0 const&__x,__xcodeml_template_type_0_0 const&__y){return(__y<__x);
}
template<typename __xcodeml_template_type_0_0>bool operator<=(__xcodeml_template_type_0_0 const&__x,__xcodeml_template_type_0_0 const&__y){return(!(__y<__x));
}
template<typename __xcodeml_template_type_0_0>bool operator>=(__xcodeml_template_type_0_0 const&__x,__xcodeml_template_type_0_0 const&__y){return(!(__x<__y));
}
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_1 swap_ranges(__xcodeml_template_type_0_0 __first1,__xcodeml_template_type_0_0 __last1,__xcodeml_template_type_0_1 __first2){{;for(;(__first1!=__last1);((++__first1),((void)(++__first2)))){(((*__first1),(*__first2)));}};
return __first2;
}
template<typename __xcodeml_template_type_0_0,unsigned long _Np>typename enable_if<expression,void>::type swap(__xcodeml_template_type_0_0&__a,__xcodeml_template_type_0_0&__b){(std::__1::(__a,(__a+_Np),__b));
}
template<typename __xcodeml_template_type_0_0>typename conditional<expression,__xcodeml_template_type_0_0 const&,__xcodeml_template_type_0_0(*)>::type move_if_noexcept(__xcodeml_template_type_0_0&__x){return(std::__1::(__x));
}
class piecewise_construct_t{}
;
constexpr class piecewise_construct_t const piecewise_construct=__xcodeml_identity<class::std::__1::piecewise_construct_t>::t();
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __non_trivially_copyable_base{public:__non_trivially_copyable_base(){}
public:__non_trivially_copyable_base(class __non_trivially_copyable_base const&){}
}
;
template<>class __non_trivially_copyable_base<unsigned long,unsigned long>{public:__non_trivially_copyable_base(){}
public:__non_trivially_copyable_base(class __non_trivially_copyable_base const&){}
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class pair:private __non_trivially_copyable_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>{public:typedef __xcodeml_template_type_0_0 first_type;
public:typedef __xcodeml_template_type_0_1 second_type;
public:__xcodeml_template_type_0_0 first;
public:__xcodeml_template_type_0_1 second;
public:pair(class pair const&);
public:pair(class pair(*));
public:template<bool _Val>using _EnableB=typename enable_if<expression,bool>::type;
public:class _CheckArgs{public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>static bool __enable_default(){return(is_default_constructible<__xcodeml_template_type_1_0>::value&&is_default_constructible<__xcodeml_template_type_1_1>::value);
}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>static bool __enable_explicit(){return((is_constructible<__xcodeml_template_type_0_0,...>::value&&is_constructible<__xcodeml_template_type_0_1,...>::value)&&((!is_convertible<__xcodeml_template_type_1_0,__xcodeml_template_type_0_0>::value)||(!is_convertible<__xcodeml_template_type_1_1,__xcodeml_template_type_0_1>::value)));
}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>static bool __enable_implicit(){return(((is_constructible<__xcodeml_template_type_0_0,...>::value&&is_constructible<__xcodeml_template_type_0_1,...>::value)&&is_convertible<__xcodeml_template_type_1_0,__xcodeml_template_type_0_0>::value)&&is_convertible<__xcodeml_template_type_1_1,__xcodeml_template_type_0_1>::value);
}
}
;
public:template<bool _MaybeEnable>using _CheckArgsDep=typename conditional<expression,class::std::__1::pair::_CheckArgs,class::std::__1::__check_tuple_constructor_fail>::type;
public:class _CheckTupleLikeConstructor{public:template<typename __xcodeml_template_type_1_0>static bool __enable_implicit(){return __tuple_convertible<__xcodeml_template_type_1_0,class pair,expression,expression>::value;
}
public:template<typename __xcodeml_template_type_1_0>static bool __enable_explicit(){return(__tuple_constructible<__xcodeml_template_type_1_0,class pair,expression,expression>::value&&(!__tuple_convertible<__xcodeml_template_type_1_0,class pair,expression,expression>::value));
}
public:template<typename __xcodeml_template_type_1_0>static bool __enable_assign(){return __tuple_assignable<__xcodeml_template_type_1_0,class pair,expression,expression>::value;
}
}
;
public:template<typename __xcodeml_template_type_1_0>using _CheckTLC=typename conditional<expression,class::std::__1::pair::_CheckTupleLikeConstructor,class::std::__1::__check_tuple_constructor_fail>::type;
public:template<bool _Dummy=true,typename enable_if<expression,bool>::type=false>pair():first(),second(){}
public:template<bool _Dummy=true,typename enable_if<expression,bool>::type=false>pair(__xcodeml_template_type_0_0 const&__t1,__xcodeml_template_type_0_1 const&__t2):first(__t1),second(__t2){}
public:template<bool _Dummy=true,typename enable_if<expression,bool>::type=false>pair(__xcodeml_template_type_0_0 const&__t1,__xcodeml_template_type_0_1 const&__t2):first(__t1),second(__t2){}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1,typename enable_if<expression,bool>::type=false>pair(__xcodeml_template_type_1_0(*__u1),__xcodeml_template_type_1_1(*__u2)):first((std::__1::__xcodeml_template_type_1_0(__u1))),second((std::__1::__xcodeml_template_type_1_1(__u2))){}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1,typename enable_if<expression,bool>::type=false>pair(__xcodeml_template_type_1_0(*__u1),__xcodeml_template_type_1_1(*__u2)):first((std::__1::__xcodeml_template_type_1_0(__u1))),second((std::__1::__xcodeml_template_type_1_1(__u2))){}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1,typename enable_if<expression,bool>::type=false>pair(pair<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1>):first(__p.first),second(__p.second){}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1,typename enable_if<expression,bool>::type=false>pair(pair<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1>):first(__p.first),second(__p.second){}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1,typename enable_if<expression,bool>::type=false>pair(pair<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1>):first((std::__1::__xcodeml_template_type_1_0(__p.first))),second((std::__1::__xcodeml_template_type_1_1(__p.second))){}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1,typename enable_if<expression,bool>::type=false>pair(pair<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1>):first((std::__1::__xcodeml_template_type_1_0(__p.first))),second((std::__1::__xcodeml_template_type_1_1(__p.second))){}
public:template<typename __xcodeml_template_type_1_0,typename enable_if<expression,bool>::type=false>pair(__xcodeml_template_type_1_0(*__p)):first((std::__1::0((std::__1::__xcodeml_template_type_1_0(__p))))),second((std::__1::1((std::__1::__xcodeml_template_type_1_0(__p))))){}
public:template<typename __xcodeml_template_type_1_0,typename enable_if<expression,bool>::type=false>pair(__xcodeml_template_type_1_0(*__p)):first((std::__1::0((std::__1::__xcodeml_template_type_1_0(__p))))),second((std::__1::1((std::__1::__xcodeml_template_type_1_0(__p))))){}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>pair(class::std::__1::piecewise_construct_t __pc,tuple<...>,tuple<...>):pair(__pc __first_args __second_args __xcodeml_identity<typename __make_tuple_indices<expression,0>::type>::t()__xcodeml_identity<typename __make_tuple_indices<expression,0>::type>::t()){}
public:class pair&operator=(typename conditional<expression,class pair,class::std::__1::__nat>::type const&__p){(this->first=__p.first);
(this->second=__p.second);
return(*this);
}
public:class pair&operator=(typename conditional<expression,class pair,class::std::__1::__nat>::type(*__p)){(this->first=(std::__1::__xcodeml_template_type_0_0(__p.first)));
(this->second=(std::__1::__xcodeml_template_type_0_1(__p.second)));
return(*this);
}
public:template<typename __xcodeml_template_type_1_0,typename enable_if<expression,bool>::type=false>class pair&operator=(__xcodeml_template_type_1_0(*__p)){(this->first=(std::__1::0((std::__1::__xcodeml_template_type_1_0(__p)))));
(this->second=(std::__1::1((std::__1::__xcodeml_template_type_1_0(__p)))));
return(*this);
}
public:void swap(class pair&__p){std::__1::;
((this->first,__p.first));
((this->second,__p.second));
}
private:
private:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1,unsigned long _I1,unsigned long _I2>pair(class::std::__1::piecewise_construct_t,tuple<...>,tuple<...>,__tuple_indices<...>,__tuple_indices<...>)
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator==(pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>){return((__x.first,__y.first)&&(__x.second,__y.second));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator!=(pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>){return(!(__x,__y));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator<(pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>){return((__x.first,__y.first)||((!(__y.first,__x.first))&&(__x.second,__y.second)));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator>(pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>){return(__y,__x);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator>=(pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>){return(!(__x,__y));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator<=(pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>){return(!(__y,__x));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename enable_if<expression,void>::type swap(pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>){(__x.swap(__y));
}
template<typename __xcodeml_template_type_0_0>class __unwrap_reference{public:typedef __xcodeml_template_type_0_0 type;
}
;
;
template<typename __xcodeml_template_type_0_0>class __unwrap_reference<reference_wrapper<__xcodeml_template_type_0_0> >{public:typedef __xcodeml_template_type_0_0&type;
}
;
template<typename __xcodeml_template_type_0_0>class __unwrap_ref_decay:public __unwrap_reference<typename decay<__xcodeml_template_type_0_0>::type>{}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>pair<typename __unwrap_ref_decay<__xcodeml_template_type_0_0>::type,typename __unwrap_ref_decay<__xcodeml_template_type_0_1>::type>{return __xcodeml_identity<pair<typename __unwrap_ref_decay<__xcodeml_template_type_0_0>::type,typename __unwrap_ref_decay<__xcodeml_template_type_0_1>::type> >::t((std::__1::__xcodeml_template_type_0_0(__t1)),(std::__1::__xcodeml_template_type_0_1(__t2)));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class tuple_size<pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1> >:public integral_constant<unsigned long,2>{}
;
template<unsigned long _Ip,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class tuple_element<expression,pair<__xcodeml_template_type_0_1,__xcodeml_template_type_0_2> >{
/* Ignored a member with no access specifier (_Ip<2)"Index out of bounds in std::tuple_element<std::pair<T1, T2>>";*/

}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class tuple_element<0,pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1> >{public:typedef __xcodeml_template_type_0_0 type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class tuple_element<1,pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1> >{public:typedef __xcodeml_template_type_0_1 type;
}
;
template<unsigned long _Ip>class __get_pair;
;
template<>class __get_pair<0>{public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>static __xcodeml_template_type_0_0&get(pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>){return __p.first;
}
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>static __xcodeml_template_type_0_0 const&get(pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>){return __p.first;
}
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>static __xcodeml_template_type_0_0(*get(pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>)){return(std::__1::__xcodeml_template_type_0_0(__p.first));
}
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>static __xcodeml_template_type_0_0 const(*get(pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>)){return(std::__1::__xcodeml_template_type_0_0(__p.first));
}
}
;
template<>class __get_pair<1>{public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>static __xcodeml_template_type_0_1&get(pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>){return __p.second;
}
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>static __xcodeml_template_type_0_1 const&get(pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>){return __p.second;
}
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>static __xcodeml_template_type_0_1(*get(pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>)){return(std::__1::__xcodeml_template_type_0_1(__p.second));
}
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>static __xcodeml_template_type_0_1 const(*get(pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>)){return(std::__1::__xcodeml_template_type_0_1(__p.second));
}
}
;
template<unsigned long _Ip,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>typename tuple_element<expression,pair<__xcodeml_template_type_0_1,__xcodeml_template_type_0_2> >::type&get(pair<__xcodeml_template_type_0_1,__xcodeml_template_type_0_2>){return(__get_pair<expression>::get(__p));
}
template<unsigned long _Ip,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>typename tuple_element<expression,pair<__xcodeml_template_type_0_1,__xcodeml_template_type_0_2> >::type const&get(pair<__xcodeml_template_type_0_1,__xcodeml_template_type_0_2>){return(__get_pair<expression>::get(__p));
}
template<unsigned long _Ip,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>typename tuple_element<expression,pair<__xcodeml_template_type_0_1,__xcodeml_template_type_0_2> >::type(*get(pair<__xcodeml_template_type_0_1,__xcodeml_template_type_0_2>)){return(__get_pair<expression>::get((std::__1::(__p))));
}
template<unsigned long _Ip,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>typename tuple_element<expression,pair<__xcodeml_template_type_0_1,__xcodeml_template_type_0_2> >::type const(*get(pair<__xcodeml_template_type_0_1,__xcodeml_template_type_0_2>)){return(__get_pair<expression>::get((std::__1::(__p))));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0&get(pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>){return(__get_pair::(__p));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0 const&get(pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>){return(__get_pair::(__p));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0(*get(pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>)){return(__get_pair::((std::__1::(__p))));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0 const(*get(pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>)){return(__get_pair::((std::__1::(__p))));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0&get(pair<__xcodeml_template_type_0_1,__xcodeml_template_type_0_0>){return(__get_pair::(__p));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0 const&get(pair<__xcodeml_template_type_0_1,__xcodeml_template_type_0_0>){return(__get_pair::(__p));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0(*get(pair<__xcodeml_template_type_0_1,__xcodeml_template_type_0_0>)){return(__get_pair::((std::__1::(__p))));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0 const(*get(pair<__xcodeml_template_type_0_1,__xcodeml_template_type_0_0>)){return(__get_pair::((std::__1::(__p))));
}
template<typename __xcodeml_template_type_0_0,__xcodeml_template_type_0_0 _Ip>class integer_sequence{public:typedef __xcodeml_template_type_0_0 value_type;

/* Ignored a member with no access specifier is_integral<__xcodeml_template_type_0_0>::value"std::integer_sequence can only be instantiated with an integral type";*/

public:static unsigned long size(){return;
}
}
;
;
template<unsigned long _Ip>using index_sequence=integer_sequence<unsigned long,...>;
template<typename __xcodeml_template_type_0_0,__xcodeml_template_type_0_0 _Ep>using __make_integer_sequence=__make_integer_seq<integer_sequence,__xcodeml_template_type_0_0,expression>;
template<typename __xcodeml_template_type_0_0,__xcodeml_template_type_0_0 _Np>using make_integer_sequence=__make_integer_seq<integer_sequence,__xcodeml_template_type_0_0,expression>;
template<unsigned long _Np>using make_index_sequence=__make_integer_seq<integer_sequence,unsigned long,expression>;
template<typename __xcodeml_template_type_0_0>using index_sequence_for=__make_integer_seq<integer_sequence,unsigned long,expression>;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0 exchange(__xcodeml_template_type_0_0&__obj,__xcodeml_template_type_0_1(*__new_value)){__xcodeml_template_type_0_0 __old_value=(std::__1::(__obj));
(__obj=(std::__1::__xcodeml_template_type_0_1(__new_value)));
return __old_value;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class unary_function{public:typedef __xcodeml_template_type_0_0 argument_type;
public:typedef __xcodeml_template_type_0_1 result_type;
}
;
template<>class unary_function<class::std::__1::_PairT,unsigned long>{public:typedef class::std::__1::_PairT argument_type;
public:typedef unsigned long result_type;
}
template<>class unary_function<bool,unsigned long>{public:typedef bool argument_type;
public:typedef unsigned long result_type;
}
template<>class unary_function<char,unsigned long>{public:typedef char argument_type;
public:typedef unsigned long result_type;
}
template<>class unary_function<signed char,unsigned long>{public:typedef signed char argument_type;
public:typedef unsigned long result_type;
}
template<>class unary_function<unsigned char,unsigned long>{public:typedef unsigned char argument_type;
public:typedef unsigned long result_type;
}
template<>class unary_function<char16_t,unsigned long>{public:typedef char16_t argument_type;
public:typedef unsigned long result_type;
}
template<>class unary_function<char32_t,unsigned long>{public:typedef char32_t argument_type;
public:typedef unsigned long result_type;
}
template<>class unary_function<wchar_t,unsigned long>{public:typedef wchar_t argument_type;
public:typedef unsigned long result_type;
}
template<>class unary_function<short,unsigned long>{public:typedef short argument_type;
public:typedef unsigned long result_type;
}
template<>class unary_function<unsigned short,unsigned long>{public:typedef unsigned short argument_type;
public:typedef unsigned long result_type;
}
template<>class unary_function<int,unsigned long>{public:typedef int argument_type;
public:typedef unsigned long result_type;
}
template<>class unary_function<unsigned int,unsigned long>{public:typedef unsigned int argument_type;
public:typedef unsigned long result_type;
}
template<>class unary_function<long,unsigned long>{public:typedef long argument_type;
public:typedef unsigned long result_type;
}
template<>class unary_function<unsigned long,unsigned long>{public:typedef unsigned long argument_type;
public:typedef unsigned long result_type;
}
template<>class unary_function<long long,unsigned long>{public:typedef long long argument_type;
public:typedef unsigned long result_type;
}
template<>class unary_function<unsigned long long,unsigned long>{public:typedef unsigned long long argument_type;
public:typedef unsigned long result_type;
}
template<>class unary_function<__int128,unsigned long>{public:typedef __int128 argument_type;
public:typedef unsigned long result_type;
}
template<>class unary_function<unsigned __int128,unsigned long>{public:typedef unsigned __int128 argument_type;
public:typedef unsigned long result_type;
}
template<>class unary_function<float,unsigned long>{public:typedef float argument_type;
public:typedef unsigned long result_type;
}
template<>class unary_function<double,unsigned long>{public:typedef double argument_type;
public:typedef unsigned long result_type;
}
template<>class unary_function<long double,unsigned long>{public:typedef long double argument_type;
public:typedef unsigned long result_type;
}
;
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 __loadword(void const(*__p)){__xcodeml_template_type_0_0 __r;
(std::memcpy((&__r),__p,(sizeof(__r))));
return __r;
}
template <>unsigned int __loadword(void const(*__p)){unsigned int __r;
(std::memcpy((&__r),__p,(sizeof(__r))));
return __r;
}
template <>unsigned long __loadword(void const(*__p)){unsigned long __r;
(std::memcpy((&__r),__p,(sizeof(__r))));
return __r;
}
template<typename __xcodeml_template_type_0_0,unsigned long=((sizeof(__xcodeml_template_type_0_0))*8)>class __murmur2_or_cityhash;
template<>class __murmur2_or_cityhash<unsigned long,64>{public:unsigned long operator()(void const(*__key),unsigned long __len){char const(*__s)=static_cast<char const(*)>(__key);
if((__len<=32)){{if((__len<=16)){{return(__hash_len_0_to_16(__s,__len));
};}else{{return(__hash_len_17_to_32(__s,__len));
};};
};}else{if((__len<=64)){{return(__hash_len_33_to_64(__s,__len));
};};};
unsigned long __x=(__loadword<unsigned long>(((__s+__len)-40)));
unsigned long __y=((__loadword<unsigned long>(((__s+__len)-16)))+(__loadword<unsigned long>(((__s+__len)-56))));
unsigned long __z=(__hash_len_16(((__loadword<unsigned long>(((__s+__len)-48)))+__len),(__loadword<unsigned long>(((__s+__len)-24)))));
class::std::__1::pair<unsigned long,unsigned long>__v=(__weak_hash_len_32_with_seeds(((__s+__len)-64),__len,__z));
class::std::__1::pair<unsigned long,unsigned long>__w=(__weak_hash_len_32_with_seeds(((__s+__len)-32),(__y+__k1),__x));
(__x=((__x*__k1)+(__loadword<unsigned long>(__s))));
(__len=((__len-1)&(~static_cast<unsigned long>(63))));
do{{(__x=((__rotate((((__x+__y)+__v.first)+(__loadword<unsigned long>((__s+8)))),37))*__k1));
(__y=((__rotate(((__y+__v.second)+(__loadword<unsigned long>((__s+48)))),42))*__k1));
(__x^=__w.second);
(__y+=(__v.first+(__loadword<unsigned long>((__s+40)))));
(__z=((__rotate((__z+__w.first),33))*__k1));
__v.operator=((__weak_hash_len_32_with_seeds(__s,(__v.second*__k1),(__x+__w.first))));
__w.operator=((__weak_hash_len_32_with_seeds((__s+32),(__z+__w.second),(__y+(__loadword<unsigned long>((__s+16)))))));
(std::swap(__z,__x));
(__s+=64);
(__len-=64);
};}while((__len!=0));
return(__hash_len_16((((__hash_len_16(__v.first,__w.first))+((__shift_mix(__y))*__k1))+__z),((__hash_len_16(__v.second,__w.second))+__x)));
}
private:
private:static unsigned long const __k0=0xc3a5c85c97cb3127ULL;
private:static unsigned long const __k1=0xb492b66fbe98f273ULL;
private:static unsigned long const __k2=0x9ae16a3b2f90404fULL;
private:static unsigned long const __k3=0xc949d7c7509e6557ULL;
private:static unsigned long __rotate(unsigned long __val,int __shift){return((__shift==0)?__val:((__val>>__shift)|(__val<<(64-__shift))));
}
private:static unsigned long __rotate_by_at_least_1(unsigned long __val,int __shift){return((__val>>__shift)|(__val<<(64-__shift)));
}
private:static unsigned long __shift_mix(unsigned long __val){return(__val^(__val>>47));
}
private:static unsigned long __hash_len_16(unsigned long __u,unsigned long __v){unsigned long const __mul=0x9ddfea08eb382d69ULL;
unsigned long __a=((__u^__v)*__mul);
(__a^=(__a>>47));
unsigned long __b=((__v^__a)*__mul);
(__b^=(__b>>47));
(__b*=__mul);
return __b;
}
private:static unsigned long __hash_len_0_to_16(char const(*__s),unsigned long __len){if((__len>8)){{unsigned long const __a=(__loadword<unsigned long>(__s));
unsigned long const __b=(__loadword<unsigned long>(((__s+__len)-8)));
return((__hash_len_16(__a,(__rotate_by_at_least_1((__b+__len),__len))))^__b);
};};
if((__len>=4)){{unsigned int const __a=(__loadword(__s));
unsigned int const __b=(__loadword<unsigned int>(((__s+__len)-4)));
return(__hash_len_16((__len+(__a<<3)),__b));
};};
if((__len>0)){{unsigned char const __a=(__s)[0];
unsigned char const __b=(__s)[(__len>>1)];
unsigned char const __c=(__s)[(__len-1)];
unsigned int const __y=(static_cast<unsigned int>(__a)+(static_cast<unsigned int>(__b)<<8));
unsigned int const __z=(__len+(static_cast<unsigned int>(__c)<<2));
return((__shift_mix(((__y*__k2)^(__z*__k3))))*__k2);
};};
return __k2;
}
private:static unsigned long __hash_len_17_to_32(char const(*__s),unsigned long __len){unsigned long const __a=((__loadword<unsigned long>(__s))*__k1);
unsigned long const __b=(__loadword<unsigned long>((__s+8)));
unsigned long const __c=((__loadword<unsigned long>(((__s+__len)-8)))*__k2);
unsigned long const __d=((__loadword<unsigned long>(((__s+__len)-16)))*__k0);
return(__hash_len_16((((__rotate((__a-__b),43))+(__rotate(__c,30)))+__d),(((__a+(__rotate((__b^__k3),20)))-__c)+__len)));
}
private:static class::std::__1::pair<unsigned long,unsigned long>__weak_hash_len_32_with_seeds(unsigned long __w,unsigned long __x,unsigned long __y,unsigned long __z,unsigned long __a,unsigned long __b){(__a+=__w);
(__b=(__rotate(((__b+__a)+__z),21)));
unsigned long const __c=__a;
(__a+=__x);
(__a+=__y);
(__b+=(__rotate(__a,44)));
return __xcodeml_identity<class::std::__1::pair<unsigned long,unsigned long> >::t((__a+__z),(__b+__c));
}
private:static class::std::__1::pair<unsigned long,unsigned long>__weak_hash_len_32_with_seeds(char const(*__s),unsigned long __a,unsigned long __b){return(__weak_hash_len_32_with_seeds((__loadword<unsigned long>(__s)),(__loadword<unsigned long>((__s+8))),(__loadword<unsigned long>((__s+16))),(__loadword<unsigned long>((__s+24))),__a,__b));
}
private:static unsigned long __hash_len_33_to_64(char const(*__s),unsigned long __len){unsigned long __z=(__loadword<unsigned long>((__s+24)));
unsigned long __a=((__loadword<unsigned long>(__s))+((__len+(__loadword<unsigned long>(((__s+__len)-16))))*__k0));
unsigned long __b=(__rotate((__a+__z),52));
unsigned long __c=(__rotate(__a,37));
(__a+=(__loadword<unsigned long>((__s+8))));
(__c+=(__rotate(__a,7)));
(__a+=(__loadword<unsigned long>((__s+16))));
unsigned long __vf=(__a+__z);
unsigned long __vs=((__b+(__rotate(__a,31)))+__c);
(__a=((__loadword<unsigned long>((__s+16)))+(__loadword<unsigned long>(((__s+__len)-32)))));
(__z+=(__loadword<unsigned long>(((__s+__len)-8))));
(__b=(__rotate((__a+__z),52)));
(__c=(__rotate(__a,37)));
(__a+=(__loadword<unsigned long>(((__s+__len)-24))));
(__c+=(__rotate(__a,7)));
(__a+=(__loadword<unsigned long>(((__s+__len)-16))));
unsigned long __wf=(__a+__z);
unsigned long __ws=((__b+(__rotate(__a,31)))+__c);
unsigned long __r=(__shift_mix((((__vf+__ws)*__k2)+((__wf+__vs)*__k0))));
return((__shift_mix(((__r*__k0)+__vs)))*__k2);
}
}
;
template<typename __xcodeml_template_type_0_0>class __murmur2_or_cityhash<__xcodeml_template_type_0_0,32>{public:__xcodeml_template_type_0_0 operator()(void const(*__key),__xcodeml_template_type_0_0 __len);
}
;
__xcodeml_template_type_0_0 __murmur2_or_cityhash::operator()(void const(*__key),__xcodeml_template_type_0_0 __len){__xcodeml_template_type_0_0 const __m=0x5bd1e995;
__xcodeml_template_type_0_0 const __r=24;
__xcodeml_template_type_0_0 __h=__len;
unsigned char const(*__data)=static_cast<unsigned char const(*)>(__key);
{;for(;(__len,4);((__data+=4),(__len-=4))){{__xcodeml_template_type_0_0 __k=(__xcodeml_template_type_0_0(__data));
(__k*=__m);
(__k^=(__k>>__r));
(__k*=__m);
(__h*=__m);
(__h^=__k);
};}};
switch(__len){case 3:(__h^=((__data)[2]<<16));
;
case 2:(__h^=((__data)[1]<<8));
;
case 1:(__h^=(__data)[0]);
(__h*=__m);
};
(__h^=(__h>>13));
(__h*=__m);
(__h^=(__h>>15));
return __h;
}
template<typename __xcodeml_template_type_0_0>class __murmur2_or_cityhash<__xcodeml_template_type_0_0,64>{public:__xcodeml_template_type_0_0 operator()(void const(*__key),__xcodeml_template_type_0_0 __len);
private:
private:static __xcodeml_template_type_0_0 const __k0=0xc3a5c85c97cb3127ULL;
private:static __xcodeml_template_type_0_0 const __k1=0xb492b66fbe98f273ULL;
private:static __xcodeml_template_type_0_0 const __k2=0x9ae16a3b2f90404fULL;
private:static __xcodeml_template_type_0_0 const __k3=0xc949d7c7509e6557ULL;
private:static __xcodeml_template_type_0_0 __rotate(__xcodeml_template_type_0_0 __val,int __shift){return((__shift==0)?__val:((__val>>__shift)|(__val<<(64-__shift))));
}
private:static __xcodeml_template_type_0_0 __rotate_by_at_least_1(__xcodeml_template_type_0_0 __val,int __shift){return((__val>>__shift)|(__val<<(64-__shift)));
}
private:static __xcodeml_template_type_0_0 __shift_mix(__xcodeml_template_type_0_0 __val){return(__val^(__val>>47));
}
private:static __xcodeml_template_type_0_0 __hash_len_16(__xcodeml_template_type_0_0 __u,__xcodeml_template_type_0_0 __v){__xcodeml_template_type_0_0 const __mul=0x9ddfea08eb382d69ULL;
__xcodeml_template_type_0_0 __a=((__u^__v)*__mul);
(__a^=(__a>>47));
__xcodeml_template_type_0_0 __b=((__v^__a)*__mul);
(__b^=(__b>>47));
(__b*=__mul);
return __b;
}
private:static __xcodeml_template_type_0_0 __hash_len_0_to_16(char const(*__s),__xcodeml_template_type_0_0 __len){if((__len,8)){{__xcodeml_template_type_0_0 const __a=(__xcodeml_template_type_0_0(__s));
__xcodeml_template_type_0_0 const __b=(__xcodeml_template_type_0_0(((__s+__len)-8)));
return((__hash_len_16(__a,(__rotate_by_at_least_1((__b+__len),__len))))^__b);
};};
if((__len,4)){{unsigned int const __a=(__loadword<unsigned int>(__s));
unsigned int const __b=(unsigned int(((__s+__len)-4)));
return(__hash_len_16((__len+(__a<<3)),__b));
};};
if((__len,0)){{unsigned char const __a=(__s)[0];
unsigned char const __b=(__s)[(__len>>1)];
unsigned char const __c=(__s)[(__len-1)];
unsigned int const __y=(static_cast<unsigned int>(__a)+(static_cast<unsigned int>(__b)<<8));
unsigned int const __z=(__len+(static_cast<unsigned int>(__c)<<2));
return((__shift_mix(((__y*__k2)^(__z*__k3))))*__k2);
};};
return __k2;
}
private:static __xcodeml_template_type_0_0 __hash_len_17_to_32(char const(*__s),__xcodeml_template_type_0_0 __len){__xcodeml_template_type_0_0 const __a=((__xcodeml_template_type_0_0(__s))*__k1);
__xcodeml_template_type_0_0 const __b=(__xcodeml_template_type_0_0((__s+8)));
__xcodeml_template_type_0_0 const __c=((__xcodeml_template_type_0_0(((__s+__len)-8)))*__k2);
__xcodeml_template_type_0_0 const __d=((__xcodeml_template_type_0_0(((__s+__len)-16)))*__k0);
return(__hash_len_16((((__rotate((__a-__b),43))+(__rotate(__c,30)))+__d),(((__a+(__rotate((__b^__k3),20)))-__c)+__len)));
}
private:static pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0>{(__a+=__w);
(__b=(__rotate(((__b+__a)+__z),21)));
__xcodeml_template_type_0_0 const __c=__a;
(__a+=__x);
(__a+=__y);
(__b+=(__rotate(__a,44)));
return __xcodeml_identity<pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0> >::t((__a+__z),(__b+__c));
}
private:static pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0>{return(((__xcodeml_template_type_0_0(__s)),(__xcodeml_template_type_0_0((__s+8))),(__xcodeml_template_type_0_0((__s+16))),(__xcodeml_template_type_0_0((__s+24))),__a,__b));
}
private:static __xcodeml_template_type_0_0 __hash_len_33_to_64(char const(*__s),unsigned long __len){__xcodeml_template_type_0_0 __z=(__xcodeml_template_type_0_0((__s+24)));
__xcodeml_template_type_0_0 __a=((__xcodeml_template_type_0_0(__s))+((__len+(__xcodeml_template_type_0_0(((__s+__len)-16))))*__k0));
__xcodeml_template_type_0_0 __b=(__rotate((__a+__z),52));
__xcodeml_template_type_0_0 __c=(__rotate(__a,37));
(__a+=(__xcodeml_template_type_0_0((__s+8))));
(__c+=(__rotate(__a,7)));
(__a+=(__xcodeml_template_type_0_0((__s+16))));
__xcodeml_template_type_0_0 __vf=(__a+__z);
__xcodeml_template_type_0_0 __vs=((__b+(__rotate(__a,31)))+__c);
(__a=((__xcodeml_template_type_0_0((__s+16)))+(__xcodeml_template_type_0_0(((__s+__len)-32)))));
(__z+=(__xcodeml_template_type_0_0(((__s+__len)-8))));
(__b=(__rotate((__a+__z),52)));
(__c=(__rotate(__a,37)));
(__a+=(__xcodeml_template_type_0_0(((__s+__len)-24))));
(__c+=(__rotate(__a,7)));
(__a+=(__xcodeml_template_type_0_0(((__s+__len)-16))));
__xcodeml_template_type_0_0 __wf=(__a+__z);
__xcodeml_template_type_0_0 __ws=((__b+(__rotate(__a,31)))+__c);
__xcodeml_template_type_0_0 __r=(__shift_mix((((__vf+__ws)*__k2)+((__wf+__vs)*__k0))));
return((__shift_mix(((__r*__k0)+__vs)))*__k2);
}
}
;
__xcodeml_template_type_0_0 __murmur2_or_cityhash::operator()(void const(*__key),__xcodeml_template_type_0_0 __len){char const(*__s)=static_cast<char const(*)>(__key);
if((__len,32)){{if((__len,16)){{return(__hash_len_0_to_16(__s,__len));
};}else{{return(__hash_len_17_to_32(__s,__len));
};};
};}else{if((__len,64)){{return(__hash_len_33_to_64(__s,__len));
};};};
__xcodeml_template_type_0_0 __x=(__xcodeml_template_type_0_0(((__s+__len)-40)));
__xcodeml_template_type_0_0 __y=((__xcodeml_template_type_0_0(((__s+__len)-16)))+(__xcodeml_template_type_0_0(((__s+__len)-56))));
__xcodeml_template_type_0_0 __z=(__hash_len_16(((__xcodeml_template_type_0_0(((__s+__len)-48)))+__len),(__xcodeml_template_type_0_0(((__s+__len)-24)))));
pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0> =((((__s+__len)-64),__len,__z));
pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0> =((((__s+__len)-32),(__y+__k1),__x));
(__x=((__x*__k1)+(__xcodeml_template_type_0_0(__s))));
(__len=((__len-1)&(~static_cast<__xcodeml_template_type_0_0>(63))));
do{{(__x=((__rotate((((__x+__y)+__v.first)+(__xcodeml_template_type_0_0((__s+8)))),37))*__k1));
(__y=((__rotate(((__y+__v.second)+(__xcodeml_template_type_0_0((__s+48)))),42))*__k1));
(__x^=__w.second);
(__y+=(__v.first+(__xcodeml_template_type_0_0((__s+40)))));
(__z=((__rotate((__z+__w.first),33))*__k1));
(__v=((__s,(__v.second*__k1),(__x+__w.first))));
(__w=(((__s+32),(__z+__w.second),(__y+(__xcodeml_template_type_0_0((__s+16)))))));
(std::(__z,__x));
(__s+=64);
(__len-=64);
};}while((__len,0));
return(__hash_len_16((((__hash_len_16(__v.first,__w.first))+((__shift_mix(__y))*__k1))+__z),((__hash_len_16(__v.second,__w.second))+__x)));
}
template<typename __xcodeml_template_type_0_0,unsigned long=((sizeof(__xcodeml_template_type_0_0))/(sizeof(unsigned long)))>class __scalar_hash;
template<>class __scalar_hash<class::std::__1::_PairT,2>:public unary_function<class::std::__1::_PairT,unsigned long>{public:unsigned long operator()(class::std::__1::_PairT __v)const{union __xcodeml_6{public:class::std::__1::_PairT __t;
public:class __xcodeml_7{public:unsigned long __a;
public:unsigned long __b;
}
;
public:class __xcodeml_6::__xcodeml_7 __s;
}
;union __xcodeml_6 __u;
__u.__t.operator=(__v);
return __xcodeml_identity<class::std::__1::__murmur2_or_cityhash<unsigned long,64> >::t().operator()((&__u),(sizeof(__u)));
}
}
template<>class __scalar_hash<long long,1>:public unary_function<long long,unsigned long>{public:unsigned long operator()(long long __v)const;
}
template<>class __scalar_hash<unsigned long long,1>:public unary_function<unsigned long long,unsigned long>{public:unsigned long operator()(unsigned long long __v)const;
}
template<>class __scalar_hash<__int128,2>:public unary_function<__int128,unsigned long>{public:unsigned long operator()(__int128 __v)const;
}
template<>class __scalar_hash<unsigned __int128,2>:public unary_function<unsigned __int128,unsigned long>{public:unsigned long operator()(unsigned __int128 __v)const;
}
template<>class __scalar_hash<float,0>:public unary_function<float,unsigned long>{public:unsigned long operator()(float __v)const{union __xcodeml_8{public:float __t;
public:unsigned long __a;
}
;union __xcodeml_8 __u;
(__u.__a=0);
(__u.__t=__v);
return __u.__a;
}
}
template<>class __scalar_hash<double,1>:public unary_function<double,unsigned long>{public:unsigned long operator()(double __v)const{union __xcodeml_9{public:double __t;
public:unsigned long __a;
}
;union __xcodeml_9 __u;
(__u.__t=__v);
return __u.__a;
}
}
template<>class __scalar_hash<long double,2>:public unary_function<long double,unsigned long>{public:unsigned long operator()(long double __v)const;
}
;
template<typename __xcodeml_template_type_0_0>class __scalar_hash<__xcodeml_template_type_0_0,0>:public unary_function<__xcodeml_template_type_0_0,unsigned long>{public:unsigned long operator()(__xcodeml_template_type_0_0 __v)const{union __xcodeml_10{public:__xcodeml_template_type_0_0 __t;
public:unsigned long __a;
}
;union __xcodeml_10 __u;
(__u.__a=0);
(__u.__t=__v);
return __u.__a;
}
}
;
template<typename __xcodeml_template_type_0_0>class __scalar_hash<__xcodeml_template_type_0_0,1>:public unary_function<__xcodeml_template_type_0_0,unsigned long>{public:unsigned long operator()(__xcodeml_template_type_0_0 __v)const{union __xcodeml_11{public:__xcodeml_template_type_0_0 __t;
public:unsigned long __a;
}
;union __xcodeml_11 __u;
(__u.__t=__v);
return __u.__a;
}
}
;
template<typename __xcodeml_template_type_0_0>class __scalar_hash<__xcodeml_template_type_0_0,2>:public unary_function<__xcodeml_template_type_0_0,unsigned long>{public:unsigned long operator()(__xcodeml_template_type_0_0 __v)const{union __xcodeml_12{public:__xcodeml_template_type_0_0 __t;
public:class __xcodeml_13{public:unsigned long __a;
public:unsigned long __b;
}
;
public:class __xcodeml_12::__xcodeml_13 __s;
}
;union __xcodeml_12 __u;
(__u.__t=__v);
return(__xcodeml_identity<class::std::__1::__murmur2_or_cityhash<unsigned long,64> >::t()((&__u),(sizeof(__u))));
}
}
;
template<typename __xcodeml_template_type_0_0>class __scalar_hash<__xcodeml_template_type_0_0,3>:public unary_function<__xcodeml_template_type_0_0,unsigned long>{public:unsigned long operator()(__xcodeml_template_type_0_0 __v)const{union __xcodeml_14{public:__xcodeml_template_type_0_0 __t;
public:class __xcodeml_15{public:unsigned long __a;
public:unsigned long __b;
public:unsigned long __c;
}
;
public:class __xcodeml_14::__xcodeml_15 __s;
}
;union __xcodeml_14 __u;
(__u.__t=__v);
return(__xcodeml_identity<class::std::__1::__murmur2_or_cityhash<unsigned long,64> >::t()((&__u),(sizeof(__u))));
}
}
;
template<typename __xcodeml_template_type_0_0>class __scalar_hash<__xcodeml_template_type_0_0,4>:public unary_function<__xcodeml_template_type_0_0,unsigned long>{public:unsigned long operator()(__xcodeml_template_type_0_0 __v)const{union __xcodeml_16{public:__xcodeml_template_type_0_0 __t;
public:class __xcodeml_17{public:unsigned long __a;
public:unsigned long __b;
public:unsigned long __c;
public:unsigned long __d;
}
;
public:class __xcodeml_16::__xcodeml_17 __s;
}
;union __xcodeml_16 __u;
(__u.__t=__v);
return(__xcodeml_identity<class::std::__1::__murmur2_or_cityhash<unsigned long,64> >::t()((&__u),(sizeof(__u))));
}
}
;
class _PairT{public:unsigned long first;
public:unsigned long second;
}
;
unsigned long __hash_combine(unsigned long __lhs,unsigned long __rhs){typedef class::std::__1::__scalar_hash<class::std::__1::_PairT,2>_HashT;
class _PairT const __p={__lhs,__rhs};
return __xcodeml_identity<class::std::__1::__scalar_hash<class::std::__1::_PairT,2> >::t().operator()(__xcodeml_identity<class::std::__1::_PairT>::t(__p));
}
template<typename __xcodeml_template_type_0_0>class hash<__xcodeml_template_type_0_0(*)>:public unary_function<__xcodeml_template_type_0_0(*),unsigned long>{public:unsigned long operator()(__xcodeml_template_type_0_0(*__v))const{union __xcodeml_18{public:__xcodeml_template_type_0_0(*__t);
public:unsigned long __a;
}
;union __xcodeml_18 __u;
(__u.__t=__v);
return(__xcodeml_identity<class::std::__1::__murmur2_or_cityhash<unsigned long,64> >::t()((&__u),(sizeof(__u))));
}
}
;
template<>class hash<bool>:public unary_function<bool,unsigned long>{public:unsigned long operator()(bool __v)const{return static_cast<unsigned long>(__v);
}
}
;
template<>class hash<char>:public unary_function<char,unsigned long>{public:unsigned long operator()(char __v)const{return static_cast<unsigned long>(__v);
}
}
;
template<>class hash<signed char>:public unary_function<signed char,unsigned long>{public:unsigned long operator()(signed char __v)const{return static_cast<unsigned long>(__v);
}
}
;
template<>class hash<unsigned char>:public unary_function<unsigned char,unsigned long>{public:unsigned long operator()(unsigned char __v)const{return static_cast<unsigned long>(__v);
}
}
;
template<>class hash<char16_t>:public unary_function<char16_t,unsigned long>{public:unsigned long operator()(char16_t __v)const{return static_cast<unsigned long>(__v);
}
}
;
template<>class hash<char32_t>:public unary_function<char32_t,unsigned long>{public:unsigned long operator()(char32_t __v)const{return static_cast<unsigned long>(__v);
}
}
;
template<>class hash<wchar_t>:public unary_function<wchar_t,unsigned long>{public:unsigned long operator()(wchar_t __v)const{return static_cast<unsigned long>(__v);
}
}
;
template<>class hash<short>:public unary_function<short,unsigned long>{public:unsigned long operator()(short __v)const{return static_cast<unsigned long>(__v);
}
}
;
template<>class hash<unsigned short>:public unary_function<unsigned short,unsigned long>{public:unsigned long operator()(unsigned short __v)const{return static_cast<unsigned long>(__v);
}
}
;
template<>class hash<int>:public unary_function<int,unsigned long>{public:unsigned long operator()(int __v)const{return static_cast<unsigned long>(__v);
}
}
;
template<>class hash<unsigned int>:public unary_function<unsigned int,unsigned long>{public:unsigned long operator()(unsigned int __v)const{return static_cast<unsigned long>(__v);
}
}
;
template<>class hash<long>:public unary_function<long,unsigned long>{public:unsigned long operator()(long __v)const{return static_cast<unsigned long>(__v);
}
}
;
template<>class hash<unsigned long>:public unary_function<unsigned long,unsigned long>{public:unsigned long operator()(unsigned long __v)const{return static_cast<unsigned long>(__v);
}
}
;
template<>class hash<long long>:public __scalar_hash<long long,1>{}
;
template<>class hash<unsigned long long>:public __scalar_hash<unsigned long long,1>{}
;
template<>class hash<__int128>:public __scalar_hash<__int128,2>{}
;
template<>class hash<unsigned __int128>:public __scalar_hash<unsigned __int128,2>{}
;
template<>class hash<float>:public __scalar_hash<float,0>{public:unsigned long operator()(float __v)const{if((__v==0.0f)){return 0;};
return(this->__scalar_hash::operator()(__v));
}
}
;
template<>class hash<double>:public __scalar_hash<double,1>{public:unsigned long operator()(double __v)const{if((__v==0.0)){return 0;};
return(this->__scalar_hash::operator()(__v));
}
}
;
template<>class hash<long double>:public __scalar_hash<long double,2>{public:unsigned long operator()(long double __v)const{if((__v==0.0L)){return 0;};
union __xcodeml_19{public:long double __t;
public:class __xcodeml_20{public:unsigned long __a;
public:unsigned long __b;
}
;
public:class __xcodeml_19::__xcodeml_20 __s;
}
;union __xcodeml_19 __u;
(__u.__s.__a=0);
(__u.__s.__b=0);
(__u.__t=__v);
return(__u.__s.__a^__u.__s.__b);
}
}
;
template<typename __xcodeml_template_type_0_0,bool=is_enum<__xcodeml_template_type_0_0>::value>class __enum_hash:public unary_function<__xcodeml_template_type_0_0,unsigned long>{public:unsigned long operator()(__xcodeml_template_type_0_0 __v)const{typedef typename underlying_type<__xcodeml_template_type_0_0>::type type;
return(__xcodeml_identity<hash<typename underlying_type<__xcodeml_template_type_0_0>::type> >::t({})(static_cast<typename underlying_type<__xcodeml_template_type_0_0>::type>(__v)));
}
}
;
;
template<typename __xcodeml_template_type_0_0>class __enum_hash<__xcodeml_template_type_0_0,0>{public:__enum_hash();
public:__enum_hash(class __enum_hash const&);
public:class __enum_hash<__xcodeml_template_type_0_0,0>&operator=(class __enum_hash const&);
}
;
template<typename __xcodeml_template_type_0_0>class hash:public __enum_hash<__xcodeml_template_type_0_0,expression>{}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>using __check_hash_requirements=integral_constant<bool,expression>;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>using __has_enabled_hash=integral_constant<bool,expression>;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>using __enable_hash_helper=__xcodeml_template_type_0_0;
}
}
class __xcodeml_21{public:int quot;
public:int rem;
}
;
typedef class::__xcodeml_21 div_t;
class __xcodeml_22{public:long quot;
public:long rem;
}
;
typedef class::__xcodeml_22 ldiv_t;
extern int __mb_cur_max;
extern"C"{int ___mb_cur_max();};
extern"C"{void abort();};
extern"C"{int abs(int);};
extern"C"{int atexit(void(*)());};
extern"C"{double atof(char const(*));};
extern"C"{int atoi(char const(*));};
extern"C"{long atol(char const(*));};
extern"C"{void(*bsearch(void const(*),void const(*),unsigned long,unsigned long,int(*)(void const(*),void const(*))));};
extern"C"{void(*calloc(unsigned long,unsigned long));};
extern"C"{class::__xcodeml_21 div(int,int);};
extern"C"{void exit(int);};
extern"C"{void free(void(*));};
extern"C"{char(*getenv(char const(*)));};
extern"C"{long labs(long);};
extern"C"{class::__xcodeml_22 ldiv(long,long);};
extern"C"{void(*malloc(unsigned long));};
extern"C"{int mblen(char const(*),unsigned long);};
extern"C"{unsigned long mbstowcs(wchar_t(*),char const(*),unsigned long);};
extern"C"{int mbtowc(wchar_t(*),char const(*),unsigned long);};
extern"C"{void qsort(void(*),unsigned long,unsigned long,int(*)(void const(*),void const(*)));};
extern"C"{int rand();};
extern"C"{void(*realloc(void(*),unsigned long));};
extern"C"{void srand(unsigned int);};
extern"C"{double strtod(char const(*),char(*(*)));};
extern"C"{float strtof(char const(*),char(*(*)));};
extern"C"{long strtol(char const(*),char(*(*)),int);};
extern"C"{long double strtold(char const(*),char(*(*)));};
extern"C"{unsigned long strtoul(char const(*),char(*(*)),int);};
extern"C"{int system(char const(*));};
extern"C"{int wctomb(char(*),wchar_t);};
extern"C"{unsigned long wcstombs(char(*),wchar_t const(*),unsigned long);};
class __xcodeml_23{public:long long quot;
public:long long rem;
}
;
typedef class __xcodeml_23 lldiv_t;
extern"C"{long long atoll(char const(*));};
extern"C"{long long llabs(long long);};
extern"C"{class __xcodeml_23 lldiv(long long,long long);};
extern"C"{long long strtoll(char const(*),char(*(*)),int);};
extern"C"{unsigned long long strtoull(char const(*),char(*(*)),int);};
extern"C"{void _Exit(int);};
extern"C"{void(*aligned_alloc(unsigned long,unsigned long));};
extern"C"{int at_quick_exit(void(*)());};
extern"C"{void quick_exit(int);};
extern"C"{char(*realpath(char const(*),char(*)));};
extern"C"{int rand_r(unsigned int(*));};
extern"C"{int posix_memalign(void(*(*)),unsigned long,unsigned long);};
extern"C"{int setenv(char const(*),char const(*),int);};
extern"C"{int unsetenv(char const(*));};
extern"C"{int getsubopt(char(*(*)),char(*const(*)),char(*(*)));};
extern"C"{char(*mkdtemp(char(*)));};
extern"C"{int mkstemp(char(*));};
extern"C"{long a64l(char const(*));};
extern"C"{double drand48();};
extern"C"{double erand48(unsigned short(*));};
extern"C"{int grantpt(int);};
extern"C"{char(*initstate(unsigned int,char(*),unsigned long));};
extern"C"{long jrand48(unsigned short(*));};
extern"C"{char(*l64a(long));};
extern"C"{void lcong48(unsigned short(*));};
extern"C"{long lrand48();};
extern"C"{char(*mktemp(char(*)));};
extern"C"{long mrand48();};
extern"C"{long nrand48(unsigned short(*));};
extern"C"{int posix_openpt(int);};
extern"C"{char(*ptsname(int));};
extern"C"{int putenv(char(*));};
extern"C"{long random();};
extern"C"{unsigned short(*seed48(unsigned short(*)));};
extern"C"{char(*setstate(char(*)));};
extern"C"{void srand48(long);};
extern"C"{void srandom(unsigned int);};
extern"C"{int unlockpt(int);};
extern char const(*malloc_conf);
extern void(*malloc_message)(void(*),char const(*));
extern"C"{void abort2(char const(*),int,void(*(*)));};
extern"C"{unsigned int arc4random();};
extern"C"{void arc4random_buf(void(*),unsigned long);};
extern"C"{unsigned int arc4random_uniform(unsigned int);};
extern"C"{char(*getbsize(int(*),long(*)));};
extern"C"{char(*cgetcap(char(*),char const(*),int));};
extern"C"{int cgetclose();};
extern"C"{int cgetent(char(*(*)),char(*(*)),char const(*));};
extern"C"{int cgetfirst(char(*(*)),char(*(*)));};
extern"C"{int cgetmatch(char const(*),char const(*));};
extern"C"{int cgetnext(char(*(*)),char(*(*)));};
extern"C"{int cgetnum(char(*),char const(*),long(*));};
extern"C"{int cgetset(char const(*));};
extern"C"{int cgetstr(char(*),char const(*),char(*(*)));};
extern"C"{int cgetustr(char(*),char const(*),char(*(*)));};
extern"C"{int daemon(int,int);};
extern"C"{int daemonfd(int,int);};
extern"C"{char(*devname(unsigned long,unsigned short));};
extern"C"{char(*devname_r(unsigned long,unsigned short,char(*),int));};
extern"C"{char(*fdevname(int));};
extern"C"{char(*fdevname_r(int,char(*),int));};
extern"C"{int getloadavg(double(*),int);};
extern"C"{char const(*getprogname());};
extern"C"{int heapsort(void(*),unsigned long,unsigned long,int(*)(void const(*),void const(*)));};
extern"C"{int l64a_r(long,char(*),int);};
extern"C"{int mergesort(void(*),unsigned long,unsigned long,int(*)(void const(*),void const(*)));};
extern"C"{int mkostemp(char(*),int);};
extern"C"{int mkostemps(char(*),int,int);};
extern"C"{int mkostempsat(int,char(*),int,int);};
extern"C"{void qsort_r(void(*),unsigned long,unsigned long,void(*),int(*)(void(*),void const(*),void const(*)));};
extern"C"{int radixsort(unsigned char const(*(*)),int,unsigned char const(*),unsigned int);};
extern"C"{void(*reallocarray(void(*),unsigned long,unsigned long));};
extern"C"{void(*reallocf(void(*),unsigned long));};
extern"C"{int rpmatch(char const(*));};
extern"C"{void setprogname(char const(*));};
extern"C"{int sradixsort(unsigned char const(*(*)),int,unsigned char const(*),unsigned int);};
extern"C"{void srandomdev();};
extern"C"{long long strtonum(char const(*),long long,long long,char const(*(*)));};
extern"C"{long strtoq(char const(*),char(*(*)),int);};
extern"C"{unsigned long strtouq(char const(*),char(*(*)),int);};
extern char(*suboptarg);
typedef void(*constraint_handler_t)(char const(*),void(*),int);
extern"C"{void(*set_constraint_handler_s(void(*handler)(char const(*),void(*),int)))(char const(*),void(*),int);};
extern"C"{void abort_handler_s(char const(*),void(*),int);};
extern"C"{void ignore_handler_s(char const(*),void(*),int);};
extern"C"{int qsort_s(void(*),unsigned long,unsigned long,int(*)(void const(*),void const(*),void(*)),void(*));};

union __infinity_un{public:unsigned char __uc[8];
public:double __ud;
}
;
extern union __infinity_un const __infinity;
union __nan_un{public:unsigned char __uc[4];
public:float __uf;
}
;
extern union __nan_un const __nan;
typedef double double_t;
typedef float float_t;
extern int signgam;
extern"C"{int __fpclassifyd(double);};
extern"C"{int __fpclassifyf(float);};
extern"C"{int __fpclassifyl(long double);};
extern"C"{int __isfinitef(float);};
extern"C"{int __isfinite(double);};
extern"C"{int __isfinitel(long double);};
extern"C"{int __isinff(float);};
extern"C"{int __isinf(double);};
extern"C"{int __isinfl(long double);};
extern"C"{int __isnormalf(float);};
extern"C"{int __isnormal(double);};
extern"C"{int __isnormall(long double);};
extern"C"{int __signbit(double);};
extern"C"{int __signbitf(float);};
extern"C"{int __signbitl(long double);};
int __inline_isnan(double __x){return(__x!=__x);
}
int __inline_isnanf(float __x){return(__x!=__x);
}
int __inline_isnanl(long double __x){return(__x!=__x);
}
extern"C"{double acos(double);};
extern"C"{double asin(double);};
extern"C"{double atan(double);};
extern"C"{double atan2(double,double);};
extern"C"{double cos(double);};
extern"C"{double sin(double);};
extern"C"{double tan(double);};
extern"C"{double cosh(double);};
extern"C"{double sinh(double);};
extern"C"{double tanh(double);};
extern"C"{double exp(double);};
extern"C"{double frexp(double,int(*));};
extern"C"{double ldexp(double,int);};
extern"C"{double log(double);};
extern"C"{double log10(double);};
extern"C"{double modf(double,double(*));};
extern"C"{double pow(double,double);};
extern"C"{double sqrt(double);};
extern"C"{double ceil(double);};
extern"C"{double fabs(double);};
extern"C"{double floor(double);};
extern"C"{double fmod(double,double);};
extern"C"{double acosh(double);};
extern"C"{double asinh(double);};
extern"C"{double atanh(double);};
extern"C"{double cbrt(double);};
extern"C"{double erf(double);};
extern"C"{double erfc(double);};
extern"C"{double exp2(double);};
extern"C"{double expm1(double);};
extern"C"{double fma(double,double,double);};
extern"C"{double hypot(double,double);};
extern"C"{int ilogb(double);};
extern"C"{double lgamma(double);};
extern"C"{long long llrint(double);};
extern"C"{long long llround(double);};
extern"C"{double log1p(double);};
extern"C"{double log2(double);};
extern"C"{double logb(double);};
extern"C"{long lrint(double);};
extern"C"{long lround(double);};
extern"C"{double nan(char const(*));};
extern"C"{double nextafter(double,double);};
extern"C"{double remainder(double,double);};
extern"C"{double remquo(double,double,int(*));};
extern"C"{double rint(double);};
extern"C"{double j0(double);};
extern"C"{double j1(double);};
extern"C"{double jn(int,double);};
extern"C"{double y0(double);};
extern"C"{double y1(double);};
extern"C"{double yn(int,double);};
extern"C"{double gamma(double);};
extern"C"{double scalb(double,double);};
extern"C"{double copysign(double,double);};
extern"C"{double fdim(double,double);};
extern"C"{double fmax(double,double);};
extern"C"{double fmin(double,double);};
extern"C"{double nearbyint(double);};
extern"C"{double round(double);};
extern"C"{double scalbln(double,long);};
extern"C"{double scalbn(double,int);};
extern"C"{double tgamma(double);};
extern"C"{double trunc(double);};
extern"C"{double drem(double,double);};
extern"C"{int finite(double);};
extern"C"{int isnanf(float);};
extern"C"{double gamma_r(double,int(*));};
extern"C"{double lgamma_r(double,int(*));};
extern"C"{double significand(double);};
extern"C"{float acosf(float);};
extern"C"{float asinf(float);};
extern"C"{float atanf(float);};
extern"C"{float atan2f(float,float);};
extern"C"{float cosf(float);};
extern"C"{float sinf(float);};
extern"C"{float tanf(float);};
extern"C"{float coshf(float);};
extern"C"{float sinhf(float);};
extern"C"{float tanhf(float);};
extern"C"{float exp2f(float);};
extern"C"{float expf(float);};
extern"C"{float expm1f(float);};
extern"C"{float frexpf(float,int(*));};
extern"C"{int ilogbf(float);};
extern"C"{float ldexpf(float,int);};
extern"C"{float log10f(float);};
extern"C"{float log1pf(float);};
extern"C"{float log2f(float);};
extern"C"{float logf(float);};
extern"C"{float modff(float,float(*));};
extern"C"{float powf(float,float);};
extern"C"{float sqrtf(float);};
extern"C"{float ceilf(float);};
extern"C"{float fabsf(float);};
extern"C"{float floorf(float);};
extern"C"{float fmodf(float,float);};
extern"C"{float roundf(float);};
extern"C"{float erff(float);};
extern"C"{float erfcf(float);};
extern"C"{float hypotf(float,float);};
extern"C"{float lgammaf(float);};
extern"C"{float tgammaf(float);};
extern"C"{float acoshf(float);};
extern"C"{float asinhf(float);};
extern"C"{float atanhf(float);};
extern"C"{float cbrtf(float);};
extern"C"{float logbf(float);};
extern"C"{float copysignf(float,float);};
extern"C"{long long llrintf(float);};
extern"C"{long long llroundf(float);};
extern"C"{long lrintf(float);};
extern"C"{long lroundf(float);};
extern"C"{float nanf(char const(*));};
extern"C"{float nearbyintf(float);};
extern"C"{float nextafterf(float,float);};
extern"C"{float remainderf(float,float);};
extern"C"{float remquof(float,float,int(*));};
extern"C"{float rintf(float);};
extern"C"{float scalblnf(float,long);};
extern"C"{float scalbnf(float,int);};
extern"C"{float truncf(float);};
extern"C"{float fdimf(float,float);};
extern"C"{float fmaf(float,float,float);};
extern"C"{float fmaxf(float,float);};
extern"C"{float fminf(float,float);};
extern"C"{float dremf(float,float);};
extern"C"{int finitef(float);};
extern"C"{float gammaf(float);};
extern"C"{float j0f(float);};
extern"C"{float j1f(float);};
extern"C"{float jnf(int,float);};
extern"C"{float scalbf(float,float);};
extern"C"{float y0f(float);};
extern"C"{float y1f(float);};
extern"C"{float ynf(int,float);};
extern"C"{float gammaf_r(float,int(*));};
extern"C"{float lgammaf_r(float,int(*));};
extern"C"{float significandf(float);};
extern"C"{long double acoshl(long double);};
extern"C"{long double acosl(long double);};
extern"C"{long double asinhl(long double);};
extern"C"{long double asinl(long double);};
extern"C"{long double atan2l(long double,long double);};
extern"C"{long double atanhl(long double);};
extern"C"{long double atanl(long double);};
extern"C"{long double cbrtl(long double);};
extern"C"{long double ceill(long double);};
extern"C"{long double copysignl(long double,long double);};
extern"C"{long double coshl(long double);};
extern"C"{long double cosl(long double);};
extern"C"{long double erfcl(long double);};
extern"C"{long double erfl(long double);};
extern"C"{long double exp2l(long double);};
extern"C"{long double expl(long double);};
extern"C"{long double expm1l(long double);};
extern"C"{long double fabsl(long double);};
extern"C"{long double fdiml(long double,long double);};
extern"C"{long double floorl(long double);};
extern"C"{long double fmal(long double,long double,long double);};
extern"C"{long double fmaxl(long double,long double);};
extern"C"{long double fminl(long double,long double);};
extern"C"{long double fmodl(long double,long double);};
extern"C"{long double frexpl(long double,int(*));};
extern"C"{long double hypotl(long double,long double);};
extern"C"{int ilogbl(long double);};
extern"C"{long double ldexpl(long double,int);};
extern"C"{long double lgammal(long double);};
extern"C"{long long llrintl(long double);};
extern"C"{long long llroundl(long double);};
extern"C"{long double log10l(long double);};
extern"C"{long double log1pl(long double);};
extern"C"{long double log2l(long double);};
extern"C"{long double logbl(long double);};
extern"C"{long double logl(long double);};
extern"C"{long lrintl(long double);};
extern"C"{long lroundl(long double);};
extern"C"{long double modfl(long double,long double(*));};
extern"C"{long double nanl(char const(*));};
extern"C"{long double nearbyintl(long double);};
extern"C"{long double nextafterl(long double,long double);};
extern"C"{double nexttoward(double,long double);};
extern"C"{float nexttowardf(float,long double);};
extern"C"{long double nexttowardl(long double,long double);};
extern"C"{long double powl(long double,long double);};
extern"C"{long double remainderl(long double,long double);};
extern"C"{long double remquol(long double,long double,int(*));};
extern"C"{long double rintl(long double);};
extern"C"{long double roundl(long double);};
extern"C"{long double scalblnl(long double,long);};
extern"C"{long double scalbnl(long double,int);};
extern"C"{long double sinhl(long double);};
extern"C"{long double sinl(long double);};
extern"C"{long double sqrtl(long double);};
extern"C"{long double tanhl(long double);};
extern"C"{long double tanl(long double);};
extern"C"{long double tgammal(long double);};
extern"C"{long double truncl(long double);};
extern"C"{long double lgammal_r(long double,int(*));};
extern"C"{void sincos(double,double(*),double(*));};
extern"C"{void sincosf(float,float(*),float(*));};
extern"C"{void sincosl(long double,long double(*),long double(*));};

template<typename __xcodeml_template_type_0_0>bool __libcpp_signbit(__xcodeml_template_type_0_0 __lcpp_x){return __lcpp_x float((__lcpp_x))double((__lcpp_x))long double((__lcpp_x))float((__lcpp_x))double((__lcpp_x))long double((__lcpp_x))float((__lcpp_x))double((__lcpp_x))long double((__lcpp_x))float((__lcpp_x))double((__lcpp_x))long double((__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,bool>::type signbit(__xcodeml_template_type_0_0 __lcpp_x){return((((typename __promote<__xcodeml_template_type_0_0,void,void>::type)__lcpp_x)));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,bool>::type signbit(__xcodeml_template_type_0_0 __lcpp_x){return(__lcpp_x<0);
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,bool>::type signbit(__xcodeml_template_type_0_0){return false;
}
template<typename __xcodeml_template_type_0_0>int __libcpp_fpclassify(__xcodeml_template_type_0_0 __lcpp_x){return __lcpp_x float((__lcpp_x))double((__lcpp_x))long double((__lcpp_x))float((__lcpp_x))double((__lcpp_x))long double((__lcpp_x))float((__lcpp_x))double((__lcpp_x))long double((__lcpp_x))float((__lcpp_x))double((__lcpp_x))long double((__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,int>::type fpclassify(__xcodeml_template_type_0_0 __lcpp_x){return((((typename __promote<__xcodeml_template_type_0_0,void,void>::type)__lcpp_x)));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,int>::type fpclassify(__xcodeml_template_type_0_0 __lcpp_x){return((__lcpp_x==0)?0x10:0x04);
}
template<typename __xcodeml_template_type_0_0>bool __libcpp_isfinite(__xcodeml_template_type_0_0 __lcpp_x){return __lcpp_x float((__lcpp_x))double((__lcpp_x))long double((__lcpp_x))float((__lcpp_x))double((__lcpp_x))long double((__lcpp_x))float((__lcpp_x))double((__lcpp_x))long double((__lcpp_x))float((__lcpp_x))double((__lcpp_x))long double((__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,bool>::type isfinite(__xcodeml_template_type_0_0 __lcpp_x){return((((typename __promote<__xcodeml_template_type_0_0,void,void>::type)__lcpp_x)));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,bool>::type isfinite(__xcodeml_template_type_0_0){return true;
}
template<typename __xcodeml_template_type_0_0>bool __libcpp_isinf(__xcodeml_template_type_0_0 __lcpp_x){return __lcpp_x float((__lcpp_x))double((__lcpp_x))long double((__lcpp_x))float((__lcpp_x))double((__lcpp_x))long double((__lcpp_x))float((__lcpp_x))double((__lcpp_x))long double((__lcpp_x))float((__lcpp_x))double((__lcpp_x))long double((__lcpp_x));
}
template <>bool __libcpp_isinf(float __lcpp_x){return __lcpp_x float(__isinff(__lcpp_x))double(__isinf(__lcpp_x))long double(__isinfl(__lcpp_x))float(__isinff(__lcpp_x))double(__isinf(__lcpp_x))long double(__isinfl(__lcpp_x))float(__isinff(__lcpp_x))double(__isinf(__lcpp_x))long double(__isinfl(__lcpp_x))float(__isinff(__lcpp_x))double(__isinf(__lcpp_x))long double(__isinfl(__lcpp_x));
}
template <>bool __libcpp_isinf(double __lcpp_x){return __lcpp_x float(__isinff(__lcpp_x))double(__isinf(__lcpp_x))long double(__isinfl(__lcpp_x))float(__isinff(__lcpp_x))double(__isinf(__lcpp_x))long double(__isinfl(__lcpp_x))float(__isinff(__lcpp_x))double(__isinf(__lcpp_x))long double(__isinfl(__lcpp_x))float(__isinff(__lcpp_x))double(__isinf(__lcpp_x))long double(__isinfl(__lcpp_x));
}
template <>bool __libcpp_isinf(long double __lcpp_x){return __lcpp_x float(__isinff(__lcpp_x))double(__isinf(__lcpp_x))long double(__isinfl(__lcpp_x))float(__isinff(__lcpp_x))double(__isinf(__lcpp_x))long double(__isinfl(__lcpp_x))float(__isinff(__lcpp_x))double(__isinf(__lcpp_x))long double(__isinfl(__lcpp_x))float(__isinff(__lcpp_x))double(__isinf(__lcpp_x))long double(__isinfl(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,bool>::type isinf(__xcodeml_template_type_0_0 __lcpp_x){return((((typename __promote<__xcodeml_template_type_0_0,void,void>::type)__lcpp_x)));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,bool>::type isinf(__xcodeml_template_type_0_0){return false;
}
bool isinf(float __lcpp_x){return(__libcpp_isinf(__lcpp_x));
}
bool isinf(double __lcpp_x){return(__libcpp_isinf(__lcpp_x));
}
bool isinf(long double __lcpp_x){return(__libcpp_isinf(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>bool __libcpp_isnan(__xcodeml_template_type_0_0 __lcpp_x){return __lcpp_x float((__lcpp_x))double((__lcpp_x))long double((__lcpp_x))float((__lcpp_x))double((__lcpp_x))long double((__lcpp_x))float((__lcpp_x))double((__lcpp_x))long double((__lcpp_x))float((__lcpp_x))double((__lcpp_x))long double((__lcpp_x));
}
template <>bool __libcpp_isnan(float __lcpp_x){return __lcpp_x float(__inline_isnanf(__lcpp_x))double(__inline_isnan(__lcpp_x))long double(__inline_isnanl(__lcpp_x))float(__inline_isnanf(__lcpp_x))double(__inline_isnan(__lcpp_x))long double(__inline_isnanl(__lcpp_x))float(__inline_isnanf(__lcpp_x))double(__inline_isnan(__lcpp_x))long double(__inline_isnanl(__lcpp_x))float(__inline_isnanf(__lcpp_x))double(__inline_isnan(__lcpp_x))long double(__inline_isnanl(__lcpp_x));
}
template <>bool __libcpp_isnan(double __lcpp_x){return __lcpp_x float(__inline_isnanf(__lcpp_x))double(__inline_isnan(__lcpp_x))long double(__inline_isnanl(__lcpp_x))float(__inline_isnanf(__lcpp_x))double(__inline_isnan(__lcpp_x))long double(__inline_isnanl(__lcpp_x))float(__inline_isnanf(__lcpp_x))double(__inline_isnan(__lcpp_x))long double(__inline_isnanl(__lcpp_x))float(__inline_isnanf(__lcpp_x))double(__inline_isnan(__lcpp_x))long double(__inline_isnanl(__lcpp_x));
}
template <>bool __libcpp_isnan(long double __lcpp_x){return __lcpp_x float(__inline_isnanf(__lcpp_x))double(__inline_isnan(__lcpp_x))long double(__inline_isnanl(__lcpp_x))float(__inline_isnanf(__lcpp_x))double(__inline_isnan(__lcpp_x))long double(__inline_isnanl(__lcpp_x))float(__inline_isnanf(__lcpp_x))double(__inline_isnan(__lcpp_x))long double(__inline_isnanl(__lcpp_x))float(__inline_isnanf(__lcpp_x))double(__inline_isnan(__lcpp_x))long double(__inline_isnanl(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,bool>::type isnan(__xcodeml_template_type_0_0 __lcpp_x){return((((typename __promote<__xcodeml_template_type_0_0,void,void>::type)__lcpp_x)));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,bool>::type isnan(__xcodeml_template_type_0_0){return false;
}
bool isnan(float __lcpp_x){return(__libcpp_isnan(__lcpp_x));
}
bool isnan(double __lcpp_x){return(__libcpp_isnan(__lcpp_x));
}
bool isnan(long double __lcpp_x){return(__libcpp_isnan(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>bool __libcpp_isnormal(__xcodeml_template_type_0_0 __lcpp_x){return __lcpp_x float((__lcpp_x))double((__lcpp_x))long double((__lcpp_x))float((__lcpp_x))double((__lcpp_x))long double((__lcpp_x))float((__lcpp_x))double((__lcpp_x))long double((__lcpp_x))float((__lcpp_x))double((__lcpp_x))long double((__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,bool>::type isnormal(__xcodeml_template_type_0_0 __lcpp_x){return((((typename __promote<__xcodeml_template_type_0_0,void,void>::type)__lcpp_x)));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,bool>::type isnormal(__xcodeml_template_type_0_0 __lcpp_x){return(__lcpp_x!=0);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool __libcpp_isgreater(__xcodeml_template_type_0_0 __lcpp_x,__xcodeml_template_type_0_1 __lcpp_y){return(__builtin_isgreater(__lcpp_x,__lcpp_y));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename enable_if<expression,bool>::type isgreater(__xcodeml_template_type_0_0 __lcpp_x,__xcodeml_template_type_0_1 __lcpp_y){typedef typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type type;
return((((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_x),((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_y)));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool __libcpp_isgreaterequal(__xcodeml_template_type_0_0 __lcpp_x,__xcodeml_template_type_0_1 __lcpp_y){return(__builtin_isgreaterequal(__lcpp_x,__lcpp_y));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename enable_if<expression,bool>::type isgreaterequal(__xcodeml_template_type_0_0 __lcpp_x,__xcodeml_template_type_0_1 __lcpp_y){typedef typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type type;
return((((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_x),((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_y)));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool __libcpp_isless(__xcodeml_template_type_0_0 __lcpp_x,__xcodeml_template_type_0_1 __lcpp_y){return(__builtin_isless(__lcpp_x,__lcpp_y));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename enable_if<expression,bool>::type isless(__xcodeml_template_type_0_0 __lcpp_x,__xcodeml_template_type_0_1 __lcpp_y){typedef typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type type;
return((((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_x),((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_y)));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool __libcpp_islessequal(__xcodeml_template_type_0_0 __lcpp_x,__xcodeml_template_type_0_1 __lcpp_y){return(__builtin_islessequal(__lcpp_x,__lcpp_y));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename enable_if<expression,bool>::type islessequal(__xcodeml_template_type_0_0 __lcpp_x,__xcodeml_template_type_0_1 __lcpp_y){typedef typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type type;
return((((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_x),((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_y)));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool __libcpp_islessgreater(__xcodeml_template_type_0_0 __lcpp_x,__xcodeml_template_type_0_1 __lcpp_y){return(__builtin_islessgreater(__lcpp_x,__lcpp_y));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename enable_if<expression,bool>::type islessgreater(__xcodeml_template_type_0_0 __lcpp_x,__xcodeml_template_type_0_1 __lcpp_y){typedef typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type type;
return((((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_x),((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_y)));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool __libcpp_isunordered(__xcodeml_template_type_0_0 __lcpp_x,__xcodeml_template_type_0_1 __lcpp_y){return(__builtin_isunordered(__lcpp_x,__lcpp_y));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename enable_if<expression,bool>::type isunordered(__xcodeml_template_type_0_0 __lcpp_x,__xcodeml_template_type_0_1 __lcpp_y){typedef typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type type;
return((((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_x),((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_y)));
}
long abs(long __x){return(::labs(__x));
}
long long abs(long long __x){return(::llabs(__x));
}
float abs(float __lcpp_x){return(::fabsf(__lcpp_x));
}
double abs(double __lcpp_x){return(::fabs(__lcpp_x));
}
long double abs(long double __lcpp_x){return(::fabsl(__lcpp_x));
}
class::__xcodeml_22 div(long __x,long __y){return(::ldiv(__x,__y));
}
class __xcodeml_23 div(long long __x,long long __y){return(::lldiv(__x,__y));
}
float acos(float __lcpp_x){return(::acosf(__lcpp_x));
}
long double acos(long double __lcpp_x){return(::acosl(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type acos(__xcodeml_template_type_0_0 __lcpp_x){return(::acos(((double)__lcpp_x)));
}
float asin(float __lcpp_x){return(::asinf(__lcpp_x));
}
long double asin(long double __lcpp_x){return(::asinl(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type asin(__xcodeml_template_type_0_0 __lcpp_x){return(::asin(((double)__lcpp_x)));
}
float atan(float __lcpp_x){return(::atanf(__lcpp_x));
}
long double atan(long double __lcpp_x){return(::atanl(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type atan(__xcodeml_template_type_0_0 __lcpp_x){return(::atan(((double)__lcpp_x)));
}
float atan2(float __lcpp_y,float __lcpp_x){return(::atan2f(__lcpp_y,__lcpp_x));
}
long double atan2(long double __lcpp_y,long double __lcpp_x){return(::atan2l(__lcpp_y,__lcpp_x));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename void/**/::type atan2(__xcodeml_template_type_0_0 __lcpp_y,__xcodeml_template_type_0_1 __lcpp_x){typedef typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type __result_type;
(!(std::integral_constant<bool,expression>::value&&std::integral_constant<bool,expression>::value))"";
return(::(((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_y),((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_x)));
}
float ceil(float __lcpp_x){return(::ceilf(__lcpp_x));
}
long double ceil(long double __lcpp_x){return(::ceill(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type ceil(__xcodeml_template_type_0_0 __lcpp_x){return(::ceil(((double)__lcpp_x)));
}
float cos(float __lcpp_x){return(::cosf(__lcpp_x));
}
long double cos(long double __lcpp_x){return(::cosl(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type cos(__xcodeml_template_type_0_0 __lcpp_x){return(::cos(((double)__lcpp_x)));
}
float cosh(float __lcpp_x){return(::coshf(__lcpp_x));
}
long double cosh(long double __lcpp_x){return(::coshl(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type cosh(__xcodeml_template_type_0_0 __lcpp_x){return(::cosh(((double)__lcpp_x)));
}
float exp(float __lcpp_x){return(::expf(__lcpp_x));
}
long double exp(long double __lcpp_x){return(::expl(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type exp(__xcodeml_template_type_0_0 __lcpp_x){return(::exp(((double)__lcpp_x)));
}
float fabs(float __lcpp_x){return(::fabsf(__lcpp_x));
}
long double fabs(long double __lcpp_x){return(::fabsl(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type fabs(__xcodeml_template_type_0_0 __lcpp_x){return(::fabs(((double)__lcpp_x)));
}
float floor(float __lcpp_x){return(::floorf(__lcpp_x));
}
long double floor(long double __lcpp_x){return(::floorl(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type floor(__xcodeml_template_type_0_0 __lcpp_x){return(::floor(((double)__lcpp_x)));
}
float fmod(float __lcpp_x,float __lcpp_y){return(::fmodf(__lcpp_x,__lcpp_y));
}
long double fmod(long double __lcpp_x,long double __lcpp_y){return(::fmodl(__lcpp_x,__lcpp_y));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename void/**/::type fmod(__xcodeml_template_type_0_0 __lcpp_x,__xcodeml_template_type_0_1 __lcpp_y){typedef typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type __result_type;
(!(std::integral_constant<bool,expression>::value&&std::integral_constant<bool,expression>::value))"";
return(::(((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_x),((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_y)));
}
float frexp(float __lcpp_x,int(*__lcpp_e)){return(::frexpf(__lcpp_x,__lcpp_e));
}
long double frexp(long double __lcpp_x,int(*__lcpp_e)){return(::frexpl(__lcpp_x,__lcpp_e));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type frexp(__xcodeml_template_type_0_0 __lcpp_x,int(*__lcpp_e)){return(::frexp(((double)__lcpp_x),__lcpp_e));
}
float ldexp(float __lcpp_x,int __lcpp_e){return(::ldexpf(__lcpp_x,__lcpp_e));
}
long double ldexp(long double __lcpp_x,int __lcpp_e){return(::ldexpl(__lcpp_x,__lcpp_e));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type ldexp(__xcodeml_template_type_0_0 __lcpp_x,int __lcpp_e){return(::ldexp(((double)__lcpp_x),__lcpp_e));
}
float log(float __lcpp_x){return(::logf(__lcpp_x));
}
long double log(long double __lcpp_x){return(::logl(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type log(__xcodeml_template_type_0_0 __lcpp_x){return(::log(((double)__lcpp_x)));
}
float log10(float __lcpp_x){return(::log10f(__lcpp_x));
}
long double log10(long double __lcpp_x){return(::log10l(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type log10(__xcodeml_template_type_0_0 __lcpp_x){return(::log10(((double)__lcpp_x)));
}
float modf(float __lcpp_x,float(*__lcpp_y)){return(::modff(__lcpp_x,__lcpp_y));
}
long double modf(long double __lcpp_x,long double(*__lcpp_y)){return(::modfl(__lcpp_x,__lcpp_y));
}
float pow(float __lcpp_x,float __lcpp_y){return(::powf(__lcpp_x,__lcpp_y));
}
long double pow(long double __lcpp_x,long double __lcpp_y){return(::powl(__lcpp_x,__lcpp_y));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename void/**/::type pow(__xcodeml_template_type_0_0 __lcpp_x,__xcodeml_template_type_0_1 __lcpp_y){typedef typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type __result_type;
(!(std::integral_constant<bool,expression>::value&&std::integral_constant<bool,expression>::value))"";
return(::(((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_x),((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_y)));
}
float sin(float __lcpp_x){return(::sinf(__lcpp_x));
}
long double sin(long double __lcpp_x){return(::sinl(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type sin(__xcodeml_template_type_0_0 __lcpp_x){return(::sin(((double)__lcpp_x)));
}
float sinh(float __lcpp_x){return(::sinhf(__lcpp_x));
}
long double sinh(long double __lcpp_x){return(::sinhl(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type sinh(__xcodeml_template_type_0_0 __lcpp_x){return(::sinh(((double)__lcpp_x)));
}
float sqrt(float __lcpp_x){return(::sqrtf(__lcpp_x));
}
long double sqrt(long double __lcpp_x){return(::sqrtl(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type sqrt(__xcodeml_template_type_0_0 __lcpp_x){return(::sqrt(((double)__lcpp_x)));
}
float tan(float __lcpp_x){return(::tanf(__lcpp_x));
}
long double tan(long double __lcpp_x){return(::tanl(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type tan(__xcodeml_template_type_0_0 __lcpp_x){return(::tan(((double)__lcpp_x)));
}
float tanh(float __lcpp_x){return(::tanhf(__lcpp_x));
}
long double tanh(long double __lcpp_x){return(::tanhl(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type tanh(__xcodeml_template_type_0_0 __lcpp_x){return(::tanh(((double)__lcpp_x)));
}
float acosh(float __lcpp_x){return(::acoshf(__lcpp_x));
}
long double acosh(long double __lcpp_x){return(::acoshl(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type acosh(__xcodeml_template_type_0_0 __lcpp_x){return(::acosh(((double)__lcpp_x)));
}
float asinh(float __lcpp_x){return(::asinhf(__lcpp_x));
}
long double asinh(long double __lcpp_x){return(::asinhl(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type asinh(__xcodeml_template_type_0_0 __lcpp_x){return(::asinh(((double)__lcpp_x)));
}
float atanh(float __lcpp_x){return(::atanhf(__lcpp_x));
}
long double atanh(long double __lcpp_x){return(::atanhl(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type atanh(__xcodeml_template_type_0_0 __lcpp_x){return(::atanh(((double)__lcpp_x)));
}
float cbrt(float __lcpp_x){return(::cbrtf(__lcpp_x));
}
long double cbrt(long double __lcpp_x){return(::cbrtl(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type cbrt(__xcodeml_template_type_0_0 __lcpp_x){return(::cbrt(((double)__lcpp_x)));
}
float copysign(float __lcpp_x,float __lcpp_y){return(::copysignf(__lcpp_x,__lcpp_y));
}
long double copysign(long double __lcpp_x,long double __lcpp_y){return(::copysignl(__lcpp_x,__lcpp_y));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename void/**/::type copysign(__xcodeml_template_type_0_0 __lcpp_x,__xcodeml_template_type_0_1 __lcpp_y){typedef typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type __result_type;
(!(std::integral_constant<bool,expression>::value&&std::integral_constant<bool,expression>::value))"";
return(::(((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_x),((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_y)));
}
float erf(float __lcpp_x){return(::erff(__lcpp_x));
}
long double erf(long double __lcpp_x){return(::erfl(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type erf(__xcodeml_template_type_0_0 __lcpp_x){return(::erf(((double)__lcpp_x)));
}
float erfc(float __lcpp_x){return(::erfcf(__lcpp_x));
}
long double erfc(long double __lcpp_x){return(::erfcl(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type erfc(__xcodeml_template_type_0_0 __lcpp_x){return(::erfc(((double)__lcpp_x)));
}
float exp2(float __lcpp_x){return(::exp2f(__lcpp_x));
}
long double exp2(long double __lcpp_x){return(::exp2l(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type exp2(__xcodeml_template_type_0_0 __lcpp_x){return(::exp2(((double)__lcpp_x)));
}
float expm1(float __lcpp_x){return(::expm1f(__lcpp_x));
}
long double expm1(long double __lcpp_x){return(::expm1l(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type expm1(__xcodeml_template_type_0_0 __lcpp_x){return(::expm1(((double)__lcpp_x)));
}
float fdim(float __lcpp_x,float __lcpp_y){return(::fdimf(__lcpp_x,__lcpp_y));
}
long double fdim(long double __lcpp_x,long double __lcpp_y){return(::fdiml(__lcpp_x,__lcpp_y));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename void/**/::type fdim(__xcodeml_template_type_0_0 __lcpp_x,__xcodeml_template_type_0_1 __lcpp_y){typedef typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type __result_type;
(!(std::integral_constant<bool,expression>::value&&std::integral_constant<bool,expression>::value))"";
return(::(((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_x),((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_y)));
}
float fma(float __lcpp_x,float __lcpp_y,float __lcpp_z){return(::fmaf(__lcpp_x,__lcpp_y,__lcpp_z));
}
long double fma(long double __lcpp_x,long double __lcpp_y,long double __lcpp_z){return(::fmal(__lcpp_x,__lcpp_y,__lcpp_z));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>typename void/**/::type fma(__xcodeml_template_type_0_0 __lcpp_x,__xcodeml_template_type_0_1 __lcpp_y,__xcodeml_template_type_0_2 __lcpp_z){typedef typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2>::type __result_type;
(!((std::integral_constant<bool,expression>::value&&std::integral_constant<bool,expression>::value)&&std::integral_constant<bool,expression>::value))"";
return(::(((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2>::type)__lcpp_x),((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2>::type)__lcpp_y),((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2>::type)__lcpp_z)));
}
float fmax(float __lcpp_x,float __lcpp_y){return(::fmaxf(__lcpp_x,__lcpp_y));
}
long double fmax(long double __lcpp_x,long double __lcpp_y){return(::fmaxl(__lcpp_x,__lcpp_y));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename void/**/::type fmax(__xcodeml_template_type_0_0 __lcpp_x,__xcodeml_template_type_0_1 __lcpp_y){typedef typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type __result_type;
(!(std::integral_constant<bool,expression>::value&&std::integral_constant<bool,expression>::value))"";
return(::(((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_x),((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_y)));
}
float fmin(float __lcpp_x,float __lcpp_y){return(::fminf(__lcpp_x,__lcpp_y));
}
long double fmin(long double __lcpp_x,long double __lcpp_y){return(::fminl(__lcpp_x,__lcpp_y));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename void/**/::type fmin(__xcodeml_template_type_0_0 __lcpp_x,__xcodeml_template_type_0_1 __lcpp_y){typedef typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type __result_type;
(!(std::integral_constant<bool,expression>::value&&std::integral_constant<bool,expression>::value))"";
return(::(((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_x),((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_y)));
}
float hypot(float __lcpp_x,float __lcpp_y){return(::hypotf(__lcpp_x,__lcpp_y));
}
long double hypot(long double __lcpp_x,long double __lcpp_y){return(::hypotl(__lcpp_x,__lcpp_y));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename void/**/::type hypot(__xcodeml_template_type_0_0 __lcpp_x,__xcodeml_template_type_0_1 __lcpp_y){typedef typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type __result_type;
(!(std::integral_constant<bool,expression>::value&&std::integral_constant<bool,expression>::value))"";
return(::(((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_x),((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_y)));
}
int ilogb(float __lcpp_x){return(::ilogbf(__lcpp_x));
}
int ilogb(long double __lcpp_x){return(::ilogbl(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,int>::type ilogb(__xcodeml_template_type_0_0 __lcpp_x){return(::ilogb(((double)__lcpp_x)));
}
float lgamma(float __lcpp_x){return(::lgammaf(__lcpp_x));
}
long double lgamma(long double __lcpp_x){return(::lgammal(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type lgamma(__xcodeml_template_type_0_0 __lcpp_x){return(::lgamma(((double)__lcpp_x)));
}
long long llrint(float __lcpp_x){return(::llrintf(__lcpp_x));
}
long long llrint(long double __lcpp_x){return(::llrintl(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,long long>::type llrint(__xcodeml_template_type_0_0 __lcpp_x){return(::llrint(((double)__lcpp_x)));
}
long long llround(float __lcpp_x){return(::llroundf(__lcpp_x));
}
long long llround(long double __lcpp_x){return(::llroundl(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,long long>::type llround(__xcodeml_template_type_0_0 __lcpp_x){return(::llround(((double)__lcpp_x)));
}
float log1p(float __lcpp_x){return(::log1pf(__lcpp_x));
}
long double log1p(long double __lcpp_x){return(::log1pl(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type log1p(__xcodeml_template_type_0_0 __lcpp_x){return(::log1p(((double)__lcpp_x)));
}
float log2(float __lcpp_x){return(::log2f(__lcpp_x));
}
long double log2(long double __lcpp_x){return(::log2l(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type log2(__xcodeml_template_type_0_0 __lcpp_x){return(::log2(((double)__lcpp_x)));
}
float logb(float __lcpp_x){return(::logbf(__lcpp_x));
}
long double logb(long double __lcpp_x){return(::logbl(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type logb(__xcodeml_template_type_0_0 __lcpp_x){return(::logb(((double)__lcpp_x)));
}
long lrint(float __lcpp_x){return(::lrintf(__lcpp_x));
}
long lrint(long double __lcpp_x){return(::lrintl(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,long>::type lrint(__xcodeml_template_type_0_0 __lcpp_x){return(::lrint(((double)__lcpp_x)));
}
long lround(float __lcpp_x){return(::lroundf(__lcpp_x));
}
long lround(long double __lcpp_x){return(::lroundl(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,long>::type lround(__xcodeml_template_type_0_0 __lcpp_x){return(::lround(((double)__lcpp_x)));
}
float nearbyint(float __lcpp_x){return(::nearbyintf(__lcpp_x));
}
long double nearbyint(long double __lcpp_x){return(::nearbyintl(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type nearbyint(__xcodeml_template_type_0_0 __lcpp_x){return(::nearbyint(((double)__lcpp_x)));
}
float nextafter(float __lcpp_x,float __lcpp_y){return(::nextafterf(__lcpp_x,__lcpp_y));
}
long double nextafter(long double __lcpp_x,long double __lcpp_y){return(::nextafterl(__lcpp_x,__lcpp_y));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename void/**/::type nextafter(__xcodeml_template_type_0_0 __lcpp_x,__xcodeml_template_type_0_1 __lcpp_y){typedef typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type __result_type;
(!(std::integral_constant<bool,expression>::value&&std::integral_constant<bool,expression>::value))"";
return(::(((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_x),((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_y)));
}
float nexttoward(float __lcpp_x,long double __lcpp_y){return(::nexttowardf(__lcpp_x,__lcpp_y));
}
long double nexttoward(long double __lcpp_x,long double __lcpp_y){return(::nexttowardl(__lcpp_x,__lcpp_y));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type nexttoward(__xcodeml_template_type_0_0 __lcpp_x,long double __lcpp_y){return(::nexttoward(((double)__lcpp_x),__lcpp_y));
}
float remainder(float __lcpp_x,float __lcpp_y){return(::remainderf(__lcpp_x,__lcpp_y));
}
long double remainder(long double __lcpp_x,long double __lcpp_y){return(::remainderl(__lcpp_x,__lcpp_y));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename void/**/::type remainder(__xcodeml_template_type_0_0 __lcpp_x,__xcodeml_template_type_0_1 __lcpp_y){typedef typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type __result_type;
(!(std::integral_constant<bool,expression>::value&&std::integral_constant<bool,expression>::value))"";
return(::(((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_x),((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_y)));
}
float remquo(float __lcpp_x,float __lcpp_y,int(*__lcpp_z)){return(::remquof(__lcpp_x,__lcpp_y,__lcpp_z));
}
long double remquo(long double __lcpp_x,long double __lcpp_y,int(*__lcpp_z)){return(::remquol(__lcpp_x,__lcpp_y,__lcpp_z));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename void/**/::type remquo(__xcodeml_template_type_0_0 __lcpp_x,__xcodeml_template_type_0_1 __lcpp_y,int(*__lcpp_z)){typedef typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type __result_type;
(!(std::integral_constant<bool,expression>::value&&std::integral_constant<bool,expression>::value))"";
return(::(((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_x),((typename __promote<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,void>::type)__lcpp_y),__lcpp_z));
}
float rint(float __lcpp_x){return(::rintf(__lcpp_x));
}
long double rint(long double __lcpp_x){return(::rintl(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type rint(__xcodeml_template_type_0_0 __lcpp_x){return(::rint(((double)__lcpp_x)));
}
float round(float __lcpp_x){return(::roundf(__lcpp_x));
}
long double round(long double __lcpp_x){return(::roundl(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type round(__xcodeml_template_type_0_0 __lcpp_x){return(::round(((double)__lcpp_x)));
}
float scalbln(float __lcpp_x,long __lcpp_y){return(::scalblnf(__lcpp_x,__lcpp_y));
}
long double scalbln(long double __lcpp_x,long __lcpp_y){return(::scalblnl(__lcpp_x,__lcpp_y));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type scalbln(__xcodeml_template_type_0_0 __lcpp_x,long __lcpp_y){return(::scalbln(((double)__lcpp_x),__lcpp_y));
}
float scalbn(float __lcpp_x,int __lcpp_y){return(::scalbnf(__lcpp_x,__lcpp_y));
}
long double scalbn(long double __lcpp_x,int __lcpp_y){return(::scalbnl(__lcpp_x,__lcpp_y));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type scalbn(__xcodeml_template_type_0_0 __lcpp_x,int __lcpp_y){return(::scalbn(((double)__lcpp_x),__lcpp_y));
}
float tgamma(float __lcpp_x){return(::tgammaf(__lcpp_x));
}
long double tgamma(long double __lcpp_x){return(::tgammal(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type tgamma(__xcodeml_template_type_0_0 __lcpp_x){return(::tgamma(((double)__lcpp_x)));
}
float trunc(float __lcpp_x){return(::truncf(__lcpp_x));
}
long double trunc(long double __lcpp_x){return(::truncl(__lcpp_x));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,double>::type trunc(__xcodeml_template_type_0_0 __lcpp_x){return(::trunc(((double)__lcpp_x)));
}

namespace std{namespace __1{::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
::;
}
}
namespace std{class exception{public:
public:exception(){}
public:virtual~exception();
public:virtual char const(*what()const);
}
;
class bad_exception:public exception{public:
public:bad_exception():exception(){}
public:virtual~bad_exception();
public:virtual char const(*what()const);
}
;
typedef void(*unexpected_handler)();
void(*set_unexpected(void(*)()))();
void(*get_unexpected())();
void unexpected();
typedef void(*terminate_handler)();
void(*set_terminate(void(*)()))();
void(*get_terminate())();
void terminate();
bool uncaught_exception();
int uncaught_exceptions();
class exception_ptr;
class::std::exception_ptr current_exception();
void rethrow_exception(class::std::exception_ptr);
class exception_ptr{private:void(*__ptr_);
public:
public:exception_ptr():__ptr_(){}
public:exception_ptr(nullptr_t):__ptr_(){}
public:exception_ptr(class exception_ptr const&);
public:class::std::exception_ptr&operator=(class exception_ptr const&);
public:~exception_ptr();
public:operator bool()const{return(this->__ptr_!=nullptr);
}
public:friend bool operator==(class exception_ptr const&__x,class exception_ptr const&__y){return(__x.__ptr_==__y.__ptr_);
};
public:friend bool operator!=(class exception_ptr const&__x,class exception_ptr const&__y){return(!operator==(__x,__y));
};
public:friend class::std::exception_ptr current_exception();
public:friend void rethrow_exception(class::std::exception_ptr);
}
;
template<typename __xcodeml_template_type_0_0>class::std::exception_ptr make_exception_ptr(__xcodeml_template_type_0_0 __e){try{throw __e;
}catch(...){return(current_exception());
}
;
}
class nested_exception{private:class::std::exception_ptr __ptr_;
public:
public:nested_exception();
public:virtual~nested_exception();
public:void rethrow_nested()const;
public:class::std::exception_ptr nested_ptr()const{return __xcodeml_identity<class::std::exception_ptr>::t(this->__ptr_);
}
}
;
template<typename __xcodeml_template_type_0_0>class __nested:public __xcodeml_template_type_0_0,public nested_exception{public:__nested(__xcodeml_template_type_0_0 const&__t):(__t){}
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,bool>class __throw_with_nested;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __throw_with_nested<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,1>{public:static void __do_throw(__xcodeml_template_type_0_0(*__t)){throw __xcodeml_identity<__nested<__xcodeml_template_type_0_1> >::t((std::__1::__xcodeml_template_type_0_0(__t)));
}
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __throw_with_nested<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,0>{public:static void __do_throw(__xcodeml_template_type_0_0(*__t)){throw(std::__1::__xcodeml_template_type_0_0(__t));
}
}
;
template<typename __xcodeml_template_type_0_0>void throw_with_nested(__xcodeml_template_type_0_0(*__t)){typedef typename decay<__xcodeml_template_type_0_0>::type _Up;
is_copy_constructible<typename decay<__xcodeml_template_type_0_0>::type>::value"type thrown must be CopyConstructible";
(__throw_with_nested<__xcodeml_template_type_0_0,typename decay<__xcodeml_template_type_0_0>::type,expression>::__do_throw((std::__1::__xcodeml_template_type_0_0(__t))));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __can_dynamic_cast:public integral_constant<bool,expression>{}
;
;
template<typename __xcodeml_template_type_0_0>void rethrow_if_nested(__xcodeml_template_type_0_0 const&__e,typename enable_if<expression,void>::type(*)){class nested_exception const(*__nep)=dynamic_cast<class nested_exception const(*)>((std::__1::(__e)));
if(__nep){(__nep->rethrow_nested());};
}
template<typename __xcodeml_template_type_0_0>void rethrow_if_nested(__xcodeml_template_type_0_0 const&,typename enable_if<expression,void>::type(*)){}
}
namespace std{class __type_info_implementations{public:class __string_impl_base{public:typedef char const(*__type_name_t);
public:static char const(*__type_name_to_string(char const(*__v))){return __v;
}
public:static char const(*__string_to_type_name(char const(*__v))){return __v;
}
}
;
public:class __unique_impl:public __string_impl_base{public:static unsigned long __hash(char const(*__v)){return reinterpret_cast<unsigned long>(__v);
}
public:static bool __eq(char const(*__lhs),char const(*__rhs)){return(__lhs==__rhs);
}
public:static bool __lt(char const(*__lhs),char const(*__rhs)){return(__lhs<__rhs);
}
}
;
public:class __non_unique_impl:public __string_impl_base{public:static unsigned long __hash(char const(*__ptr)){unsigned long __hash=5381;
while(unsigned char __c=static_cast<unsigned char>((*(__ptr++)))){__c;};
return __hash;
}
public:static bool __eq(char const(*__lhs),char const(*__rhs)){return((__lhs==__rhs)||((__builtin_strcmp(__lhs,__rhs))==0));
}
public:static bool __lt(char const(*__lhs),char const(*__rhs)){return((__builtin_strcmp(__lhs,__rhs))<0);
}
}
;
public:class __non_unique_arm_rtti_bit_impl{public:typedef unsigned long __type_name_t;
public:static char const(*__type_name_to_string(unsigned long __v)){return reinterpret_cast<char const(*)>((__v&(~integral_constant::value)));
}
public:static unsigned long __string_to_type_name(char const(*__v)){return reinterpret_cast<unsigned long>(__v);
}
public:static unsigned long __hash(unsigned long __v){if((__is_type_name_unique(__v))){return reinterpret_cast<unsigned long>(__v);};
return(__non_unique_impl::__hash((__type_name_to_string(__v))));
}
public:static bool __eq(unsigned long __lhs,unsigned long __rhs){if((__lhs==__rhs)){return true;};
if((__is_type_name_unique(__lhs,__rhs))){return false;};
return((__builtin_strcmp((__type_name_to_string(__lhs)),(__type_name_to_string(__rhs))))==0);
}
public:static bool __lt(unsigned long __lhs,unsigned long __rhs){if((__is_type_name_unique(__lhs,__rhs))){return(__lhs<__rhs);};
return((__builtin_strcmp((__type_name_to_string(__lhs)),(__type_name_to_string(__rhs))))<0);
}
private:
private:typedef class::std::__1::integral_constant<unsigned long,9223372036854775808>__non_unique_rtti_bit;
private:static bool __is_type_name_unique(unsigned long __lhs){return(!(__lhs&integral_constant::value));
}
private:static bool __is_type_name_unique(unsigned long __lhs,unsigned long __rhs){return(!((__lhs&__rhs)&integral_constant::value));
}
}
;
public:typedef class::std::__type_info_implementations::__unique_impl __impl;
}
;
class type_info{private:class::std::type_info&operator=(class type_info const&);
private:type_info(class type_info const&);
protected:
protected:typedef class::std::__type_info_implementations::__unique_impl __impl;
protected:char const(*__type_name);
protected:type_info(char const(*__n)):__type_name((__unique_impl::__string_to_type_name(__n))){}
public:
public:virtual~type_info();
public:char const(*name()const){return(__unique_impl::__type_name_to_string(this->__type_name));
}
public:bool before(class type_info const&__arg)const{return(__unique_impl::__lt(this->__type_name,__arg.__type_name));
}
public:unsigned long hash_code()const{return(__unique_impl::__hash(this->__type_name));
}
public:bool operator==(class type_info const&__arg)const{return(__unique_impl::__eq(this->__type_name,__arg.__type_name));
}
public:bool operator!=(class type_info const&__arg)const{return(!(this->operator==(__arg)));
}
}
;
class bad_cast:public exception{public:
public:bad_cast();
public:virtual~bad_cast();
public:virtual char const(*what()const);
}
;
class bad_typeid:public exception{public:
public:bad_typeid();
public:virtual~bad_typeid();
public:virtual char const(*what()const);
}
;
}
namespace std{namespace __1{void __throw_bad_cast(){throw __xcodeml_identity<class::std::bad_cast>::t();
}
}
}
namespace std{class nothrow_t{}
;
extern class nothrow_t const nothrow;
class bad_alloc:public exception{public:
public:bad_alloc();
public:virtual~bad_alloc();
public:virtual char const(*what()const);
}
;
class bad_array_new_length:public bad_alloc{public:
public:bad_array_new_length();
public:virtual~bad_array_new_length();
public:virtual char const(*what()const);
}
;
typedef void(*new_handler)();
void(*set_new_handler(void(*)()))();
void(*get_new_handler())();
void __throw_bad_alloc();
enum align_val_t{};
}
void(*operator new(unsigned long __sz));
void(*operator new(unsigned long __sz,class nothrow_t const&));
void operator delete(void(*__p));
void operator delete(void(*__p),class nothrow_t const&);
void operator delete(void(*__p),unsigned long __sz);
void(*operator new[](unsigned long __sz));
void(*operator new[](unsigned long __sz,class nothrow_t const&));
void operator delete[](void(*__p));
void operator delete[](void(*__p),class nothrow_t const&);
void operator delete[](void(*__p),unsigned long __sz);
void(*operator new(unsigned long __sz,enum align_val_t));
void(*operator new(unsigned long __sz,enum align_val_t,class nothrow_t const&));
void operator delete(void(*__p),enum align_val_t);
void operator delete(void(*__p),enum align_val_t,class nothrow_t const&);
void operator delete(void(*__p),unsigned long __sz,enum align_val_t);
void(*operator new[](unsigned long __sz,enum align_val_t));
void(*operator new[](unsigned long __sz,enum align_val_t,class nothrow_t const&));
void operator delete[](void(*__p),enum align_val_t);
void operator delete[](void(*__p),enum align_val_t,class nothrow_t const&);
void operator delete[](void(*__p),unsigned long __sz,enum align_val_t);
void(*operator new(unsigned long,void(*__p))){return __p;
}
void(*operator new[](unsigned long,void(*__p))){return __p;
}
void operator delete(void(*),void(*)){}
void operator delete[](void(*),void(*)){}
namespace std{namespace __1{bool __is_overaligned_for_new(unsigned long __align){return(__align>16UL);
}
void(*__libcpp_allocate(unsigned long __size,unsigned long __align)){((void)__align);
return(__builtin_operator_new(__size));
}
class _DeallocateCaller{public:static void __do_deallocate_handle_size_align(void(*__ptr),unsigned long __size,unsigned long __align){((void)__align);
return(__do_deallocate_handle_size(__ptr,__size));
}
public:static void __do_deallocate_handle_align(void(*__ptr),unsigned long __align){((void)__align);
return(__do_call(__ptr));
}
private:
private:static void __do_deallocate_handle_size(void(*__ptr),unsigned long __size){((void)__size);
return(__do_call(__ptr));
}
private:
private:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>static void __do_call(void(*__ptr),__xcodeml_template_type_0_0 __a1,__xcodeml_template_type_0_1 __a2){return(__builtin_operator_delete(__ptr,__a1,__a2));
}
private:template<typename __xcodeml_template_type_0_0>static void __do_call(void(*__ptr),__xcodeml_template_type_0_0 __a1){return(__builtin_operator_delete(__ptr,__a1));
}
private:static void __do_call(void(*__ptr)){return(__builtin_operator_delete(__ptr));
}
}
;
void __libcpp_deallocate(void(*__ptr),unsigned long __size,unsigned long __align){(_DeallocateCaller::__do_deallocate_handle_size_align(__ptr,__size,__align));
}
void __libcpp_deallocate_unsized(void(*__ptr),unsigned long __align){(_DeallocateCaller::__do_deallocate_handle_align(__ptr,__align));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0(*__launder(__xcodeml_template_type_0_0(*__p))){(!is_function<__xcodeml_template_type_0_0>::value)"can't launder functions";
(!is_same<void,typename remove_cv<__xcodeml_template_type_0_0>::type>::value)"can't launder cv-void";
return(__builtin_launder(__p));
}
}
}
namespace std{namespace __1{template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class binary_function{public:typedef __xcodeml_template_type_0_0 first_argument_type;
public:typedef __xcodeml_template_type_0_1 second_argument_type;
public:typedef __xcodeml_template_type_0_2 result_type;
}
;
;
template<typename __xcodeml_template_type_0_0>class __has_result_type{private:
private:class __two{public:char __lx;
public:char __lxx;
}
;
private:template<typename __xcodeml_template_type_1_0>static class::std::__1::__has_result_type::__two __test(...)
private:template<typename __xcodeml_template_type_1_0>static char __test(typename __xcodeml_template_type_1_0::result_type(*))
public:
public:static bool const value=((sizeof((__xcodeml_template_type_0_0(0))))==1);
}
;
;
template<typename __xcodeml_template_type_0_0>class less:public binary_function<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0,bool>{public:bool operator()(__xcodeml_template_type_0_0 const&__x,__xcodeml_template_type_0_0 const&__y)const{return(__x,__y);
}
}
;
;
template<>class less<void>{public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>decltype (operator()(__xcodeml_template_type_0_0(*__t),__xcodeml_template_type_0_1(*__u))const){return((std::__1::__xcodeml_template_type_0_0(__t)),(std::__1::__xcodeml_template_type_0_1(__u)));
}
public:typedef void is_transparent;
}
;
template<typename __xcodeml_template_type_0_0>class __derives_from_unary_function{private:
private:class __two{public:char __lx;
public:char __lxx;
}
;
private:static class::std::__1::__derives_from_unary_function::__two __test(...);
private:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>static unary_function<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1>
public:
public:static bool const value=(!is_same<decltype (),class::std::__1::__derives_from_unary_function::__two>::value);
public:typedef decltype (type);
}
;
;
template<typename __xcodeml_template_type_0_0>class __derives_from_binary_function{private:
private:class __two{public:char __lx;
public:char __lxx;
}
;
private:static class::std::__1::__derives_from_binary_function::__two __test(...);
private:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1,typename __xcodeml_template_type_1_2>static binary_function<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1,__xcodeml_template_type_1_2>
public:
public:static bool const value=(!is_same<decltype (),class::std::__1::__derives_from_binary_function::__two>::value);
public:typedef decltype (type);
}
;
;
template<typename __xcodeml_template_type_0_0,bool=__derives_from_unary_function<__xcodeml_template_type_0_0>::value>class __maybe_derive_from_unary_function:public/**/{}
;
;
template<typename __xcodeml_template_type_0_0>class __maybe_derive_from_unary_function<__xcodeml_template_type_0_0,0>{}
;
template<typename __xcodeml_template_type_0_0,bool=__derives_from_binary_function<__xcodeml_template_type_0_0>::value>class __maybe_derive_from_binary_function:public/**/{}
;
;
template<typename __xcodeml_template_type_0_0>class __maybe_derive_from_binary_function<__xcodeml_template_type_0_0,0>{}
;
template<typename __xcodeml_template_type_0_0,bool=__has_result_type<__xcodeml_template_type_0_0>::value>class __weak_result_type_imp:public __maybe_derive_from_unary_function<__xcodeml_template_type_0_0,expression>,public __maybe_derive_from_binary_function<__xcodeml_template_type_0_0,expression>{public:typedef typename __xcodeml_template_type_0_0::result_type result_type;
}
;
;
template<typename __xcodeml_template_type_0_0>class __weak_result_type_imp<__xcodeml_template_type_0_0,0>:public __maybe_derive_from_unary_function<__xcodeml_template_type_0_0,expression>,public __maybe_derive_from_binary_function<__xcodeml_template_type_0_0,expression>{}
;
template<typename __xcodeml_template_type_0_0>class __weak_result_type:public __weak_result_type_imp<__xcodeml_template_type_0_0,expression>{}
;
;
template<typename __xcodeml_template_type_0_0>class __weak_result_type<__xcodeml_template_type_0_0()>{public:typedef __xcodeml_template_type_0_0 result_type;
}
;
template<typename __xcodeml_template_type_0_0>class __weak_result_type<__xcodeml_template_type_0_0&()>{public:typedef __xcodeml_template_type_0_0 result_type;
}
;
template<typename __xcodeml_template_type_0_0>class __weak_result_type<__xcodeml_template_type_0_0(*)()>{public:typedef __xcodeml_template_type_0_0 result_type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __weak_result_type<__xcodeml_template_type_0_0(__xcodeml_template_type_0_1)>:public unary_function<__xcodeml_template_type_0_1,__xcodeml_template_type_0_0>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __weak_result_type<__xcodeml_template_type_0_0&(__xcodeml_template_type_0_1)>:public unary_function<__xcodeml_template_type_0_1,__xcodeml_template_type_0_0>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __weak_result_type<__xcodeml_template_type_0_0(*)(__xcodeml_template_type_0_1)>:public unary_function<__xcodeml_template_type_0_1,__xcodeml_template_type_0_0>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __weak_result_type<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)()>:public unary_function<__xcodeml_template_type_0_1(*),__xcodeml_template_type_0_0>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __weak_result_type<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)()const>:public unary_function<__xcodeml_template_type_0_1 const(*),__xcodeml_template_type_0_0>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __weak_result_type<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)()volatile>:public unary_function<__xcodeml_template_type_0_1 volatile(*),__xcodeml_template_type_0_0>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __weak_result_type<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)()const volatile>:public unary_function<__xcodeml_template_type_0_1 volatile const(*),__xcodeml_template_type_0_0>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __weak_result_type<__xcodeml_template_type_0_0(__xcodeml_template_type_0_1,__xcodeml_template_type_0_2)>:public binary_function<__xcodeml_template_type_0_1,__xcodeml_template_type_0_2,__xcodeml_template_type_0_0>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __weak_result_type<__xcodeml_template_type_0_0(*)(__xcodeml_template_type_0_1,__xcodeml_template_type_0_2)>:public binary_function<__xcodeml_template_type_0_1,__xcodeml_template_type_0_2,__xcodeml_template_type_0_0>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __weak_result_type<__xcodeml_template_type_0_0&(__xcodeml_template_type_0_1,__xcodeml_template_type_0_2)>:public binary_function<__xcodeml_template_type_0_1,__xcodeml_template_type_0_2,__xcodeml_template_type_0_0>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __weak_result_type<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)(__xcodeml_template_type_0_2)>:public binary_function<__xcodeml_template_type_0_1(*),__xcodeml_template_type_0_2,__xcodeml_template_type_0_0>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __weak_result_type<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)(__xcodeml_template_type_0_2)const>:public binary_function<__xcodeml_template_type_0_1 const(*),__xcodeml_template_type_0_2,__xcodeml_template_type_0_0>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __weak_result_type<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)(__xcodeml_template_type_0_2)volatile>:public binary_function<__xcodeml_template_type_0_1 volatile(*),__xcodeml_template_type_0_2,__xcodeml_template_type_0_0>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __weak_result_type<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)(__xcodeml_template_type_0_2)const volatile>:public binary_function<__xcodeml_template_type_0_1 volatile const(*),__xcodeml_template_type_0_2,__xcodeml_template_type_0_0>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3,typename __xcodeml_template_type_0_4>class __weak_result_type<__xcodeml_template_type_0_0(__xcodeml_template_type_0_1,__xcodeml_template_type_0_2,__xcodeml_template_type_0_3,void/**/)>{public:typedef __xcodeml_template_type_0_0 result_type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3,typename __xcodeml_template_type_0_4>class __weak_result_type<__xcodeml_template_type_0_0&(__xcodeml_template_type_0_1,__xcodeml_template_type_0_2,__xcodeml_template_type_0_3,void/**/)>{public:typedef __xcodeml_template_type_0_0 result_type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3,typename __xcodeml_template_type_0_4>class __weak_result_type<__xcodeml_template_type_0_0(*)(__xcodeml_template_type_0_1,__xcodeml_template_type_0_2,__xcodeml_template_type_0_3,void/**/)>{public:typedef __xcodeml_template_type_0_0 result_type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3,typename __xcodeml_template_type_0_4>class __weak_result_type<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)(__xcodeml_template_type_0_2,__xcodeml_template_type_0_3,void/**/)>{public:typedef __xcodeml_template_type_0_0 result_type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3,typename __xcodeml_template_type_0_4>class __weak_result_type<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)(__xcodeml_template_type_0_2,__xcodeml_template_type_0_3,void/**/)const>{public:typedef __xcodeml_template_type_0_0 result_type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3,typename __xcodeml_template_type_0_4>class __weak_result_type<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)(__xcodeml_template_type_0_2,__xcodeml_template_type_0_3,void/**/)volatile>{public:typedef __xcodeml_template_type_0_0 result_type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3,typename __xcodeml_template_type_0_4>class __weak_result_type<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)(__xcodeml_template_type_0_2,__xcodeml_template_type_0_3,void/**/)const volatile>{public:typedef __xcodeml_template_type_0_0 result_type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __invoke_return{public:typedef decltype (type);
}
;
;
template<typename __xcodeml_template_type_0_0>class __invoke_void_return_wrapper{public:template<typename __xcodeml_template_type_1_0>static __xcodeml_template_type_0_0 __call(void/*__args*/){return(((std::__1::__xcodeml_template_type_1_0(__args))));
}
}
;
;
template<>class __invoke_void_return_wrapper<void>{public:template<typename __xcodeml_template_type_0_0>static void __call(void/*__args*/){(((std::__1::__xcodeml_template_type_0_0(__args))));
}
}
;
template<typename __xcodeml_template_type_0_0>class reference_wrapper:public __weak_result_type<__xcodeml_template_type_0_0>{public:
public:typedef __xcodeml_template_type_0_0 type;
private:
private:__xcodeml_template_type_0_0(*__f_);
public:
public:reference_wrapper(__xcodeml_template_type_0_0&__f):__f_((std::__1::(__f))){}
private:
private:reference_wrapper(__xcodeml_template_type_0_0(*));
public:
public:operator __xcodeml_template_type_0_0&()const{return(*this->__f_);
}
public:__xcodeml_template_type_0_0&get()const{return(*this->__f_);
}
public:template<typename __xcodeml_template_type_1_0>typename __invoke_of<__xcodeml_template_type_0_0&,...>::type operator()(void/*__args*/)const{return(((this->get()),(std::__1::__xcodeml_template_type_1_0(__args))));
}
}
;
;
template<typename __xcodeml_template_type_0_0>reference_wrapper<__xcodeml_template_type_0_0>{return __xcodeml_identity<reference_wrapper<__xcodeml_template_type_0_0> >::t(__t);
}
template<typename __xcodeml_template_type_0_0>reference_wrapper<__xcodeml_template_type_0_0>{return(((__t.get())));
}
template<typename __xcodeml_template_type_0_0>reference_wrapper<__xcodeml_template_type_0_0 const>{return __xcodeml_identity<reference_wrapper<__xcodeml_template_type_0_0 const> >::t(__t);
}
template<typename __xcodeml_template_type_0_0>reference_wrapper<__xcodeml_template_type_0_0 const>{return(((__t.get())));
}
template<typename __xcodeml_template_type_0_0>void ref(__xcodeml_template_type_0_0 const(*))
template<typename __xcodeml_template_type_0_0>void cref(__xcodeml_template_type_0_0 const(*))
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __is_transparent:public integral_constant<bool,0>{}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __is_transparent<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,typename __void_t<typename __xcodeml_template_type_0_0::is_transparent>::type>:public integral_constant<bool,1>{}
;
class allocator_arg_t{}
;
constexpr class allocator_arg_t const allocator_arg=__xcodeml_identity<class::std::__1::allocator_arg_t>::t();
template<typename __xcodeml_template_type_0_0>class __has_allocator_type{private:
private:class __two{public:char __lx;
public:char __lxx;
}
;
private:template<typename __xcodeml_template_type_1_0>static class::std::__1::__has_allocator_type::__two __test(...)
private:template<typename __xcodeml_template_type_1_0>static char __test(typename __xcodeml_template_type_1_0::allocator_type(*))
public:
public:static bool const value=((sizeof((__xcodeml_template_type_0_0(0))))==1);
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,bool=__has_allocator_type<__xcodeml_template_type_0_0>::value>class __uses_allocator:public integral_constant<bool,expression>{}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __uses_allocator<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,0>:public integral_constant<bool,0>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class uses_allocator:public __uses_allocator<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,expression>{}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __uses_alloc_ctor_imp{public:typedef typename __uncvref<__xcodeml_template_type_0_1>::type _RawAlloc;
public:static bool const __ua=uses_allocator<__xcodeml_template_type_0_0,typename __uncvref<__xcodeml_template_type_0_1>::type>::value;
public:static bool const __ic=is_constructible<__xcodeml_template_type_0_0,...>::value;
public:static int const value=(__ua?(2-__ic):0);
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __uses_alloc_ctor:public integral_constant<int,expression>{}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>void __user_alloc_construct_impl(class::std::__1::integral_constant<int,0>,__xcodeml_template_type_0_0(*__storage),__xcodeml_template_type_0_1 const&,void/*__args*/){new(__storage)__xcodeml_identity<__xcodeml_template_type_0_0>::t((std::__1::__xcodeml_template_type_0_2(__args)));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>void __user_alloc_construct_impl(class::std::__1::integral_constant<int,1>,__xcodeml_template_type_0_0(*__storage),__xcodeml_template_type_0_1 const&__a,void/*__args*/){new(__storage)__xcodeml_identity<__xcodeml_template_type_0_0>::t(allocator_arg,__a,(std::__1::__xcodeml_template_type_0_2(__args)));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>void __user_alloc_construct_impl(class::std::__1::integral_constant<int,2>,__xcodeml_template_type_0_0(*__storage),__xcodeml_template_type_0_1 const&__a,void/*__args*/){new(__storage)__xcodeml_identity<__xcodeml_template_type_0_0>::t((std::__1::__xcodeml_template_type_0_2(__args)),__a);
}
}
}
namespace std{namespace __1{class input_iterator_tag{}
;
class output_iterator_tag{}
;
class forward_iterator_tag:public input_iterator_tag{}
;
class bidirectional_iterator_tag:public forward_iterator_tag{}
;
class random_access_iterator_tag:public bidirectional_iterator_tag{}
;
template<typename __xcodeml_template_type_0_0>class __has_iterator_typedefs{private:
private:class __two{public:char __lx;
public:char __lxx;
}
;
private:template<typename __xcodeml_template_type_1_0>static class::std::__1::__has_iterator_typedefs::__two __test(...)
private:template<typename __xcodeml_template_type_1_0>static char __test(typename __void_t<typename __xcodeml_template_type_1_0::iterator_category>::type(*),typename __void_t<typename __xcodeml_template_type_1_0::difference_type>::type(*),typename __void_t<typename __xcodeml_template_type_1_0::value_type>::type(*),typename __void_t<typename __xcodeml_template_type_1_0::reference>::type(*),typename __void_t<typename __xcodeml_template_type_1_0::pointer>::type(*))
public:
public:static bool const value=((sizeof((__xcodeml_template_type_0_0(0,0,0,0,0))))==1);
}
;
;
template<typename __xcodeml_template_type_0_0>class __has_iterator_category{private:
private:class __two{public:char __lx;
public:char __lxx;
}
;
private:template<typename __xcodeml_template_type_1_0>static class::std::__1::__has_iterator_category::__two __test(...)
private:template<typename __xcodeml_template_type_1_0>static char __test(typename __xcodeml_template_type_1_0::iterator_category(*))
public:
public:static bool const value=((sizeof((__xcodeml_template_type_0_0(0))))==1);
}
;
;
template<typename __xcodeml_template_type_0_0,bool>class __iterator_traits_impl{}
;
;
template<typename __xcodeml_template_type_0_0>class __iterator_traits_impl<__xcodeml_template_type_0_0,1>{public:typedef typename __xcodeml_template_type_0_0::difference_type difference_type;
public:typedef typename __xcodeml_template_type_0_0::value_type value_type;
public:typedef typename __xcodeml_template_type_0_0::pointer pointer;
public:typedef typename __xcodeml_template_type_0_0::reference reference;
public:typedef typename __xcodeml_template_type_0_0::iterator_category iterator_category;
}
;
template<typename __xcodeml_template_type_0_0,bool>class __iterator_traits{}
;
;
template<typename __xcodeml_template_type_0_0>class __iterator_traits<__xcodeml_template_type_0_0,1>:public __iterator_traits_impl<__xcodeml_template_type_0_0,expression>{}
;
template<typename __xcodeml_template_type_0_0>class iterator_traits:public __iterator_traits<__xcodeml_template_type_0_0,expression>{}
;
;
template<typename __xcodeml_template_type_0_0>class iterator_traits<__xcodeml_template_type_0_0(*)>{public:typedef long difference_type;
public:typedef typename remove_cv<__xcodeml_template_type_0_0>::type value_type;
public:typedef __xcodeml_template_type_0_0(*pointer);
public:typedef __xcodeml_template_type_0_0&reference;
public:typedef class::std::__1::random_access_iterator_tag iterator_category;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,bool=__has_iterator_category<iterator_traits<__xcodeml_template_type_0_0> >::value>class __has_iterator_category_convertible_to:public integral_constant<bool,expression>{}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __has_iterator_category_convertible_to<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,0>:public integral_constant<bool,0>{}
;
template<typename __xcodeml_template_type_0_0>class __is_input_iterator:public __has_iterator_category_convertible_to<__xcodeml_template_type_0_0,class::std::__1::input_iterator_tag,expression>{}
;
;
template<typename __xcodeml_template_type_0_0>class __is_forward_iterator:public __has_iterator_category_convertible_to<__xcodeml_template_type_0_0,class::std::__1::forward_iterator_tag,expression>{}
;
;
template<typename __xcodeml_template_type_0_0>class __is_bidirectional_iterator:public __has_iterator_category_convertible_to<__xcodeml_template_type_0_0,class::std::__1::bidirectional_iterator_tag,expression>{}
;
;
template<typename __xcodeml_template_type_0_0>class __is_random_access_iterator:public __has_iterator_category_convertible_to<__xcodeml_template_type_0_0,class::std::__1::random_access_iterator_tag,expression>{}
;
;
template<typename __xcodeml_template_type_0_0>class __is_exactly_input_iterator:public integral_constant<bool,expression>{}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3,typename __xcodeml_template_type_0_4>class iterator{public:typedef __xcodeml_template_type_0_1 value_type;
public:typedef __xcodeml_template_type_0_2 difference_type;
public:typedef __xcodeml_template_type_0_3 pointer;
public:typedef __xcodeml_template_type_0_4 reference;
public:typedef __xcodeml_template_type_0_0 iterator_category;
}
;
template<>class iterator<class::std::__1::output_iterator_tag,void,void,void,void>{public:typedef void value_type;
public:typedef void difference_type;
public:typedef void pointer;
public:typedef void reference;
public:typedef class::std::__1::output_iterator_tag iterator_category;
}
;
template<typename __xcodeml_template_type_0_0>void __advance(__xcodeml_template_type_0_0&__i,typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __n,class::std::__1::input_iterator_tag){{;for(;(__n,0);(--__n)){(++__i);}};
}
template<typename __xcodeml_template_type_0_0>void __advance(__xcodeml_template_type_0_0&__i,typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __n,class::std::__1::bidirectional_iterator_tag){if((__n,0)){{;for(;(__n,0);(--__n)){(++__i);}};}else{{;for(;(__n,0);(++__n)){(--__i);}};};
}
template<typename __xcodeml_template_type_0_0>void __advance(__xcodeml_template_type_0_0&__i,typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __n,class::std::__1::random_access_iterator_tag){(__i+=__n);
}
template<typename __xcodeml_template_type_0_0>void advance(__xcodeml_template_type_0_0&__i,typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __n){((void)0);
((__i,__n,__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_0>::iterator_category>::t()));
}
template<typename __xcodeml_template_type_0_0>typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __distance(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,class::std::__1::input_iterator_tag){typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __r=0;
{;for(;(__first,__last);(++__first)){(++__r);}};
return __r;
}
template<typename __xcodeml_template_type_0_0>typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __distance(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,class::std::__1::random_access_iterator_tag){return(__last-__first);
}
template<typename __xcodeml_template_type_0_0>typename iterator_traits<__xcodeml_template_type_0_0>::difference_type distance(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last){return((__first,__last,__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_0>::iterator_category>::t()));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,__xcodeml_template_type_0_0>::type next(__xcodeml_template_type_0_0 __x,typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __n){((void)0);
(std::__1::(__x,__n));
return __x;
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,__xcodeml_template_type_0_0>::type prev(__xcodeml_template_type_0_0 __x,typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __n){((void)0);
(std::__1::(__x,(-__n)));
return __x;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __is_stashing_iterator:public integral_constant<bool,0>{}
;
;
template<typename __xcodeml_template_type_0_0>class __is_stashing_iterator<__xcodeml_template_type_0_0,typename __void_t<typename __xcodeml_template_type_0_0::__stashing_iterator_tag>::type>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class reverse_iterator:public iterator<typename iterator_traits<__xcodeml_template_type_0_0>::iterator_category,typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_0>::difference_type,typename iterator_traits<__xcodeml_template_type_0_0>::pointer,typename iterator_traits<__xcodeml_template_type_0_0>::reference>{private:
private:__xcodeml_template_type_0_0 __t;

/* Ignored a member with no access specifier (!__is_stashing_iterator<__xcodeml_template_type_0_0,void>::value)"The specified iterator type cannot be used with reverse_iterator; Using stashing iterators with reverse_iterator causes undefined behavior";*/

protected:
protected:__xcodeml_template_type_0_0 current;
public:
public:typedef __xcodeml_template_type_0_0 iterator_type;
public:typedef typename iterator_traits<__xcodeml_template_type_0_0>::difference_type difference_type;
public:typedef typename iterator_traits<__xcodeml_template_type_0_0>::reference reference;
public:typedef typename iterator_traits<__xcodeml_template_type_0_0>::pointer pointer;
public:reverse_iterator():__t(),current(){}
public:reverse_iterator(__xcodeml_template_type_0_0 __x):__t(__x),current(__x){}
public:template<typename __xcodeml_template_type_1_0>reverse_iterator(reverse_iterator<__xcodeml_template_type_1_0>):__t((__u.base())),current((__u.base())){}
public:template<typename __xcodeml_template_type_1_0>class reverse_iterator&operator=(reverse_iterator<__xcodeml_template_type_1_0>){(this->__t=(this->current=(__u.base())));
return(*this);
}
public:__xcodeml_template_type_0_0 base()const{return this->current;
}
public:typename iterator_traits<__xcodeml_template_type_0_0>::reference operator*()const{__xcodeml_template_type_0_0 __tmp=this->current;
return(*(--__tmp));
}
public:typename iterator_traits<__xcodeml_template_type_0_0>::pointer operator->()const{return(std::__1::((this->operator*())));
}
public:class reverse_iterator&operator++(){(--this->current);
return(*this);
}
public:class reverse_iterator operator++(int){class reverse_iterator __tmp=(*this);
(--this->current);
return __tmp;
}
public:class reverse_iterator&operator--(){(++this->current);
return(*this);
}
public:class reverse_iterator operator--(int){class reverse_iterator __tmp=(*this);
(++this->current);
return __tmp;
}
public:class reverse_iterator operator+(typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __n)const{return __xcodeml_identity<class reverse_iterator>::t((this->current-__n));
}
public:class reverse_iterator&operator+=(typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __n){(this->current-=__n);
return(*this);
}
public:class reverse_iterator operator-(typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __n)const{return __xcodeml_identity<class reverse_iterator>::t((this->current+__n));
}
public:class reverse_iterator&operator-=(typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __n){(this->current+=__n);
return(*this);
}
public:typename iterator_traits<__xcodeml_template_type_0_0>::reference operator[](typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __n)const{return(*((*this)+__n));
}
}
;
template<>class reverse_iterator template<>class reverse_iterator;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator==(reverse_iterator<__xcodeml_template_type_0_0>,reverse_iterator<__xcodeml_template_type_0_1>){return((__x.base()),(__y.base()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator<(reverse_iterator<__xcodeml_template_type_0_0>,reverse_iterator<__xcodeml_template_type_0_1>){return((__x.base()),(__y.base()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator!=(reverse_iterator<__xcodeml_template_type_0_0>,reverse_iterator<__xcodeml_template_type_0_1>){return((__x.base()),(__y.base()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator>(reverse_iterator<__xcodeml_template_type_0_0>,reverse_iterator<__xcodeml_template_type_0_1>){return((__x.base()),(__y.base()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator>=(reverse_iterator<__xcodeml_template_type_0_0>,reverse_iterator<__xcodeml_template_type_0_1>){return((__x.base()),(__y.base()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator<=(reverse_iterator<__xcodeml_template_type_0_0>,reverse_iterator<__xcodeml_template_type_0_1>){return((__x.base()),(__y.base()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>decltype (operator-(reverse_iterator<__xcodeml_template_type_0_0>,reverse_iterator<__xcodeml_template_type_0_1>)){return((__y.base()),(__x.base()));
}
template<typename __xcodeml_template_type_0_0>reverse_iterator<__xcodeml_template_type_0_0>{return __xcodeml_identity<reverse_iterator<__xcodeml_template_type_0_0> >::t(((__x.base()),__n));
}
template<typename __xcodeml_template_type_0_0>reverse_iterator<__xcodeml_template_type_0_0>{return __xcodeml_identity<reverse_iterator<__xcodeml_template_type_0_0> >::t(__i);
}
template<typename __xcodeml_template_type_0_0>class back_insert_iterator:public iterator<class::std::__1::output_iterator_tag,void,void,void,void>{protected:
protected:__xcodeml_template_type_0_0(*container);
public:
public:typedef __xcodeml_template_type_0_0 container_type;
public:back_insert_iterator(__xcodeml_template_type_0_0&__x):container((std::__1::(__x))){}
public:class back_insert_iterator&operator=(typename __xcodeml_template_type_0_0::value_type const&__value_){(this->container.push_back(__value_));
return(*this);
}
public:class back_insert_iterator&operator=(typename __xcodeml_template_type_0_0::value_type(*__value_)){(this->container.push_back((std::__1::(__value_))));
return(*this);
}
public:class back_insert_iterator&operator*(){return(*this);
}
public:class back_insert_iterator&operator++(){return(*this);
}
public:class back_insert_iterator operator++(int){return(*this);
}
}
;
;
template<typename __xcodeml_template_type_0_0>back_insert_iterator<__xcodeml_template_type_0_0>{return __xcodeml_identity<back_insert_iterator<__xcodeml_template_type_0_0> >::t(__x);
}
template<typename __xcodeml_template_type_0_0>class front_insert_iterator:public iterator<class::std::__1::output_iterator_tag,void,void,void,void>{protected:
protected:__xcodeml_template_type_0_0(*container);
public:
public:typedef __xcodeml_template_type_0_0 container_type;
public:front_insert_iterator(__xcodeml_template_type_0_0&__x):container((std::__1::(__x))){}
public:class front_insert_iterator&operator=(typename __xcodeml_template_type_0_0::value_type const&__value_){(this->container.push_front(__value_));
return(*this);
}
public:class front_insert_iterator&operator=(typename __xcodeml_template_type_0_0::value_type(*__value_)){(this->container.push_front((std::__1::(__value_))));
return(*this);
}
public:class front_insert_iterator&operator*(){return(*this);
}
public:class front_insert_iterator&operator++(){return(*this);
}
public:class front_insert_iterator operator++(int){return(*this);
}
}
;
;
template<typename __xcodeml_template_type_0_0>front_insert_iterator<__xcodeml_template_type_0_0>{return __xcodeml_identity<front_insert_iterator<__xcodeml_template_type_0_0> >::t(__x);
}
template<typename __xcodeml_template_type_0_0>class insert_iterator:public iterator<class::std::__1::output_iterator_tag,void,void,void,void>{protected:
protected:__xcodeml_template_type_0_0(*container);
protected:typename __xcodeml_template_type_0_0::iterator iter;
public:
public:typedef __xcodeml_template_type_0_0 container_type;
public:insert_iterator(__xcodeml_template_type_0_0&__x,typename __xcodeml_template_type_0_0::iterator __i):container((std::__1::(__x))),iter(__i){}
public:class insert_iterator&operator=(typename __xcodeml_template_type_0_0::value_type const&__value_){(this->iter=(this->container.insert(this->iter,__value_)));
(++this->iter);
return(*this);
}
public:class insert_iterator&operator=(typename __xcodeml_template_type_0_0::value_type(*__value_)){(this->iter=(this->container.insert(this->iter,(std::__1::(__value_)))));
(++this->iter);
return(*this);
}
public:class insert_iterator&operator*(){return(*this);
}
public:class insert_iterator&operator++(){return(*this);
}
public:class insert_iterator&operator++(int){return(*this);
}
}
;
;
template<typename __xcodeml_template_type_0_0>insert_iterator<__xcodeml_template_type_0_0>{return __xcodeml_identity<insert_iterator<__xcodeml_template_type_0_0> >::t(__x,__i);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>class istream_iterator:public iterator<class::std::__1::input_iterator_tag,__xcodeml_template_type_0_0,__xcodeml_template_type_0_3,__xcodeml_template_type_0_0 const(*),__xcodeml_template_type_0_0 const&>{public:
public:typedef __xcodeml_template_type_0_1 char_type;
public:typedef __xcodeml_template_type_0_2 traits_type;
public:typedef basic_istream<__xcodeml_template_type_0_1,__xcodeml_template_type_0_2>;
private:
private:basic_istream<__xcodeml_template_type_0_1,__xcodeml_template_type_0_2>;
private:__xcodeml_template_type_0_0 __value_;
public:
public:istream_iterator():__in_stream_(0),__value_(){}
public:istream_iterator(basic_istream<__xcodeml_template_type_0_1,__xcodeml_template_type_0_2>):__in_stream_((std::__1::(__s))){if((!((*this->__in_stream_)>>this->__value_))){(this->__in_stream_=0);};
}
public:__xcodeml_template_type_0_0 const&operator*()const{return this->__value_;
}
public:__xcodeml_template_type_0_0 const(*operator->()const){return(std::__1::((this->operator*())));
}
public:class istream_iterator&operator++(){if((!((*this->__in_stream_)>>this->__value_))){(this->__in_stream_=0);};
return(*this);
}
public:class istream_iterator operator++(int){class istream_iterator __t=(*this);
(++(*this));
return __t;
}
public:friend template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1,typename __xcodeml_template_type_1_2,typename __xcodeml_template_type_1_3>bool operator==(istream_iterator<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1,__xcodeml_template_type_1_2,__xcodeml_template_type_1_3>,istream_iterator<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1,__xcodeml_template_type_1_2,__xcodeml_template_type_1_3>);
public:friend template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1,typename __xcodeml_template_type_1_2,typename __xcodeml_template_type_1_3>bool operator==(istream_iterator<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1,__xcodeml_template_type_1_2,__xcodeml_template_type_1_3>,istream_iterator<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1,__xcodeml_template_type_1_2,__xcodeml_template_type_1_3>);
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>bool operator==(istream_iterator<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2,__xcodeml_template_type_0_3>,istream_iterator<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2,__xcodeml_template_type_0_3>){return(__x.__in_stream_,__y.__in_stream_);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>bool operator!=(istream_iterator<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2,__xcodeml_template_type_0_3>,istream_iterator<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2,__xcodeml_template_type_0_3>){return(!(__x,__y));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class ostream_iterator:public iterator<class::std::__1::output_iterator_tag,void,void,void,void>{public:
public:typedef __xcodeml_template_type_0_1 char_type;
public:typedef __xcodeml_template_type_0_2 traits_type;
public:typedef basic_ostream<__xcodeml_template_type_0_1,__xcodeml_template_type_0_2>;
private:
private:basic_ostream<__xcodeml_template_type_0_1,__xcodeml_template_type_0_2>;
private:__xcodeml_template_type_0_1 const(*__delim_);
public:
public:ostream_iterator(basic_ostream<__xcodeml_template_type_0_1,__xcodeml_template_type_0_2>):__out_stream_((std::__1::(__s))),__delim_(0){}
public:ostream_iterator(basic_ostream<__xcodeml_template_type_0_1,__xcodeml_template_type_0_2>,__xcodeml_template_type_0_1 const(*__delimiter)):__out_stream_((std::__1::(__s))),__delim_(__delimiter){}
public:class ostream_iterator&operator=(__xcodeml_template_type_0_0 const&__value_){((*this->__out_stream_)<<__value_);
if(this->__delim_){((*this->__out_stream_)<<this->__delim_);};
return(*this);
}
public:class ostream_iterator&operator*(){return(*this);
}
public:class ostream_iterator&operator++(){return(*this);
}
public:class ostream_iterator&operator++(int){return(*this);
}
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class istreambuf_iterator:public iterator<class::std::__1::input_iterator_tag,__xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1::off_type,__xcodeml_template_type_0_0(*),__xcodeml_template_type_0_0>{public:
public:typedef __xcodeml_template_type_0_0 char_type;
public:typedef __xcodeml_template_type_0_1 traits_type;
public:typedef typename __xcodeml_template_type_0_1::int_type int_type;
public:typedef basic_streambuf<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>;
public:typedef basic_istream<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>;
private:
private:basic_streambuf<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>;
private:class __proxy{private:__xcodeml_template_type_0_0 __keep_;
private:basic_streambuf<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>;
private:__proxy(__xcodeml_template_type_0_0 __c,basic_streambuf<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>):__keep_(__c),__sbuf_(__s){}
public:friend class istreambuf_iterator;
public:
public:__xcodeml_template_type_0_0 operator*()const{return this->__keep_;
}
}
;
private:bool __test_for_eof()const{if((this->__sbuf_&&(__xcodeml_template_type_0_1::.eq_int_type((this->__sbuf_.sgetc()),(__xcodeml_template_type_0_1::.eof()))))){(this->__sbuf_=0);};
return(this->__sbuf_,0);
}
public:
public:istreambuf_iterator():__sbuf_(0){}
public:istreambuf_iterator(basic_istream<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>):__sbuf_((__s.rdbuf())){}
public:istreambuf_iterator(basic_streambuf<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>):__sbuf_(__s){}
public:istreambuf_iterator(class __proxy const&__p):__sbuf_(__p.__sbuf_){}
public:__xcodeml_template_type_0_0 operator*()const{return static_cast<__xcodeml_template_type_0_0>((this->__sbuf_.sgetc()));
}
public:class istreambuf_iterator&operator++(){(this->__sbuf_.sbumpc());
return(*this);
}
public:class::std::__1::istreambuf_iterator::__proxy operator++(int){return __xcodeml_identity<class::std::__1::istreambuf_iterator::__proxy>::t((this->__sbuf_.sbumpc()),this->__sbuf_);
}
public:bool equal(class istreambuf_iterator const&__b)const{return((this->__test_for_eof()),(__b.__test_for_eof()));
}
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator==(istreambuf_iterator<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,istreambuf_iterator<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>){return(__a.equal(__b));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator!=(istreambuf_iterator<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,istreambuf_iterator<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>){return(!(__a.equal(__b)));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class ostreambuf_iterator:public iterator<class::std::__1::output_iterator_tag,void,void,void,void>{public:
public:typedef __xcodeml_template_type_0_0 char_type;
public:typedef __xcodeml_template_type_0_1 traits_type;
public:typedef basic_streambuf<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>;
public:typedef basic_ostream<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>;
private:
private:basic_streambuf<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>;
public:
public:ostreambuf_iterator(basic_ostream<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>):__sbuf_((__s.rdbuf())){}
public:ostreambuf_iterator(basic_streambuf<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>):__sbuf_(__s){}
public:class ostreambuf_iterator&operator=(__xcodeml_template_type_0_0 __c){if((this->__sbuf_&&(__xcodeml_template_type_0_1::.eq_int_type((this->__sbuf_.sputc(__c)),(__xcodeml_template_type_0_1::.eof()))))){(this->__sbuf_=0);};
return(*this);
}
public:class ostreambuf_iterator&operator*(){return(*this);
}
public:class ostreambuf_iterator&operator++(){return(*this);
}
public:class ostreambuf_iterator&operator++(int){return(*this);
}
public:bool failed()const{return(this->__sbuf_,0);
}
public:friend template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>ostreambuf_iterator<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1>;
}
;
;
template<typename __xcodeml_template_type_0_0>class move_iterator{private:
private:__xcodeml_template_type_0_0 __i;
public:
public:typedef __xcodeml_template_type_0_0 iterator_type;
public:typedef typename iterator_traits<__xcodeml_template_type_0_0>::iterator_category iterator_category;
public:typedef typename iterator_traits<__xcodeml_template_type_0_0>::value_type value_type;
public:typedef typename iterator_traits<__xcodeml_template_type_0_0>::difference_type difference_type;
public:typedef __xcodeml_template_type_0_0 pointer;
public:typedef typename iterator_traits<__xcodeml_template_type_0_0>::reference __reference;
public:typedef typename conditional<expression,typename remove_reference<typename iterator_traits<__xcodeml_template_type_0_0>::reference>::type(*),typename iterator_traits<__xcodeml_template_type_0_0>::reference>::type reference;
public:move_iterator():__i(){}
public:move_iterator(__xcodeml_template_type_0_0 __x):__i(__x){}
public:template<typename __xcodeml_template_type_1_0>move_iterator(move_iterator<__xcodeml_template_type_1_0>):__i((__u.base())){}
public:__xcodeml_template_type_0_0 base()const{return this->__i;
}
public:typename conditional<expression,typename remove_reference<typename iterator_traits<__xcodeml_template_type_0_0>::reference>::type(*),typename iterator_traits<__xcodeml_template_type_0_0>::reference>::type operator*()const{return static_cast<typename conditional<expression,typename remove_reference<typename iterator_traits<__xcodeml_template_type_0_0>::reference>::type(*),typename iterator_traits<__xcodeml_template_type_0_0>::reference>::type>((*this->__i));
}
public:__xcodeml_template_type_0_0 operator->()const{return this->__i;
}
public:class move_iterator&operator++(){(++this->__i);
return(*this);
}
public:class move_iterator operator++(int){class move_iterator __tmp=(*this);
(++this->__i);
return __tmp;
}
public:class move_iterator&operator--(){(--this->__i);
return(*this);
}
public:class move_iterator operator--(int){class move_iterator __tmp=(*this);
(--this->__i);
return __tmp;
}
public:class move_iterator operator+(typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __n)const{return __xcodeml_identity<class move_iterator>::t((this->__i,__n));
}
public:class move_iterator&operator+=(typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __n){(this->__i+=__n);
return(*this);
}
public:class move_iterator operator-(typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __n)const{return __xcodeml_identity<class move_iterator>::t((this->__i,__n));
}
public:class move_iterator&operator-=(typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __n){(this->__i-=__n);
return(*this);
}
public:typename conditional<expression,typename remove_reference<typename iterator_traits<__xcodeml_template_type_0_0>::reference>::type(*),typename iterator_traits<__xcodeml_template_type_0_0>::reference>::type operator[](typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __n)const{return static_cast<typename conditional<expression,typename remove_reference<typename iterator_traits<__xcodeml_template_type_0_0>::reference>::type(*),typename iterator_traits<__xcodeml_template_type_0_0>::reference>::type>((this->__i)[__n]);
}
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator==(move_iterator<__xcodeml_template_type_0_0>,move_iterator<__xcodeml_template_type_0_1>){return((__x.base()),(__y.base()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator<(move_iterator<__xcodeml_template_type_0_0>,move_iterator<__xcodeml_template_type_0_1>){return((__x.base()),(__y.base()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator!=(move_iterator<__xcodeml_template_type_0_0>,move_iterator<__xcodeml_template_type_0_1>){return((__x.base()),(__y.base()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator>(move_iterator<__xcodeml_template_type_0_0>,move_iterator<__xcodeml_template_type_0_1>){return((__x.base()),(__y.base()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator>=(move_iterator<__xcodeml_template_type_0_0>,move_iterator<__xcodeml_template_type_0_1>){return((__x.base()),(__y.base()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator<=(move_iterator<__xcodeml_template_type_0_0>,move_iterator<__xcodeml_template_type_0_1>){return((__x.base()),(__y.base()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>decltype (operator-(move_iterator<__xcodeml_template_type_0_0>,move_iterator<__xcodeml_template_type_0_1>)){return((__x.base()),(__y.base()));
}
template<typename __xcodeml_template_type_0_0>move_iterator<__xcodeml_template_type_0_0>{return __xcodeml_identity<move_iterator<__xcodeml_template_type_0_0> >::t(((__x.base()),__n));
}
template<typename __xcodeml_template_type_0_0>move_iterator<__xcodeml_template_type_0_0>{return __xcodeml_identity<move_iterator<__xcodeml_template_type_0_0> >::t(__i);
}
template<typename __xcodeml_template_type_0_0>class __wrap_iter;
template<>class __wrap_iter template<>class __wrap_iter;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator==(__wrap_iter<__xcodeml_template_type_0_0>,__wrap_iter<__xcodeml_template_type_0_1>)
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator<(__wrap_iter<__xcodeml_template_type_0_0>,__wrap_iter<__xcodeml_template_type_0_1>)
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator!=(__wrap_iter<__xcodeml_template_type_0_0>,__wrap_iter<__xcodeml_template_type_0_1>)
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator>(__wrap_iter<__xcodeml_template_type_0_0>,__wrap_iter<__xcodeml_template_type_0_1>)
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator>=(__wrap_iter<__xcodeml_template_type_0_0>,__wrap_iter<__xcodeml_template_type_0_1>)
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator<=(__wrap_iter<__xcodeml_template_type_0_0>,__wrap_iter<__xcodeml_template_type_0_1>)
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>decltype (operator-(__wrap_iter<__xcodeml_template_type_0_0>,__wrap_iter<__xcodeml_template_type_0_1>))
template<typename __xcodeml_template_type_0_0>__wrap_iter<__xcodeml_template_type_0_0>
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_1 copy(__xcodeml_template_type_0_0,__xcodeml_template_type_0_0,__xcodeml_template_type_0_1)
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_1 copy_backward(__xcodeml_template_type_0_0,__xcodeml_template_type_0_0,__xcodeml_template_type_0_1)
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_1 move(__xcodeml_template_type_0_0,__xcodeml_template_type_0_0,__xcodeml_template_type_0_1)
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_1 move_backward(__xcodeml_template_type_0_0,__xcodeml_template_type_0_0,__xcodeml_template_type_0_1)
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,__xcodeml_template_type_0_0(*)>::type __unwrap_iter(__wrap_iter<__xcodeml_template_type_0_0(*)>)
template<typename __xcodeml_template_type_0_0>class __wrap_iter{public:
public:typedef __xcodeml_template_type_0_0 iterator_type;
public:typedef typename iterator_traits<__xcodeml_template_type_0_0>::iterator_category iterator_category;
public:typedef typename iterator_traits<__xcodeml_template_type_0_0>::value_type value_type;
public:typedef typename iterator_traits<__xcodeml_template_type_0_0>::difference_type difference_type;
public:typedef typename iterator_traits<__xcodeml_template_type_0_0>::pointer pointer;
public:typedef typename iterator_traits<__xcodeml_template_type_0_0>::reference reference;
private:
private:__xcodeml_template_type_0_0 __i;
public:
public:__wrap_iter():__i({}){}
public:template<typename __xcodeml_template_type_1_0>__wrap_iter(__wrap_iter<__xcodeml_template_type_1_0>,typename enable_if<expression,void>::type(*)):__i((__u.base())){}
public:typename iterator_traits<__xcodeml_template_type_0_0>::reference operator*()const{return(*this->__i);
}
public:typename iterator_traits<__xcodeml_template_type_0_0>::pointer operator->()const{return((typename iterator_traits<__xcodeml_template_type_0_0>::pointer)(std::__1::((*this->__i))));
}
public:class __wrap_iter&operator++(){(++this->__i);
return(*this);
}
public:class __wrap_iter operator++(int){class __wrap_iter __tmp=(*this);
(++(*this));
return __tmp;
}
public:class __wrap_iter&operator--(){(--this->__i);
return(*this);
}
public:class __wrap_iter operator--(int){class __wrap_iter __tmp=(*this);
(--(*this));
return __tmp;
}
public:class __wrap_iter operator+(typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __n)const{class __wrap_iter __w=(*this);
(__w+=__n);
return __w;
}
public:class __wrap_iter&operator+=(typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __n){(this->__i+=__n);
return(*this);
}
public:class __wrap_iter operator-(typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __n)const{return((*this),(__n));
}
public:class __wrap_iter&operator-=(typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __n){((*this)+=(__n));
return(*this);
}
public:typename iterator_traits<__xcodeml_template_type_0_0>::reference operator[](typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __n)const{return(this->__i)[__n];
}
public:__xcodeml_template_type_0_0 base()const{return this->__i;
}
private:
private:__wrap_iter(__xcodeml_template_type_0_0 __x):__i(__x){}
public:friend template<typename __xcodeml_template_type_1_0>class __wrap_iter;
;
public:friend template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1,typename __xcodeml_template_type_1_2>class basic_string;
;
public:friend template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>class vector;
;
public:friend template<typename __xcodeml_template_type_1_0,unsigned long>class span;
;
public:friend template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>bool operator==(__wrap_iter<__xcodeml_template_type_1_0>,__wrap_iter<__xcodeml_template_type_1_1>);
public:friend template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>bool operator<(__wrap_iter<__xcodeml_template_type_1_0>,__wrap_iter<__xcodeml_template_type_1_1>);
public:friend template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>bool operator!=(__wrap_iter<__xcodeml_template_type_1_0>,__wrap_iter<__xcodeml_template_type_1_1>);
public:friend template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>bool operator>(__wrap_iter<__xcodeml_template_type_1_0>,__wrap_iter<__xcodeml_template_type_1_1>);
public:friend template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>bool operator>=(__wrap_iter<__xcodeml_template_type_1_0>,__wrap_iter<__xcodeml_template_type_1_1>);
public:friend template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>bool operator<=(__wrap_iter<__xcodeml_template_type_1_0>,__wrap_iter<__xcodeml_template_type_1_1>);
public:friend template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>decltype (operator-(__wrap_iter<__xcodeml_template_type_1_0>,__wrap_iter<__xcodeml_template_type_1_1>));
public:friend template<typename __xcodeml_template_type_1_0>__wrap_iter<__xcodeml_template_type_1_0>;
public:friend template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>__xcodeml_template_type_1_1 copy(__xcodeml_template_type_1_0,__xcodeml_template_type_1_0,__xcodeml_template_type_1_1);
public:friend template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>__xcodeml_template_type_1_1 copy_backward(__xcodeml_template_type_1_0,__xcodeml_template_type_1_0,__xcodeml_template_type_1_1);
public:friend template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>__xcodeml_template_type_1_1 move(__xcodeml_template_type_1_0,__xcodeml_template_type_1_0,__xcodeml_template_type_1_1);
public:friend template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>__xcodeml_template_type_1_1 move_backward(__xcodeml_template_type_1_0,__xcodeml_template_type_1_0,__xcodeml_template_type_1_1);
public:friend template<typename __xcodeml_template_type_1_0>typename enable_if<expression,__xcodeml_template_type_1_0(*)>::type __unwrap_iter(__wrap_iter<__xcodeml_template_type_1_0(*)>);
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator==(__wrap_iter<__xcodeml_template_type_0_0>,__wrap_iter<__xcodeml_template_type_0_1>){return((__x.base()),(__y.base()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator<(__wrap_iter<__xcodeml_template_type_0_0>,__wrap_iter<__xcodeml_template_type_0_1>){return((__x.base()),(__y.base()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator!=(__wrap_iter<__xcodeml_template_type_0_0>,__wrap_iter<__xcodeml_template_type_0_1>){return(!(__x,__y));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator>(__wrap_iter<__xcodeml_template_type_0_0>,__wrap_iter<__xcodeml_template_type_0_1>){return(__y,__x);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator>=(__wrap_iter<__xcodeml_template_type_0_0>,__wrap_iter<__xcodeml_template_type_0_1>){return(!(__x,__y));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator<=(__wrap_iter<__xcodeml_template_type_0_0>,__wrap_iter<__xcodeml_template_type_0_1>){return(!(__y,__x));
}
template<typename __xcodeml_template_type_0_0>bool operator!=(__wrap_iter<__xcodeml_template_type_0_0>,__wrap_iter<__xcodeml_template_type_0_0>){return(!(__x,__y));
}
template<typename __xcodeml_template_type_0_0>bool operator>(__wrap_iter<__xcodeml_template_type_0_0>,__wrap_iter<__xcodeml_template_type_0_0>){return(__y,__x);
}
template<typename __xcodeml_template_type_0_0>bool operator>=(__wrap_iter<__xcodeml_template_type_0_0>,__wrap_iter<__xcodeml_template_type_0_0>){return(!(__x,__y));
}
template<typename __xcodeml_template_type_0_0>bool operator<=(__wrap_iter<__xcodeml_template_type_0_0>,__wrap_iter<__xcodeml_template_type_0_0>){return(!(__y,__x));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>decltype (operator-(__wrap_iter<__xcodeml_template_type_0_0>,__wrap_iter<__xcodeml_template_type_0_1>)){return((__x.base()),(__y.base()));
}
template<typename __xcodeml_template_type_0_0>__wrap_iter<__xcodeml_template_type_0_0>{(__x+=__n);
return __x;
}
template<typename __xcodeml_template_type_0_0>class __libcpp_is_trivial_iterator:public integral_constant<bool,expression>{}
;
;
template<typename __xcodeml_template_type_0_0>class __libcpp_is_trivial_iterator<move_iterator<__xcodeml_template_type_0_0> >:public integral_constant<bool,expression>{}
;
template<typename __xcodeml_template_type_0_0>class __libcpp_is_trivial_iterator<reverse_iterator<__xcodeml_template_type_0_0> >:public integral_constant<bool,expression>{}
;
template<typename __xcodeml_template_type_0_0>class __libcpp_is_trivial_iterator<__wrap_iter<__xcodeml_template_type_0_0> >:public integral_constant<bool,expression>{}
;
template<typename __xcodeml_template_type_0_0,unsigned long _Np>__xcodeml_template_type_0_0(*begin(__xcodeml_template_type_0_0&__array)){return __array;
}
template<typename __xcodeml_template_type_0_0,unsigned long _Np>__xcodeml_template_type_0_0(*end(__xcodeml_template_type_0_0&__array)){return(__array,_Np);
}
template<typename __xcodeml_template_type_0_0>decltype (begin(__xcodeml_template_type_0_0&__c)){return(__c.begin());
}
template<typename __xcodeml_template_type_0_0>decltype (begin(__xcodeml_template_type_0_0 const&__c)){return(__c.begin());
}
template<typename __xcodeml_template_type_0_0>decltype (end(__xcodeml_template_type_0_0&__c)){return(__c.end());
}
template<typename __xcodeml_template_type_0_0>decltype (end(__xcodeml_template_type_0_0 const&__c)){return(__c.end());
}
template<typename __xcodeml_template_type_0_0,unsigned long _Np>reverse_iterator<__xcodeml_template_type_0_0(*)>{return __xcodeml_identity<reverse_iterator<__xcodeml_template_type_0_0(*)> >::t((__array,_Np));
}
template<typename __xcodeml_template_type_0_0,unsigned long _Np>reverse_iterator<__xcodeml_template_type_0_0(*)>{return __xcodeml_identity<reverse_iterator<__xcodeml_template_type_0_0(*)> >::t(__array);
}
template<typename __xcodeml_template_type_0_0>reverse_iterator<__xcodeml_template_type_0_0 const(*)>{return __xcodeml_identity<reverse_iterator<__xcodeml_template_type_0_0 const(*)> >::t((__il.end()));
}
template<typename __xcodeml_template_type_0_0>reverse_iterator<__xcodeml_template_type_0_0 const(*)>{return __xcodeml_identity<reverse_iterator<__xcodeml_template_type_0_0 const(*)> >::t((__il.begin()));
}
template<typename __xcodeml_template_type_0_0>decltype (cbegin(__xcodeml_template_type_0_0 const&__c)){return(std::__1::(__c));
}
template<typename __xcodeml_template_type_0_0>decltype (cend(__xcodeml_template_type_0_0 const&__c)){return(std::__1::(__c));
}
template<typename __xcodeml_template_type_0_0>decltype (rbegin(__xcodeml_template_type_0_0&__c)){return(__c.rbegin());
}
template<typename __xcodeml_template_type_0_0>decltype (rbegin(__xcodeml_template_type_0_0 const&__c)){return(__c.rbegin());
}
template<typename __xcodeml_template_type_0_0>decltype (rend(__xcodeml_template_type_0_0&__c)){return(__c.rend());
}
template<typename __xcodeml_template_type_0_0>decltype (rend(__xcodeml_template_type_0_0 const&__c)){return(__c.rend());
}
template<typename __xcodeml_template_type_0_0>decltype (crbegin(__xcodeml_template_type_0_0 const&__c)){return(std::__1::(__c));
}
template<typename __xcodeml_template_type_0_0>decltype (crend(__xcodeml_template_type_0_0 const&__c)){return(std::__1::(__c));
}
}
}
namespace std{namespace __1{template<unsigned long _Ip,typename __xcodeml_template_type_0_1,bool=(is_empty<__xcodeml_template_type_0_1>::value&&(!__libcpp_is_final<__xcodeml_template_type_0_1>::value))>class __tuple_leaf;
;
template<unsigned long _Ip,typename __xcodeml_template_type_0_1,bool _Ep>void swap(__tuple_leaf<expression,__xcodeml_template_type_0_1,expression>,__tuple_leaf<expression,__xcodeml_template_type_0_1,expression>){(((__x.get()),(__y.get())));
}
template<unsigned long _Ip,typename __xcodeml_template_type_0_1,bool>class __tuple_leaf{private:__xcodeml_template_type_0_1 __value_;
private:template<typename __xcodeml_template_type_1_0>static bool __can_bind_reference(){return(!__xcodeml_template_type_0_1 __xcodeml_template_type_1_0);
}
private:class __tuple_leaf&operator=(class __tuple_leaf const&);
public:
public:__tuple_leaf():__value_(){(!is_reference<__xcodeml_template_type_0_1>::.value)"Attempted to default construct a reference element in a tuple";
}
public:template<typename __xcodeml_template_type_1_0>__tuple_leaf(class::std::__1::integral_constant<int,0>,__xcodeml_template_type_1_0 const&):__value_(){(!is_reference<__xcodeml_template_type_0_1>::.value)"Attempted to default construct a reference element in a tuple";
}
public:template<typename __xcodeml_template_type_1_0>__tuple_leaf(class::std::__1::integral_constant<int,1>,__xcodeml_template_type_1_0 const&__a):__value_(__xcodeml_identity<class::std::__1::allocator_arg_t>::t()__a){(!is_reference<__xcodeml_template_type_0_1>::.value)"Attempted to default construct a reference element in a tuple";
}
public:template<typename __xcodeml_template_type_1_0>__tuple_leaf(class::std::__1::integral_constant<int,2>,__xcodeml_template_type_1_0 const&__a):__value_(__a){(!is_reference<__xcodeml_template_type_0_1>::.value)"Attempted to default construct a reference element in a tuple";
}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>__tuple_leaf(__xcodeml_template_type_1_0(*__t)):__value_((std::__1::__xcodeml_template_type_1_0(__t))){(__xcodeml_template_type_1_0(*)())"Attempted construction of reference element binds to a temporary whose lifetime has ended";
}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>__tuple_leaf(class::std::__1::integral_constant<int,0>,__xcodeml_template_type_1_1 const&,__xcodeml_template_type_1_0(*__t)):__value_((std::__1::__xcodeml_template_type_1_0(__t))){(__xcodeml_template_type_1_0(*)())"Attempted construction of reference element binds to a temporary whose lifetime has ended";
}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>__tuple_leaf(class::std::__1::integral_constant<int,1>,__xcodeml_template_type_1_1 const&__a,__xcodeml_template_type_1_0(*__t)):__value_(__xcodeml_identity<class::std::__1::allocator_arg_t>::t()__a(std::__1::__xcodeml_template_type_1_0(__t))){(!is_reference<__xcodeml_template_type_0_1>::.value)"Attempted to uses-allocator construct a reference element in a tuple";
}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>__tuple_leaf(class::std::__1::integral_constant<int,2>,__xcodeml_template_type_1_1 const&__a,__xcodeml_template_type_1_0(*__t)):__value_((std::__1::__xcodeml_template_type_1_0(__t))__a){(!is_reference<__xcodeml_template_type_0_1>::.value)"Attempted to uses-allocator construct a reference element in a tuple";
}
public:__tuple_leaf(class __tuple_leaf const&__t);
public:__tuple_leaf(class __tuple_leaf(*__t));
public:template<typename __xcodeml_template_type_1_0>class __tuple_leaf&operator=(__xcodeml_template_type_1_0(*__t)){(this->__value_=(std::__1::__xcodeml_template_type_1_0(__t)));
return(*this);
}
public:int swap(class __tuple_leaf&__t){(std::__1::((*this),__t));
return 0;
}
public:__xcodeml_template_type_0_1&get(){return this->__value_;
}
public:__xcodeml_template_type_0_1 const&get()const{return this->__value_;
}
}
;
;
template<unsigned long _Ip,typename __xcodeml_template_type_0_1>class __tuple_leaf<expression,__xcodeml_template_type_0_1,1>:private __xcodeml_template_type_0_1{private:class __tuple_leaf<expression,__xcodeml_template_type_0_1,1>&operator=(class __tuple_leaf const&);
public:
public:__tuple_leaf(){}
public:template<typename __xcodeml_template_type_1_0>__tuple_leaf(class::std::__1::integral_constant<int,0>,__xcodeml_template_type_1_0 const&){}
public:template<typename __xcodeml_template_type_1_0>__tuple_leaf(class::std::__1::integral_constant<int,1>,__xcodeml_template_type_1_0 const&__a):(__xcodeml_identity<class::std::__1::allocator_arg_t>::t()__a){}
public:template<typename __xcodeml_template_type_1_0>__tuple_leaf(class::std::__1::integral_constant<int,2>,__xcodeml_template_type_1_0 const&__a):(__a){}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>__tuple_leaf(__xcodeml_template_type_1_0(*__t)):((std::__1::__xcodeml_template_type_1_0(__t))){}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>__tuple_leaf(class::std::__1::integral_constant<int,0>,__xcodeml_template_type_1_1 const&,__xcodeml_template_type_1_0(*__t)):((std::__1::__xcodeml_template_type_1_0(__t))){}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>__tuple_leaf(class::std::__1::integral_constant<int,1>,__xcodeml_template_type_1_1 const&__a,__xcodeml_template_type_1_0(*__t)):(__xcodeml_identity<class::std::__1::allocator_arg_t>::t()__a(std::__1::__xcodeml_template_type_1_0(__t))){}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>__tuple_leaf(class::std::__1::integral_constant<int,2>,__xcodeml_template_type_1_1 const&__a,__xcodeml_template_type_1_0(*__t)):((std::__1::__xcodeml_template_type_1_0(__t))__a){}
public:__tuple_leaf(class __tuple_leaf const&);
public:__tuple_leaf(class __tuple_leaf<expression,__xcodeml_template_type_0_1,1>(*));
public:template<typename __xcodeml_template_type_1_0>class __tuple_leaf<expression,__xcodeml_template_type_0_1,1>&operator=(__xcodeml_template_type_1_0(*__t)){(__xcodeml_template_type_0_1::.((std::__1::__xcodeml_template_type_1_0(__t))));
return(*this);
}
public:int swap(class __tuple_leaf<expression,__xcodeml_template_type_0_1,1>&__t){(std::__1::((*this),__t));
return 0;
}
public:__xcodeml_template_type_0_1&get(){return static_cast<__xcodeml_template_type_0_1&>((*this));
}
public:__xcodeml_template_type_0_1 const&get()const{return static_cast<__xcodeml_template_type_0_1 const&>((*this));
}
}
;
template<typename __xcodeml_template_type_0_0>void __swallow(void/**/){}
template<typename __xcodeml_template_type_0_0>class __all_default_constructible;
;
template<typename __xcodeml_template_type_0_0>class __all_default_constructible<__tuple_types<...> >:public integral_constant<bool,expression>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __tuple_impl;
;
template<unsigned long _Indx,typename __xcodeml_template_type_0_1>class __tuple_impl<__tuple_indices<...>,...>:public __tuple_leaf<expression,__xcodeml_template_type_0_1,expression>{public:__tuple_impl(){}
public:template<unsigned long _Uf,typename __xcodeml_template_type_1_1,unsigned long _Ul,typename __xcodeml_template_type_1_3,typename __xcodeml_template_type_1_4>__tuple_impl(__tuple_indices<...>,__tuple_types<...>,__tuple_indices<...>,__tuple_types<...>,void/*__u*/):((std::__1::__xcodeml_template_type_1_4(__u))),(){}
public:template<typename __xcodeml_template_type_1_0,unsigned long _Uf,typename __xcodeml_template_type_1_2,unsigned long _Ul,typename __xcodeml_template_type_1_4,typename __xcodeml_template_type_1_5>__tuple_impl(class::std::__1::allocator_arg_t,__xcodeml_template_type_1_0 const&__a,__tuple_indices<...>,__tuple_types<...>,__tuple_indices<...>,__tuple_types<...>,void/*__u*/):(__xcodeml_identity<__uses_alloc_ctor<__xcodeml_template_type_1_2,__xcodeml_template_type_1_0,...> >::t()__a(std::__1::__xcodeml_template_type_1_5(__u))),(__xcodeml_identity<__uses_alloc_ctor<__xcodeml_template_type_1_4,__xcodeml_template_type_1_0,...> >::t()__a){}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>__tuple_impl(__xcodeml_template_type_1_0(*__t)):((std::__1::typename tuple_element<expression,typename __make_tuple_types<__xcodeml_template_type_1_0,expression,0,expression>::type>::type((std::__1::_Indx(__t))))){}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1,typename __xcodeml_template_type_1_2>__tuple_impl(class::std::__1::allocator_arg_t,__xcodeml_template_type_1_0 const&__a,__xcodeml_template_type_1_1(*__t)):(__xcodeml_identity<__uses_alloc_ctor<__xcodeml_template_type_0_1,__xcodeml_template_type_1_0,...> >::t()__a(std::__1::typename tuple_element<expression,typename __make_tuple_types<__xcodeml_template_type_1_1,expression,0,expression>::type>::type((std::__1::_Indx(__t))))){}
public:template<typename __xcodeml_template_type_1_0>typename enable_if<expression,class __tuple_impl<__tuple_indices<...>,...>&>::type operator=(__xcodeml_template_type_1_0(*__t)){(((__tuple_leaf<expression,__xcodeml_template_type_0_1,expression>::.((std::__1::typename tuple_element<expression,typename __make_tuple_types<__xcodeml_template_type_1_0,expression,0,expression>::type>::type((std::__1::_Indx(__t))))))));
return(*this);
}
public:__tuple_impl(class __tuple_impl const&);
public:__tuple_impl(class __tuple_impl<__tuple_indices<...>,...>(*));
public:class __tuple_impl<__tuple_indices<...>,...>&operator=(class __tuple_impl const&__t){(((__tuple_leaf<expression,__xcodeml_template_type_0_1,expression>::.((static_cast<__tuple_leaf<expression,__xcodeml_template_type_0_1,expression> >(__t).get())))));
return(*this);
}
public:class __tuple_impl<__tuple_indices<...>,...>&operator=(class __tuple_impl<__tuple_indices<...>,...>(*__t)){(((__tuple_leaf<expression,__xcodeml_template_type_0_1,expression>::.((std::__1::__xcodeml_template_type_0_1((static_cast<__tuple_leaf<expression,__xcodeml_template_type_0_1,expression> >(__t).get())))))));
return(*this);
}
public:void swap(class __tuple_impl<__tuple_indices<...>,...>&__t){(((__tuple_leaf<expression,__xcodeml_template_type_0_1,expression>::.swap(static_cast<__tuple_leaf<expression,__xcodeml_template_type_0_1,expression> >(__t)))));
}
}
;
template<typename __xcodeml_template_type_0_0>class tuple{private:typedef __tuple_impl<typename __make_tuple_indices<expression,0>::type,...>;
private:__tuple_impl<typename __make_tuple_indices<expression,0>::type,...>;
private:constexpr static bool const _EnableImplicitReducedArityExtension=false;
private:template<typename __xcodeml_template_type_1_0>class _PackExpandsToThisTuple:public integral_constant<bool,0>{}
;
;

/* Ignored a member with no access specifier template<typename __xcodeml_template_type_1_0>class _PackExpandsToThisTuple<...>:public is_same<typename __uncvref<__xcodeml_template_type_1_0>::type,class tuple>{}
;*/

private:template<bool _MaybeEnable,typename __xcodeml_template_type_1_1>class _CheckArgsConstructor:public __check_tuple_constructor_fail{}
;
;

/* Ignored a member with no access specifier template<typename __xcodeml_template_type_1_0>class _CheckArgsConstructor<1,__xcodeml_template_type_1_0>{public:template<typename __xcodeml_template_type_2_0>static bool __enable_default(){return integral_constant<bool,expression>::value;
}
public:template<typename __xcodeml_template_type_2_0>static bool __enable_explicit(){return((__tuple_constructible<tuple<...>,typename __make_tuple_types<class tuple,expression,0,expression>::type,expression,expression>::value&&(!__tuple_convertible<tuple<...>,typename __make_tuple_types<class tuple,expression,0,expression>::type,expression,expression>::value))&&__all_default_constructible<typename __make_tuple_types<class tuple,expression,expression,expression>::type>::value);
}
public:template<typename __xcodeml_template_type_2_0>static bool __enable_implicit(){return((__tuple_constructible<tuple<...>,typename __make_tuple_types<class tuple,expression,0,expression>::type,expression,expression>::value&&__tuple_convertible<tuple<...>,typename __make_tuple_types<class tuple,expression,0,expression>::type,expression,expression>::value)&&__all_default_constructible<typename __make_tuple_types<class tuple,expression,expression,expression>::type>::value);
}
}
;*/

private:template<bool _MaybeEnable,bool=(==1),typename __xcodeml_template_type_1_2>class _CheckTupleLikeConstructor:public __check_tuple_constructor_fail{}
;
;

/* Ignored a member with no access specifier template<typename __xcodeml_template_type_1_0>class _CheckTupleLikeConstructor<1,0,__xcodeml_template_type_1_0>{public:template<typename __xcodeml_template_type_2_0>static bool __enable_implicit(){return(__tuple_constructible<__xcodeml_template_type_2_0,class tuple,expression,expression>::value&&__tuple_convertible<__xcodeml_template_type_2_0,class tuple,expression,expression>::value);
}
public:template<typename __xcodeml_template_type_2_0>static bool __enable_explicit(){return(__tuple_constructible<__xcodeml_template_type_2_0,class tuple,expression,expression>::value&&(!__tuple_convertible<__xcodeml_template_type_2_0,class tuple,expression,expression>::value));
}
}
;*/


/* Ignored a member with no access specifier template<typename __xcodeml_template_type_1_0>class _CheckTupleLikeConstructor<1,1,__xcodeml_template_type_1_0>{public:template<typename __xcodeml_template_type_2_0>using _PreferTupleLikeConstructor=void/**/;
public:template<typename __xcodeml_template_type_2_0>static bool __enable_implicit(){return void/**/::value;
}
public:template<typename __xcodeml_template_type_2_0>static bool __enable_explicit(){return void/**/::value;
}
}
;*/

private:template<typename __xcodeml_template_type_1_0,bool _DisableIfLValue>using _EnableImplicitTupleLikeConstructor=void/**/;
private:template<typename __xcodeml_template_type_1_0,bool _DisableIfLValue>using _EnableExplicitTupleLikeConstructor=void/**/;
public:friend template<unsigned long _Jp,typename __xcodeml_template_type_1_1>typename tuple_element<expression,tuple<...> >::type&get(tuple<...>);
public:friend template<unsigned long _Jp,typename __xcodeml_template_type_1_1>typename tuple_element<expression,tuple<...> >::type const&get(tuple<...>);
public:friend template<unsigned long _Jp,typename __xcodeml_template_type_1_1>typename tuple_element<expression,tuple<...> >::type(*get(tuple<...>));
public:friend template<unsigned long _Jp,typename __xcodeml_template_type_1_1>typename tuple_element<expression,tuple<...> >::type const(*get(tuple<...>));
public:
public:template<bool _Dummy=true,typename __xcodeml_template_type_1_1>tuple(){}
public:tuple(class tuple const&);
public:tuple(class tuple(*));
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1,bool _Dummy=true,typename __xcodeml_template_type_1_3>tuple(__xcodeml_template_type_1_0,__xcodeml_template_type_1_1 const&__a):__base_(__xcodeml_identity<class::std::__1::allocator_arg_t>::t()__a __xcodeml_identity<class::std::__1::__tuple_indices<...> >::t()__xcodeml_identity<class::std::__1::__tuple_types<...> >::t()__xcodeml_identity<typename __make_tuple_indices<expression,0>::type>::t()__xcodeml_identity<__tuple_types<...> >::t()){}
public:template<bool _Dummy=true,typename enable_if<expression,bool>::type=false>tuple(void/*__t*/):__base_(__xcodeml_identity<typename __make_tuple_indices<expression,0>::type>::t()__xcodeml_identity<typename __make_tuple_types<class tuple,expression,0,expression>::type>::t()__xcodeml_identity<class::std::__1::__tuple_indices<...> >::t()__xcodeml_identity<typename __make_tuple_types<class tuple,0,0,expression>::type>::t()__t){}
public:template<bool _Dummy=true,typename enable_if<expression,bool>::type=false>tuple(void/*__t*/):__base_(__xcodeml_identity<typename __make_tuple_indices<expression,0>::type>::t()__xcodeml_identity<typename __make_tuple_types<class tuple,expression,0,expression>::type>::t()__xcodeml_identity<class::std::__1::__tuple_indices<...> >::t()__xcodeml_identity<typename __make_tuple_types<class tuple,0,0,expression>::type>::t()__t){}
public:template<typename __xcodeml_template_type_1_0,bool _Dummy=true,typename enable_if<expression,bool>::type=false>tuple(class::std::__1::allocator_arg_t,__xcodeml_template_type_1_0 const&__a,void/*__t*/):__base_(__xcodeml_identity<class::std::__1::allocator_arg_t>::t()__a __xcodeml_identity<typename __make_tuple_indices<expression,0>::type>::t()__xcodeml_identity<typename __make_tuple_types<class tuple,expression,0,expression>::type>::t()__xcodeml_identity<class::std::__1::__tuple_indices<...> >::t()__xcodeml_identity<typename __make_tuple_types<class tuple,0,0,expression>::type>::t()__t){}
public:template<typename __xcodeml_template_type_1_0,bool _Dummy=true,typename enable_if<expression,bool>::type=false>tuple(class::std::__1::allocator_arg_t,__xcodeml_template_type_1_0 const&__a,void/*__t*/):__base_(__xcodeml_identity<class::std::__1::allocator_arg_t>::t()__a __xcodeml_identity<typename __make_tuple_indices<expression,0>::type>::t()__xcodeml_identity<typename __make_tuple_types<class tuple,expression,0,expression>::type>::t()__xcodeml_identity<class::std::__1::__tuple_indices<...> >::t()__xcodeml_identity<typename __make_tuple_types<class tuple,0,0,expression>::type>::t()__t){}
public:template<typename __xcodeml_template_type_1_0,bool _PackIsTuple=_PackExpandsToThisTuple<...>::value,typename enable_if<expression,bool>::type=false>tuple(void/*__u*/):__base_(__xcodeml_identity<typename __make_tuple_indices<expression,0>::type>::t()__xcodeml_identity<typename __make_tuple_types<class tuple,expression,0,expression>::type>::t()__xcodeml_identity<typename __make_tuple_indices<expression,expression>::type>::t()__xcodeml_identity<typename __make_tuple_types<class tuple,expression,expression,expression>::type>::t()(std::__1::__xcodeml_template_type_1_0(__u))){}
public:template<typename __xcodeml_template_type_1_0,typename enable_if<expression,bool>::type=false>tuple(void/*__u*/):__base_(__xcodeml_identity<typename __make_tuple_indices<expression,0>::type>::t()__xcodeml_identity<typename __make_tuple_types<class tuple,expression,0,expression>::type>::t()__xcodeml_identity<typename __make_tuple_indices<expression,expression>::type>::t()__xcodeml_identity<typename __make_tuple_types<class tuple,expression,expression,expression>::type>::t()(std::__1::__xcodeml_template_type_1_0(__u))){}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1,typename enable_if<expression,bool>::type=false>tuple(class::std::__1::allocator_arg_t,__xcodeml_template_type_1_0 const&__a,void/*__u*/):__base_(__xcodeml_identity<class::std::__1::allocator_arg_t>::t()__a __xcodeml_identity<typename __make_tuple_indices<expression,0>::type>::t()__xcodeml_identity<typename __make_tuple_types<class tuple,expression,0,expression>::type>::t()__xcodeml_identity<typename __make_tuple_indices<expression,expression>::type>::t()__xcodeml_identity<typename __make_tuple_types<class tuple,expression,expression,expression>::type>::t()(std::__1::__xcodeml_template_type_1_1(__u))){}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1,typename enable_if<expression,bool>::type=false>tuple(class::std::__1::allocator_arg_t,__xcodeml_template_type_1_0 const&__a,void/*__u*/):__base_(__xcodeml_identity<class::std::__1::allocator_arg_t>::t()__a __xcodeml_identity<typename __make_tuple_indices<expression,0>::type>::t()__xcodeml_identity<typename __make_tuple_types<class tuple,expression,0,expression>::type>::t()__xcodeml_identity<typename __make_tuple_indices<expression,expression>::type>::t()__xcodeml_identity<typename __make_tuple_types<class tuple,expression,expression,expression>::type>::t()(std::__1::__xcodeml_template_type_1_1(__u))){}
public:template<typename __xcodeml_template_type_1_0,void/**/ =false>tuple(__xcodeml_template_type_1_0(*__t)):__base_((std::__1::__xcodeml_template_type_1_0(__t))){}
public:template<typename __xcodeml_template_type_1_0,void/**/ =false>tuple(__xcodeml_template_type_1_0 const&__t):__base_(__t){}
public:template<typename __xcodeml_template_type_1_0,void/**/ =false>tuple(__xcodeml_template_type_1_0(*__t)):__base_((std::__1::__xcodeml_template_type_1_0(__t))){}
public:template<typename __xcodeml_template_type_1_0,void/**/ =false>tuple(__xcodeml_template_type_1_0 const&__t):__base_(__t){}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1,typename enable_if<expression,bool>::type=false>tuple(class::std::__1::allocator_arg_t,__xcodeml_template_type_1_0 const&__a,__xcodeml_template_type_1_1(*__t)):__base_(__xcodeml_identity<class::std::__1::allocator_arg_t>::t()__a(std::__1::__xcodeml_template_type_1_1(__t))){}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1,typename enable_if<expression,bool>::type=false>tuple(class::std::__1::allocator_arg_t,__xcodeml_template_type_1_0 const&__a,__xcodeml_template_type_1_1(*__t)):__base_(__xcodeml_identity<class::std::__1::allocator_arg_t>::t()__a(std::__1::__xcodeml_template_type_1_1(__t))){}
public:using _CanCopyAssign=integral_constant<bool,expression>;
public:using _CanMoveAssign=integral_constant<bool,expression>;
public:class tuple&operator=(typename conditional<expression,class tuple,class::std::__1::__nat>::type const&__t){(this->__base_.(__t.__base_));
return(*this);
}
public:class tuple&operator=(typename conditional<expression,class tuple,class::std::__1::__nat>::type(*__t)){(this->__base_.(static_cast<__tuple_impl<typename __make_tuple_indices<expression,0>::type,...> >(__t.__base_)));
return(*this);
}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>class tuple&operator=(__xcodeml_template_type_1_0(*__t)){(this->__base_.((std::__1::__xcodeml_template_type_1_0(__t))));
return(*this);
}
public:void swap(class tuple&__t){(this->__base_.swap(__t.__base_));
}
}
;
;
template<>class tuple<...>{public:
public:tuple();
public:template<typename __xcodeml_template_type_0_0>tuple(class::std::__1::allocator_arg_t,__xcodeml_template_type_0_0 const&){}
public:template<typename __xcodeml_template_type_0_0>tuple(class::std::__1::allocator_arg_t,__xcodeml_template_type_0_0 const&,class tuple const&){}
public:template<typename __xcodeml_template_type_0_0>tuple(array<__xcodeml_template_type_0_0,0>){}
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>tuple(class::std::__1::allocator_arg_t,__xcodeml_template_type_0_0 const&,array<__xcodeml_template_type_0_1,0>){}
public:void swap(class::std::__1::tuple<...>&){}
}
;
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,void>::type swap(tuple<...>,tuple<...>){(__t.swap(__u));
}
template<unsigned long _Ip,typename __xcodeml_template_type_0_1>typename tuple_element<expression,tuple<...> >::type&get(tuple<...>){typedef typename tuple_element<expression,tuple<...> >::type type;
return(static_cast<__tuple_leaf<expression,typename tuple_element<expression,tuple<...> >::type,expression> >(__t.__base_).get());
}
template<unsigned long _Ip,typename __xcodeml_template_type_0_1>typename tuple_element<expression,tuple<...> >::type const&get(tuple<...>){typedef typename tuple_element<expression,tuple<...> >::type type;
return(static_cast<__tuple_leaf<expression,typename tuple_element<expression,tuple<...> >::type,expression> >(__t.__base_).get());
}
template<unsigned long _Ip,typename __xcodeml_template_type_0_1>typename tuple_element<expression,tuple<...> >::type(*get(tuple<...>)){typedef typename tuple_element<expression,tuple<...> >::type type;
return static_cast<typename tuple_element<expression,tuple<...> >::type(*)>((static_cast<__tuple_leaf<expression,typename tuple_element<expression,tuple<...> >::type,expression> >(__t.__base_).get()));
}
template<unsigned long _Ip,typename __xcodeml_template_type_0_1>typename tuple_element<expression,tuple<...> >::type const(*get(tuple<...>)){typedef typename tuple_element<expression,tuple<...> >::type type;
return static_cast<typename tuple_element<expression,tuple<...> >::type const(*)>((static_cast<__tuple_leaf<expression,typename tuple_element<expression,tuple<...> >::type,expression> >(__t.__base_).get()));
}
namespace __find_detail{constexpr unsigned long const __not_found=(-1);
constexpr unsigned long const __ambiguous=(__not_found-1);
unsigned long __find_idx_return(unsigned long __curr_i,unsigned long __res,bool __matches){return((!__matches)?__res:((__res==__not_found)?__curr_i:__ambiguous));
}
template<unsigned long _Nx>unsigned long __find_idx(unsigned long __i,bool const&__matches){return((__i==_Nx)?__not_found:((__i,(((__i+1),__matches)),(__matches)[__i])));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __find_exactly_one_checked{public:constexpr static bool const __matches[]={is_same<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::value};
public:constexpr static unsigned long const value=(__find_detail::(0,__matches));

/* Ignored a member with no access specifier (value!=__not_found)"type not found in type list";*/


/* Ignored a member with no access specifier (value!=__ambiguous)"type occurs more than once in type list";*/

}
;
;
template<typename __xcodeml_template_type_0_0>class __find_exactly_one_checked<__xcodeml_template_type_0_0,...>{
/* Ignored a member with no access specifier (!is_same<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0>::value)"type not in empty type list";*/

}
;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __find_exactly_one_t:public __find_exactly_one_checked<__xcodeml_template_type_0_0,...>{}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0&get(tuple<...>){return(std::__1::__find_exactly_one_t<__xcodeml_template_type_0_0,...>::value(__tup));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0 const&get(tuple<...>){return(std::__1::__find_exactly_one_t<__xcodeml_template_type_0_0,...>::value(__tup));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0(*get(tuple<...>)){return(std::__1::__find_exactly_one_t<__xcodeml_template_type_0_0,...>::value((std::__1::(__tup))));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0 const(*get(tuple<...>)){return(std::__1::__find_exactly_one_t<__xcodeml_template_type_0_0,...>::value((std::__1::(__tup))));
}
template<typename __xcodeml_template_type_0_0>tuple<...>{return __xcodeml_identity<tuple<...> >::t(__t);
}
template<typename __xcodeml_template_type_0_0>class __ignore_t{public:template<typename __xcodeml_template_type_1_0>class __ignore_t const&operator=(__xcodeml_template_type_1_0(*))const{return(*this);
}
}
;
template<>class __ignore_t<unsigned char>{public:template<typename __xcodeml_template_type_0_0>class __ignore_t const&operator=(__xcodeml_template_type_0_0(*))const
}
;
namespace{constexpr class __ignore_t const ignore=__xcodeml_identity<class::std::__1::__ignore_t<unsigned char> >::t();
}
template<typename __xcodeml_template_type_0_0>tuple<...>{return __xcodeml_identity<tuple<...> >::t((std::__1::__xcodeml_template_type_0_0(__t)));
}
template<typename __xcodeml_template_type_0_0>tuple<...>{return __xcodeml_identity<tuple<...> >::t((std::__1::__xcodeml_template_type_0_0(__t)));
}
template <>class::std::__1::tuple<...>forward_as_tuple(){return __xcodeml_identity<class::std::__1::tuple<...> >::t();
}
template<unsigned long _Ip>class __tuple_equal{public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>bool operator()(__xcodeml_template_type_1_0 const&__x,__xcodeml_template_type_1_1 const&__y){return((__xcodeml_identity<__tuple_equal<expression> >::t()(__x,__y))&&((std::__1::(_Ip-1)(__x)),(std::__1::(_Ip-1)(__y))));
}
}
;
;
template<>class __tuple_equal<0>{public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator()(__xcodeml_template_type_0_0 const&,__xcodeml_template_type_0_1 const&){return true;
}
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator==(tuple<...>,tuple<...>){(==)"Can't compare tuples of different sizes";
return(__xcodeml_identity<__tuple_equal<expression> >::t()(__x,__y));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator!=(tuple<...>,tuple<...>){return(!(__x,__y));
}
template<unsigned long _Ip>class __tuple_less{public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>bool operator()(__xcodeml_template_type_1_0 const&__x,__xcodeml_template_type_1_1 const&__y){unsigned long const __idx=(tuple_size<__xcodeml_template_type_1_0>::.value,_Ip);
if(((std::__1::__idx(__x)),(std::__1::__idx(__y)))){return true;};
if(((std::__1::__idx(__y)),(std::__1::__idx(__x)))){return false;};
return(__xcodeml_identity<__tuple_less<expression> >::t()(__x,__y));
}
}
;
;
template<>class __tuple_less<0>{public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator()(__xcodeml_template_type_0_0 const&,__xcodeml_template_type_0_1 const&){return false;
}
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator<(tuple<...>,tuple<...>){(==)"Can't compare tuples of different sizes";
return(__xcodeml_identity<__tuple_less<expression> >::t()(__x,__y));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator>(tuple<...>,tuple<...>){return(__y,__x);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator>=(tuple<...>,tuple<...>){return(!(__x,__y));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator<=(tuple<...>,tuple<...>){return(!(__y,__x));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __tuple_cat_type;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __tuple_cat_type<tuple<...>,__tuple_types<...> >{public:typedef tuple<...>;
}
;
template<typename __xcodeml_template_type_0_0,bool _Is_Tuple0TupleLike,typename __xcodeml_template_type_0_2>class __tuple_cat_return_1{}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __tuple_cat_return_1<tuple<...>,1,...>{public:typedef typename __tuple_cat_type<tuple<...>,typename __make_tuple_types<typename __uncvref<__xcodeml_template_type_0_1>::type,expression,0,expression>::type>::type type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>class __tuple_cat_return_1<tuple<...>,1,...>:public __tuple_cat_return_1<typename __tuple_cat_type<tuple<...>,typename __make_tuple_types<typename __uncvref<__xcodeml_template_type_0_1>::type,expression,0,expression>::type>::type,expression,...>{}
;
template<typename __xcodeml_template_type_0_0>class __tuple_cat_return;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __tuple_cat_return<...>:public __tuple_cat_return_1<class::std::__1::tuple<...>,expression,...>{}
;
template<>class __tuple_cat_return<...>{public:typedef class::std::__1::tuple<...>type;
}
;
class::std::__1::tuple<...>tuple_cat(){return __xcodeml_identity<class::std::__1::tuple<...> >::t();
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>class __tuple_cat_return_ref_imp;
;
template<typename __xcodeml_template_type_0_0,unsigned long _I0,typename __xcodeml_template_type_0_2>class __tuple_cat_return_ref_imp<tuple<...>,__tuple_indices<...>,__xcodeml_template_type_0_2,...>{public:typedef typename remove_reference<__xcodeml_template_type_0_2>::type _T0;
public:typedef tuple<...>;
}
;
template<typename __xcodeml_template_type_0_0,unsigned long _I0,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3,typename __xcodeml_template_type_0_4>class __tuple_cat_return_ref_imp<tuple<...>,__tuple_indices<...>,__xcodeml_template_type_0_2,...>:public __tuple_cat_return_ref_imp<tuple<...>,typename __make_tuple_indices<expression,0>::type,__xcodeml_template_type_0_3,...>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __tuple_cat_return_ref:public __tuple_cat_return_ref_imp<class::std::__1::tuple<...>,typename __make_tuple_indices<expression,0>::type,__xcodeml_template_type_0_0,...>{}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __tuple_cat;
;
template<typename __xcodeml_template_type_0_0,unsigned long _I0,unsigned long _J0>class __tuple_cat<tuple<...>,__tuple_indices<...>,__tuple_indices<...> >{public:template<typename __xcodeml_template_type_1_0>typename __tuple_cat_return_ref<tuple<...>,...>::type operator()(tuple<...>,__xcodeml_template_type_1_0(*__t0)){return(((std::__1::__xcodeml_template_type_0_0((std::__1::_I0(__t)))),(std::__1::_J0((std::__1::__xcodeml_template_type_1_0(__t0))))));
}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1,typename __xcodeml_template_type_1_2>typename __tuple_cat_return_ref<tuple<...>,...>::type operator()(tuple<...>,__xcodeml_template_type_1_0(*__t0),__xcodeml_template_type_1_1(*__t1),void/*__tpls*/){typedef typename remove_reference<__xcodeml_template_type_1_0>::type _T0;
typedef typename remove_reference<__xcodeml_template_type_1_1>::type _T1;
return(__xcodeml_identity<__tuple_cat<tuple<...>,typename __make_tuple_indices<expression,0>::type,typename __make_tuple_indices<expression,0>::type> >::t()((((std::__1::__xcodeml_template_type_0_0((std::__1::_I0(__t)))),(std::__1::_J0((std::__1::__xcodeml_template_type_1_0(__t0)))))),(std::__1::__xcodeml_template_type_1_1(__t1)),(std::__1::__xcodeml_template_type_1_2(__tpls))));
}
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename __tuple_cat_return<...>::type tuple_cat(__xcodeml_template_type_0_0(*__t0),void/*__tpls*/){typedef typename remove_reference<__xcodeml_template_type_0_0>::type _T0;
return(__xcodeml_identity<__tuple_cat<class::std::__1::tuple<...>,class::std::__1::__tuple_indices<...>,typename __make_tuple_indices<expression,0>::type> >::t()(__xcodeml_identity<class::std::__1::tuple<...> >::t(),(std::__1::__xcodeml_template_type_0_0(__t0)),(std::__1::__xcodeml_template_type_0_1(__tpls))));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class uses_allocator<tuple<...>,__xcodeml_template_type_0_1>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1,unsigned long _I1,unsigned long _I2>pair::pair(class::std::__1::piecewise_construct_t,tuple<...>,tuple<...>,__tuple_indices<...>,__tuple_indices<...>):first((std::__1::__xcodeml_template_type_1_0((std::__1::_I1(__first_args))))),second((std::__1::__xcodeml_template_type_1_1((std::__1::_I2(__second_args))))){}
}
}
namespace std{namespace __1{class __libcpp_refstring{private:char const(*__imp_);
private:bool __uses_refcount()const;
public:
public:__libcpp_refstring(char const(*__msg));
public:__libcpp_refstring(class __libcpp_refstring const&__s);
public:class::std::__1::__libcpp_refstring&operator=(class __libcpp_refstring const&__s);
public:~__libcpp_refstring();
public:char const(*c_str()const){return this->__imp_;
}
}
;
}
}
namespace std{class logic_error:public exception{private:
private:class::std::__1::__libcpp_refstring __imp_;
public:
public:logic_error(class basic_string const&);
public:logic_error(char const(*));
public:logic_error(class logic_error const&);
public:class::std::logic_error&operator=(class logic_error const&);
public:virtual~logic_error();
public:virtual char const(*what()const);
}
;
class runtime_error:public exception{private:
private:class::std::__1::__libcpp_refstring __imp_;
public:
public:runtime_error(class basic_string const&);
public:runtime_error(char const(*));
public:runtime_error(class runtime_error const&);
public:class::std::runtime_error&operator=(class runtime_error const&);
public:virtual~runtime_error();
public:virtual char const(*what()const);
}
;
class domain_error:public logic_error{public:
public:domain_error(class basic_string const&__s):logic_error(__s){}
public:domain_error(char const(*__s)):logic_error(__s){}
public:virtual~domain_error();
}
;
class invalid_argument:public logic_error{public:
public:invalid_argument(class basic_string const&__s):logic_error(__s){}
public:invalid_argument(char const(*__s)):logic_error(__s){}
public:virtual~invalid_argument();
}
;
class length_error:public logic_error{public:
public:length_error(class basic_string const&__s):logic_error(__s){}
public:length_error(char const(*__s)):logic_error(__s){}
public:virtual~length_error();
}
;
class out_of_range:public logic_error{public:
public:out_of_range(class basic_string const&__s):logic_error(__s){}
public:out_of_range(char const(*__s)):logic_error(__s){}
public:virtual~out_of_range();
}
;
class range_error:public runtime_error{public:
public:range_error(class basic_string const&__s):runtime_error(__s){}
public:range_error(char const(*__s)):runtime_error(__s){}
public:virtual~range_error();
}
;
class overflow_error:public runtime_error{public:
public:overflow_error(class basic_string const&__s):runtime_error(__s){}
public:overflow_error(char const(*__s)):runtime_error(__s){}
public:virtual~overflow_error();
}
;
class underflow_error:public runtime_error{public:
public:underflow_error(class basic_string const&__s):runtime_error(__s){}
public:underflow_error(char const(*__s)):runtime_error(__s){}
public:virtual~underflow_error();
}
;
}
namespace std{namespace __1{void __throw_runtime_error(char const(*));
void __throw_logic_error(char const(*__msg)){throw((class::std::logic_error)__xcodeml_identity<class::std::logic_error>::t(__msg));
}
void __throw_domain_error(char const(*__msg)){throw((class::std::domain_error)__xcodeml_identity<class::std::domain_error>::t(__msg));
}
void __throw_invalid_argument(char const(*__msg)){throw((class::std::invalid_argument)__xcodeml_identity<class::std::invalid_argument>::t(__msg));
}
void __throw_length_error(char const(*__msg)){throw((class::std::length_error)__xcodeml_identity<class::std::length_error>::t(__msg));
}
void __throw_out_of_range(char const(*__msg)){throw((class::std::out_of_range)__xcodeml_identity<class::std::out_of_range>::t(__msg));
}
void __throw_range_error(char const(*__msg)){throw((class::std::range_error)__xcodeml_identity<class::std::range_error>::t(__msg));
}
void __throw_overflow_error(char const(*__msg)){throw((class::std::overflow_error)__xcodeml_identity<class::std::overflow_error>::t(__msg));
}
void __throw_underflow_error(char const(*__msg)){throw((class::std::underflow_error)__xcodeml_identity<class::std::underflow_error>::t(__msg));
}
}
}
extern"C"{void __assert(char const(*),char const(*),int,char const(*));};

namespace std{namespace __1{enum __legacy_memory_order{__mo_relaxed,__mo_consume,__mo_acquire,__mo_release,__mo_acq_rel,__mo_seq_cst};
typedef unsigned int __memory_order_underlying_t;
enum memory_order{memory_order_relaxed=__mo_relaxed,memory_order_consume=__mo_consume,memory_order_acquire=__mo_acquire,memory_order_release=__mo_release,memory_order_acq_rel=__mo_acq_rel,memory_order_seq_cst=__mo_seq_cst};
typedef enum memory_order memory_order;
is_same::value"unexpected underlying type for std::memory_order";
template<typename __xcodeml_template_type_0_0>class __cxx_atomic_base_impl{public:__cxx_atomic_base_impl();
public:__cxx_atomic_base_impl(__xcodeml_template_type_0_0 value):__a_value(value){}
public:void/*__a_value*/;
}
;
template<>class __cxx_atomic_base_impl<bool>{public:__cxx_atomic_base_impl();
public:__cxx_atomic_base_impl(bool value):__a_value(value){}
public:void/*__a_value*/;
}
;
void __cxx_atomic_thread_fence(enum memory_order __order){(__c11_atomic_thread_fence(static_cast<unsigned int>(__order)));
}
void __cxx_atomic_signal_fence(enum memory_order __order){(__c11_atomic_signal_fence(static_cast<unsigned int>(__order)));
}
template<typename __xcodeml_template_type_0_0>void __cxx_atomic_init(__cxx_atomic_base_impl<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __val){(__c11_atomic_init((&__a.__a_value),__val));
}
template<typename __xcodeml_template_type_0_0>void __cxx_atomic_init(__cxx_atomic_base_impl<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __val){(__c11_atomic_init((&__a.__a_value),__val));
}
template<typename __xcodeml_template_type_0_0>void __cxx_atomic_store(__cxx_atomic_base_impl<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __val,enum memory_order __order){(__c11_atomic_store((&__a.__a_value),__val,static_cast<unsigned int>(__order)));
}
template <>void __cxx_atomic_store(class __cxx_atomic_base_impl volatile(*__a),bool __val,enum memory_order __order){(&__a->__a_value)static_cast<unsigned int>(__order)__val;
}
template<typename __xcodeml_template_type_0_0>void __cxx_atomic_store(__cxx_atomic_base_impl<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __val,enum memory_order __order){(__c11_atomic_store((&__a.__a_value),__val,static_cast<unsigned int>(__order)));
}
template <>void __cxx_atomic_store(class::std::__1::__cxx_atomic_base_impl<bool>(*__a),bool __val,enum memory_order __order){(&__a->__a_value)static_cast<unsigned int>(__order)__val;
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 __cxx_atomic_load(__cxx_atomic_base_impl<__xcodeml_template_type_0_0>,enum memory_order __order){using __ptr_type=typename remove_const<decltype ()>::type(*);
return(__c11_atomic_load(const_cast<typename remove_const<decltype ()>::type(*)>((&__a.__a_value)),static_cast<unsigned int>(__order)));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 __cxx_atomic_load(__cxx_atomic_base_impl<__xcodeml_template_type_0_0>,enum memory_order __order){using __ptr_type=typename remove_const<decltype ()>::type(*);
return(__c11_atomic_load(const_cast<typename remove_const<decltype ()>::type(*)>((&__a.__a_value)),static_cast<unsigned int>(__order)));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 __cxx_atomic_exchange(__cxx_atomic_base_impl<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __value,enum memory_order __order){return(__c11_atomic_exchange((&__a.__a_value),__value,static_cast<unsigned int>(__order)));
}
template <>bool __cxx_atomic_exchange(class __cxx_atomic_base_impl volatile(*__a),bool __value,enum memory_order __order){return(&__a->__a_value)static_cast<unsigned int>(__order)__value;
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 __cxx_atomic_exchange(__cxx_atomic_base_impl<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __value,enum memory_order __order){return(__c11_atomic_exchange((&__a.__a_value),__value,static_cast<unsigned int>(__order)));
}
template <>bool __cxx_atomic_exchange(class::std::__1::__cxx_atomic_base_impl<bool>(*__a),bool __value,enum memory_order __order){return(&__a->__a_value)static_cast<unsigned int>(__order)__value;
}
template<typename __xcodeml_template_type_0_0>bool __cxx_atomic_compare_exchange_strong(__cxx_atomic_base_impl<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0(*__expected),__xcodeml_template_type_0_0 __value,enum memory_order __success,enum memory_order __failure){return(__c11_atomic_compare_exchange_strong((&__a.__a_value),__expected,__value,static_cast<unsigned int>(__success),static_cast<unsigned int>(__failure)));
}
template<typename __xcodeml_template_type_0_0>bool __cxx_atomic_compare_exchange_strong(__cxx_atomic_base_impl<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0(*__expected),__xcodeml_template_type_0_0 __value,enum memory_order __success,enum memory_order __failure){return(__c11_atomic_compare_exchange_strong((&__a.__a_value),__expected,__value,static_cast<unsigned int>(__success),static_cast<unsigned int>(__failure)));
}
template<typename __xcodeml_template_type_0_0>bool __cxx_atomic_compare_exchange_weak(__cxx_atomic_base_impl<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0(*__expected),__xcodeml_template_type_0_0 __value,enum memory_order __success,enum memory_order __failure){return(__c11_atomic_compare_exchange_weak((&__a.__a_value),__expected,__value,static_cast<unsigned int>(__success),static_cast<unsigned int>(__failure)));
}
template<typename __xcodeml_template_type_0_0>bool __cxx_atomic_compare_exchange_weak(__cxx_atomic_base_impl<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0(*__expected),__xcodeml_template_type_0_0 __value,enum memory_order __success,enum memory_order __failure){return(__c11_atomic_compare_exchange_weak((&__a.__a_value),__expected,__value,static_cast<unsigned int>(__success),static_cast<unsigned int>(__failure)));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 __cxx_atomic_fetch_add(__cxx_atomic_base_impl<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __delta,enum memory_order __order){return(__c11_atomic_fetch_add((&__a.__a_value),__delta,static_cast<unsigned int>(__order)));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 __cxx_atomic_fetch_add(__cxx_atomic_base_impl<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __delta,enum memory_order __order){return(__c11_atomic_fetch_add((&__a.__a_value),__delta,static_cast<unsigned int>(__order)));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0(*__cxx_atomic_fetch_add(__cxx_atomic_base_impl<__xcodeml_template_type_0_0(*)>,long __delta,enum memory_order __order)){return(__c11_atomic_fetch_add((&__a.__a_value),__delta,static_cast<unsigned int>(__order)));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0(*__cxx_atomic_fetch_add(__cxx_atomic_base_impl<__xcodeml_template_type_0_0(*)>,long __delta,enum memory_order __order)){return(__c11_atomic_fetch_add((&__a.__a_value),__delta,static_cast<unsigned int>(__order)));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 __cxx_atomic_fetch_sub(__cxx_atomic_base_impl<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __delta,enum memory_order __order){return(__c11_atomic_fetch_sub((&__a.__a_value),__delta,static_cast<unsigned int>(__order)));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 __cxx_atomic_fetch_sub(__cxx_atomic_base_impl<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __delta,enum memory_order __order){return(__c11_atomic_fetch_sub((&__a.__a_value),__delta,static_cast<unsigned int>(__order)));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0(*__cxx_atomic_fetch_sub(__cxx_atomic_base_impl<__xcodeml_template_type_0_0(*)>,long __delta,enum memory_order __order)){return(__c11_atomic_fetch_sub((&__a.__a_value),__delta,static_cast<unsigned int>(__order)));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0(*__cxx_atomic_fetch_sub(__cxx_atomic_base_impl<__xcodeml_template_type_0_0(*)>,long __delta,enum memory_order __order)){return(__c11_atomic_fetch_sub((&__a.__a_value),__delta,static_cast<unsigned int>(__order)));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 __cxx_atomic_fetch_and(__cxx_atomic_base_impl<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __pattern,enum memory_order __order){return(__c11_atomic_fetch_and((&__a.__a_value),__pattern,static_cast<unsigned int>(__order)));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 __cxx_atomic_fetch_and(__cxx_atomic_base_impl<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __pattern,enum memory_order __order){return(__c11_atomic_fetch_and((&__a.__a_value),__pattern,static_cast<unsigned int>(__order)));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 __cxx_atomic_fetch_or(__cxx_atomic_base_impl<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __pattern,enum memory_order __order){return(__c11_atomic_fetch_or((&__a.__a_value),__pattern,static_cast<unsigned int>(__order)));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 __cxx_atomic_fetch_or(__cxx_atomic_base_impl<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __pattern,enum memory_order __order){return(__c11_atomic_fetch_or((&__a.__a_value),__pattern,static_cast<unsigned int>(__order)));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 __cxx_atomic_fetch_xor(__cxx_atomic_base_impl<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __pattern,enum memory_order __order){return(__c11_atomic_fetch_xor((&__a.__a_value),__pattern,static_cast<unsigned int>(__order)));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 __cxx_atomic_fetch_xor(__cxx_atomic_base_impl<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __pattern,enum memory_order __order){return(__c11_atomic_fetch_xor((&__a.__a_value),__pattern,static_cast<unsigned int>(__order)));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 kill_dependency(__xcodeml_template_type_0_0 __y){return __y;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __cxx_atomic_impl:public __xcodeml_template_type_0_1{public:__cxx_atomic_impl();
public:__cxx_atomic_impl(__xcodeml_template_type_0_0 value):(value){}
}
;
template<>class __cxx_atomic_impl<bool,class::std::__1::__cxx_atomic_base_impl<bool> >:public __cxx_atomic_base_impl<bool>{public:__cxx_atomic_impl();
public:__cxx_atomic_impl(bool value):__cxx_atomic_base_impl(value){}
}
;
template<typename __xcodeml_template_type_0_0,bool=(is_integral<__xcodeml_template_type_0_0>::value&&(!is_same<__xcodeml_template_type_0_0,bool>::value))>class __atomic_base{public:__cxx_atomic_impl<__xcodeml_template_type_0_0,__cxx_atomic_base_impl<__xcodeml_template_type_0_0> >;
public:bool is_lock_free()const volatile{return(__c11_atomic_is_lock_free((sizeof(__xcodeml_template_type_0_0))));
}
public:bool is_lock_free()const{return(static_cast<class __atomic_base volatile const(*)>(this).is_lock_free());
}
public:void store(__xcodeml_template_type_0_0 __d,enum memory_order __m)volatile{(((&this->__a_),__d,__m));
}
public:void store(__xcodeml_template_type_0_0 __d,enum memory_order __m){(((&this->__a_),__d,__m));
}
public:__xcodeml_template_type_0_0 load(enum memory_order __m)const volatile{return(((&this->__a_),__m));
}
public:__xcodeml_template_type_0_0 load(enum memory_order __m)const{return(((&this->__a_),__m));
}
public:operator __xcodeml_template_type_0_0()const volatile{return(());
}
public:operator __xcodeml_template_type_0_0()const{return(());
}
public:__xcodeml_template_type_0_0 exchange(__xcodeml_template_type_0_0 __d,enum memory_order __m)volatile{return(((&this->__a_),__d,__m));
}
public:__xcodeml_template_type_0_0 exchange(__xcodeml_template_type_0_0 __d,enum memory_order __m){return(((&this->__a_),__d,__m));
}
public:bool compare_exchange_weak(__xcodeml_template_type_0_0&__e,__xcodeml_template_type_0_0 __d,enum memory_order __s,enum memory_order __f)volatile{return(((&this->__a_),(&__e),__d,__s,__f));
}
public:bool compare_exchange_weak(__xcodeml_template_type_0_0&__e,__xcodeml_template_type_0_0 __d,enum memory_order __s,enum memory_order __f){return(((&this->__a_),(&__e),__d,__s,__f));
}
public:bool compare_exchange_strong(__xcodeml_template_type_0_0&__e,__xcodeml_template_type_0_0 __d,enum memory_order __s,enum memory_order __f)volatile{return(((&this->__a_),(&__e),__d,__s,__f));
}
public:bool compare_exchange_strong(__xcodeml_template_type_0_0&__e,__xcodeml_template_type_0_0 __d,enum memory_order __s,enum memory_order __f){return(((&this->__a_),(&__e),__d,__s,__f));
}
public:bool compare_exchange_weak(__xcodeml_template_type_0_0&__e,__xcodeml_template_type_0_0 __d,enum memory_order __m)volatile{return(((&this->__a_),(&__e),__d,__m,__m));
}
public:bool compare_exchange_weak(__xcodeml_template_type_0_0&__e,__xcodeml_template_type_0_0 __d,enum memory_order __m){return(((&this->__a_),(&__e),__d,__m,__m));
}
public:bool compare_exchange_strong(__xcodeml_template_type_0_0&__e,__xcodeml_template_type_0_0 __d,enum memory_order __m)volatile{return(((&this->__a_),(&__e),__d,__m,__m));
}
public:bool compare_exchange_strong(__xcodeml_template_type_0_0&__e,__xcodeml_template_type_0_0 __d,enum memory_order __m){return(((&this->__a_),(&__e),__d,__m,__m));
}
public:__atomic_base();
public:__atomic_base(__xcodeml_template_type_0_0 __d):__a_(__d){}
public:__atomic_base(class __atomic_base const&);
public:class __atomic_base&operator=(class __atomic_base const&);
public:class __atomic_base&operator=(class __atomic_base const&)volatile;
}
;
;
template<typename __xcodeml_template_type_0_0>class __atomic_base<__xcodeml_template_type_0_0,1>:public __atomic_base<__xcodeml_template_type_0_0,0>{public:typedef __atomic_base<__xcodeml_template_type_0_0,0>;
public:__atomic_base();
public:__atomic_base(__xcodeml_template_type_0_0 __d):(__d){}
public:__xcodeml_template_type_0_0 fetch_add(__xcodeml_template_type_0_0 __op,enum memory_order __m)volatile{return(((&this.__a_),__op,__m));
}
public:__xcodeml_template_type_0_0 fetch_add(__xcodeml_template_type_0_0 __op,enum memory_order __m){return(((&this.__a_),__op,__m));
}
public:__xcodeml_template_type_0_0 fetch_sub(__xcodeml_template_type_0_0 __op,enum memory_order __m)volatile{return(((&this.__a_),__op,__m));
}
public:__xcodeml_template_type_0_0 fetch_sub(__xcodeml_template_type_0_0 __op,enum memory_order __m){return(((&this.__a_),__op,__m));
}
public:__xcodeml_template_type_0_0 fetch_and(__xcodeml_template_type_0_0 __op,enum memory_order __m)volatile{return(((&this.__a_),__op,__m));
}
public:__xcodeml_template_type_0_0 fetch_and(__xcodeml_template_type_0_0 __op,enum memory_order __m){return(((&this.__a_),__op,__m));
}
public:__xcodeml_template_type_0_0 fetch_or(__xcodeml_template_type_0_0 __op,enum memory_order __m)volatile{return(((&this.__a_),__op,__m));
}
public:__xcodeml_template_type_0_0 fetch_or(__xcodeml_template_type_0_0 __op,enum memory_order __m){return(((&this.__a_),__op,__m));
}
public:__xcodeml_template_type_0_0 fetch_xor(__xcodeml_template_type_0_0 __op,enum memory_order __m)volatile{return(((&this.__a_),__op,__m));
}
public:__xcodeml_template_type_0_0 fetch_xor(__xcodeml_template_type_0_0 __op,enum memory_order __m){return(((&this.__a_),__op,__m));
}
public:__xcodeml_template_type_0_0 operator++(int)volatile{return((__xcodeml_identity<__xcodeml_template_type_0_0>::t(1)));
}
public:__xcodeml_template_type_0_0 operator++(int){return((__xcodeml_identity<__xcodeml_template_type_0_0>::t(1)));
}
public:__xcodeml_template_type_0_0 operator--(int)volatile{return((__xcodeml_identity<__xcodeml_template_type_0_0>::t(1)));
}
public:__xcodeml_template_type_0_0 operator--(int){return((__xcodeml_identity<__xcodeml_template_type_0_0>::t(1)));
}
public:__xcodeml_template_type_0_0 operator++()volatile{return(((__xcodeml_identity<__xcodeml_template_type_0_0>::t(1))),__xcodeml_identity<__xcodeml_template_type_0_0>::t(1));
}
public:__xcodeml_template_type_0_0 operator++(){return(((__xcodeml_identity<__xcodeml_template_type_0_0>::t(1))),__xcodeml_identity<__xcodeml_template_type_0_0>::t(1));
}
public:__xcodeml_template_type_0_0 operator--()volatile{return(((__xcodeml_identity<__xcodeml_template_type_0_0>::t(1))),__xcodeml_identity<__xcodeml_template_type_0_0>::t(1));
}
public:__xcodeml_template_type_0_0 operator--(){return(((__xcodeml_identity<__xcodeml_template_type_0_0>::t(1))),__xcodeml_identity<__xcodeml_template_type_0_0>::t(1));
}
public:__xcodeml_template_type_0_0 operator+=(__xcodeml_template_type_0_0 __op)volatile{return(((__op)),__op);
}
public:__xcodeml_template_type_0_0 operator+=(__xcodeml_template_type_0_0 __op){return(((__op)),__op);
}
public:__xcodeml_template_type_0_0 operator-=(__xcodeml_template_type_0_0 __op)volatile{return(((__op)),__op);
}
public:__xcodeml_template_type_0_0 operator-=(__xcodeml_template_type_0_0 __op){return(((__op)),__op);
}
public:__xcodeml_template_type_0_0 operator&=(__xcodeml_template_type_0_0 __op)volatile{return(((__op))&__op);
}
public:__xcodeml_template_type_0_0 operator&=(__xcodeml_template_type_0_0 __op){return(((__op))&__op);
}
public:__xcodeml_template_type_0_0 operator|=(__xcodeml_template_type_0_0 __op)volatile{return(((__op))|__op);
}
public:__xcodeml_template_type_0_0 operator|=(__xcodeml_template_type_0_0 __op){return(((__op))|__op);
}
public:__xcodeml_template_type_0_0 operator^=(__xcodeml_template_type_0_0 __op)volatile{return(((__op))^__op);
}
public:__xcodeml_template_type_0_0 operator^=(__xcodeml_template_type_0_0 __op){return(((__op))^__op);
}
}
;
template<typename __xcodeml_template_type_0_0>class atomic:public __atomic_base<__xcodeml_template_type_0_0,expression>{public:typedef __atomic_base<__xcodeml_template_type_0_0,expression>;
public:atomic();
public:atomic(__xcodeml_template_type_0_0 __d):(__d){}
public:__xcodeml_template_type_0_0 operator=(__xcodeml_template_type_0_0 __d)volatile{(__atomic_base<__xcodeml_template_type_0_0,expression>::.store(__d));
return __d;
}
public:__xcodeml_template_type_0_0 operator=(__xcodeml_template_type_0_0 __d){(__atomic_base<__xcodeml_template_type_0_0,expression>::.store(__d));
return __d;
}
}
;
template<>class atomic template<>class atomic template<>class atomic template<>class atomic template<>class atomic template<>class atomic template<>class atomic template<>class atomic template<>class atomic template<>class atomic template<>class atomic template<>class atomic template<>class atomic template<>class atomic template<>class atomic;
template<typename __xcodeml_template_type_0_0>class atomic<__xcodeml_template_type_0_0(*)>:public __atomic_base<__xcodeml_template_type_0_0(*),expression>{public:typedef __atomic_base<__xcodeml_template_type_0_0(*),expression>;
public:atomic();
public:atomic(__xcodeml_template_type_0_0(*__d)):(__d){}
public:__xcodeml_template_type_0_0(*operator=(__xcodeml_template_type_0_0(*__d))volatile){(__atomic_base<__xcodeml_template_type_0_0(*),expression>::.store(__d));
return __d;
}
public:__xcodeml_template_type_0_0(*operator=(__xcodeml_template_type_0_0(*__d))){(__atomic_base<__xcodeml_template_type_0_0(*),expression>::.store(__d));
return __d;
}
public:__xcodeml_template_type_0_0(*fetch_add(long __op,enum memory_order __m)volatile){return(((&this.__a_),__op,__m));
}
public:__xcodeml_template_type_0_0(*fetch_add(long __op,enum memory_order __m)){return(((&this.__a_),__op,__m));
}
public:__xcodeml_template_type_0_0(*fetch_sub(long __op,enum memory_order __m)volatile){return(((&this.__a_),__op,__m));
}
public:__xcodeml_template_type_0_0(*fetch_sub(long __op,enum memory_order __m)){return(((&this.__a_),__op,__m));
}
public:__xcodeml_template_type_0_0(*operator++(int)volatile){return((1));
}
public:__xcodeml_template_type_0_0(*operator++(int)){return((1));
}
public:__xcodeml_template_type_0_0(*operator--(int)volatile){return((1));
}
public:__xcodeml_template_type_0_0(*operator--(int)){return((1));
}
public:__xcodeml_template_type_0_0(*operator++()volatile){return(((1)),1);
}
public:__xcodeml_template_type_0_0(*operator++()){return(((1)),1);
}
public:__xcodeml_template_type_0_0(*operator--()volatile){return(((1)),1);
}
public:__xcodeml_template_type_0_0(*operator--()){return(((1)),1);
}
public:__xcodeml_template_type_0_0(*operator+=(long __op)volatile){return(((__op)),__op);
}
public:__xcodeml_template_type_0_0(*operator+=(long __op)){return(((__op)),__op);
}
public:__xcodeml_template_type_0_0(*operator-=(long __op)volatile){return(((__op)),__op);
}
public:__xcodeml_template_type_0_0(*operator-=(long __op)){return(((__op)),__op);
}
}
;
template<typename __xcodeml_template_type_0_0>bool atomic_is_lock_free(atomic<__xcodeml_template_type_0_0>){return(__o.is_lock_free());
}
template<typename __xcodeml_template_type_0_0>bool atomic_is_lock_free(atomic<__xcodeml_template_type_0_0>){return(__o.is_lock_free());
}
template<typename __xcodeml_template_type_0_0>void atomic_init(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __d){(((&__o.__a_),__d));
}
template<typename __xcodeml_template_type_0_0>void atomic_init(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __d){(((&__o.__a_),__d));
}
template<typename __xcodeml_template_type_0_0>void atomic_store(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __d){(__o.store(__d));
}
template<typename __xcodeml_template_type_0_0>void atomic_store(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __d){(__o.store(__d));
}
template<typename __xcodeml_template_type_0_0>void atomic_store_explicit(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __d,enum memory_order __m){(__o.store(__d,__m));
}
template<typename __xcodeml_template_type_0_0>void atomic_store_explicit(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __d,enum memory_order __m){(__o.store(__d,__m));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 atomic_load(atomic<__xcodeml_template_type_0_0>){return(__o.load());
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 atomic_load(atomic<__xcodeml_template_type_0_0>){return(__o.load());
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 atomic_load_explicit(atomic<__xcodeml_template_type_0_0>,enum memory_order __m){return(__o.load(__m));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 atomic_load_explicit(atomic<__xcodeml_template_type_0_0>,enum memory_order __m){return(__o.load(__m));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 atomic_exchange(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __d){return(__o.exchange(__d));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 atomic_exchange(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __d){return(__o.exchange(__d));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 atomic_exchange_explicit(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __d,enum memory_order __m){return(__o.exchange(__d,__m));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 atomic_exchange_explicit(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __d,enum memory_order __m){return(__o.exchange(__d,__m));
}
template<typename __xcodeml_template_type_0_0>bool atomic_compare_exchange_weak(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0(*__e),__xcodeml_template_type_0_0 __d){return(__o.compare_exchange_weak((*__e),__d));
}
template<typename __xcodeml_template_type_0_0>bool atomic_compare_exchange_weak(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0(*__e),__xcodeml_template_type_0_0 __d){return(__o.compare_exchange_weak((*__e),__d));
}
template<typename __xcodeml_template_type_0_0>bool atomic_compare_exchange_strong(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0(*__e),__xcodeml_template_type_0_0 __d){return(__o.compare_exchange_strong((*__e),__d));
}
template<typename __xcodeml_template_type_0_0>bool atomic_compare_exchange_strong(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0(*__e),__xcodeml_template_type_0_0 __d){return(__o.compare_exchange_strong((*__e),__d));
}
template<typename __xcodeml_template_type_0_0>bool atomic_compare_exchange_weak_explicit(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0(*__e),__xcodeml_template_type_0_0 __d,enum memory_order __s,enum memory_order __f){return(__o.compare_exchange_weak((*__e),__d,__s,__f));
}
template<typename __xcodeml_template_type_0_0>bool atomic_compare_exchange_weak_explicit(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0(*__e),__xcodeml_template_type_0_0 __d,enum memory_order __s,enum memory_order __f){return(__o.compare_exchange_weak((*__e),__d,__s,__f));
}
template<typename __xcodeml_template_type_0_0>bool atomic_compare_exchange_strong_explicit(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0(*__e),__xcodeml_template_type_0_0 __d,enum memory_order __s,enum memory_order __f){return(__o.compare_exchange_strong((*__e),__d,__s,__f));
}
template<typename __xcodeml_template_type_0_0>bool atomic_compare_exchange_strong_explicit(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0(*__e),__xcodeml_template_type_0_0 __d,enum memory_order __s,enum memory_order __f){return(__o.compare_exchange_strong((*__e),__d,__s,__f));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,__xcodeml_template_type_0_0>::type atomic_fetch_add(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __op){return(__o.fetch_add(__op));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,__xcodeml_template_type_0_0>::type atomic_fetch_add(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __op){return(__o.fetch_add(__op));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0(*atomic_fetch_add(atomic<__xcodeml_template_type_0_0(*)>,long __op)){return(__o.fetch_add(__op));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0(*atomic_fetch_add(atomic<__xcodeml_template_type_0_0(*)>,long __op)){return(__o.fetch_add(__op));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,__xcodeml_template_type_0_0>::type atomic_fetch_add_explicit(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __op,enum memory_order __m){return(__o.fetch_add(__op,__m));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,__xcodeml_template_type_0_0>::type atomic_fetch_add_explicit(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __op,enum memory_order __m){return(__o.fetch_add(__op,__m));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0(*atomic_fetch_add_explicit(atomic<__xcodeml_template_type_0_0(*)>,long __op,enum memory_order __m)){return(__o.fetch_add(__op,__m));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0(*atomic_fetch_add_explicit(atomic<__xcodeml_template_type_0_0(*)>,long __op,enum memory_order __m)){return(__o.fetch_add(__op,__m));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,__xcodeml_template_type_0_0>::type atomic_fetch_sub(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __op){return(__o.fetch_sub(__op));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,__xcodeml_template_type_0_0>::type atomic_fetch_sub(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __op){return(__o.fetch_sub(__op));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0(*atomic_fetch_sub(atomic<__xcodeml_template_type_0_0(*)>,long __op)){return(__o.fetch_sub(__op));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0(*atomic_fetch_sub(atomic<__xcodeml_template_type_0_0(*)>,long __op)){return(__o.fetch_sub(__op));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,__xcodeml_template_type_0_0>::type atomic_fetch_sub_explicit(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __op,enum memory_order __m){return(__o.fetch_sub(__op,__m));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,__xcodeml_template_type_0_0>::type atomic_fetch_sub_explicit(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __op,enum memory_order __m){return(__o.fetch_sub(__op,__m));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0(*atomic_fetch_sub_explicit(atomic<__xcodeml_template_type_0_0(*)>,long __op,enum memory_order __m)){return(__o.fetch_sub(__op,__m));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0(*atomic_fetch_sub_explicit(atomic<__xcodeml_template_type_0_0(*)>,long __op,enum memory_order __m)){return(__o.fetch_sub(__op,__m));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,__xcodeml_template_type_0_0>::type atomic_fetch_and(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __op){return(__o.fetch_and(__op));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,__xcodeml_template_type_0_0>::type atomic_fetch_and(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __op){return(__o.fetch_and(__op));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,__xcodeml_template_type_0_0>::type atomic_fetch_and_explicit(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __op,enum memory_order __m){return(__o.fetch_and(__op,__m));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,__xcodeml_template_type_0_0>::type atomic_fetch_and_explicit(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __op,enum memory_order __m){return(__o.fetch_and(__op,__m));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,__xcodeml_template_type_0_0>::type atomic_fetch_or(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __op){return(__o.fetch_or(__op));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,__xcodeml_template_type_0_0>::type atomic_fetch_or(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __op){return(__o.fetch_or(__op));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,__xcodeml_template_type_0_0>::type atomic_fetch_or_explicit(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __op,enum memory_order __m){return(__o.fetch_or(__op,__m));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,__xcodeml_template_type_0_0>::type atomic_fetch_or_explicit(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __op,enum memory_order __m){return(__o.fetch_or(__op,__m));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,__xcodeml_template_type_0_0>::type atomic_fetch_xor(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __op){return(__o.fetch_xor(__op));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,__xcodeml_template_type_0_0>::type atomic_fetch_xor(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __op){return(__o.fetch_xor(__op));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,__xcodeml_template_type_0_0>::type atomic_fetch_xor_explicit(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __op,enum memory_order __m){return(__o.fetch_xor(__op,__m));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,__xcodeml_template_type_0_0>::type atomic_fetch_xor_explicit(atomic<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_0 __op,enum memory_order __m){return(__o.fetch_xor(__op,__m));
}
class atomic_flag{public:class::std::__1::__cxx_atomic_impl<bool,class::std::__1::__cxx_atomic_base_impl<bool> >__a_;
public:bool test_and_set(enum memory_order __m)volatile{return(__cxx_atomic_exchange((&this->__a_),((bool)true),__m));
}
public:bool test_and_set(enum memory_order __m){return(__cxx_atomic_exchange((&this->__a_),((bool)true),__m));
}
public:void clear(enum memory_order __m)volatile{(__cxx_atomic_store((&this->__a_),((bool)false),__m));
}
public:void clear(enum memory_order __m){(__cxx_atomic_store((&this->__a_),((bool)false),__m));
}
public:atomic_flag();
public:atomic_flag(bool __b):__a_(__b){}
public:atomic_flag(class atomic_flag const&);
public:class::std::__1::atomic_flag&operator=(class atomic_flag const&);
public:class::std::__1::atomic_flag&operator=(class atomic_flag const&)volatile;
}
;
typedef class::std::__1::atomic_flag atomic_flag;
bool atomic_flag_test_and_set(class atomic_flag volatile(*__o)){return(__o->test_and_set(memory_order_seq_cst));
}
bool atomic_flag_test_and_set(class::std::__1::atomic_flag(*__o)){return(__o->test_and_set(memory_order_seq_cst));
}
bool atomic_flag_test_and_set_explicit(class atomic_flag volatile(*__o),enum memory_order __m){return(__o->test_and_set(__m));
}
bool atomic_flag_test_and_set_explicit(class::std::__1::atomic_flag(*__o),enum memory_order __m){return(__o->test_and_set(__m));
}
void atomic_flag_clear(class atomic_flag volatile(*__o)){(__o->clear(memory_order_seq_cst));
}
void atomic_flag_clear(class::std::__1::atomic_flag(*__o)){(__o->clear(memory_order_seq_cst));
}
void atomic_flag_clear_explicit(class atomic_flag volatile(*__o),enum memory_order __m){(__o->clear(__m));
}
void atomic_flag_clear_explicit(class::std::__1::atomic_flag(*__o),enum memory_order __m){(__o->clear(__m));
}
void atomic_thread_fence(enum memory_order __m){(__cxx_atomic_thread_fence(__m));
}
void atomic_signal_fence(enum memory_order __m){(__cxx_atomic_signal_fence(__m));
}
typedef class::std::__1::atomic<bool>atomic_bool;
typedef class::std::__1::atomic<char>atomic_char;
typedef class::std::__1::atomic<signed char>atomic_schar;
typedef class::std::__1::atomic<unsigned char>atomic_uchar;
typedef class::std::__1::atomic<short>atomic_short;
typedef class::std::__1::atomic<unsigned short>atomic_ushort;
typedef class::std::__1::atomic<int>atomic_int;
typedef class::std::__1::atomic<unsigned int>atomic_uint;
typedef class::std::__1::atomic<long>atomic_long;
typedef class::std::__1::atomic<unsigned long>atomic_ulong;
typedef class::std::__1::atomic<long long>atomic_llong;
typedef class::std::__1::atomic<unsigned long long>atomic_ullong;
typedef class::std::__1::atomic<char16_t>atomic_char16_t;
typedef class::std::__1::atomic<char32_t>atomic_char32_t;
typedef class::std::__1::atomic<wchar_t>atomic_wchar_t;
typedef class::std::__1::atomic<signed char>atomic_int_least8_t;
typedef class::std::__1::atomic<unsigned char>atomic_uint_least8_t;
typedef class::std::__1::atomic<short>atomic_int_least16_t;
typedef class::std::__1::atomic<unsigned short>atomic_uint_least16_t;
typedef class::std::__1::atomic<int>atomic_int_least32_t;
typedef class::std::__1::atomic<unsigned int>atomic_uint_least32_t;
typedef class::std::__1::atomic<long>atomic_int_least64_t;
typedef class::std::__1::atomic<unsigned long>atomic_uint_least64_t;
typedef class::std::__1::atomic<int>atomic_int_fast8_t;
typedef class::std::__1::atomic<unsigned int>atomic_uint_fast8_t;
typedef class::std::__1::atomic<int>atomic_int_fast16_t;
typedef class::std::__1::atomic<unsigned int>atomic_uint_fast16_t;
typedef class::std::__1::atomic<int>atomic_int_fast32_t;
typedef class::std::__1::atomic<unsigned int>atomic_uint_fast32_t;
typedef class::std::__1::atomic<long>atomic_int_fast64_t;
typedef class::std::__1::atomic<unsigned long>atomic_uint_fast64_t;
typedef class::std::__1::atomic<signed char>atomic_int8_t;
typedef class::std::__1::atomic<unsigned char>atomic_uint8_t;
typedef class::std::__1::atomic<short>atomic_int16_t;
typedef class::std::__1::atomic<unsigned short>atomic_uint16_t;
typedef class::std::__1::atomic<int>atomic_int32_t;
typedef class::std::__1::atomic<unsigned int>atomic_uint32_t;
typedef class::std::__1::atomic<long>atomic_int64_t;
typedef class::std::__1::atomic<unsigned long>atomic_uint64_t;
typedef class::std::__1::atomic<long>atomic_intptr_t;
typedef class::std::__1::atomic<unsigned long>atomic_uintptr_t;
typedef class::std::__1::atomic<unsigned long>atomic_size_t;
typedef class::std::__1::atomic<long>atomic_ptrdiff_t;
typedef class::std::__1::atomic<long>atomic_intmax_t;
typedef class::std::__1::atomic<unsigned long>atomic_uintmax_t;
}
}
namespace std{namespace __1{template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 __libcpp_relaxed_load(__xcodeml_template_type_0_0 const(*__value)){return(__atomic_load_n(__value,0));
}
template <>long __libcpp_relaxed_load(long const(*__value)){return __value 0;
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 __libcpp_acquire_load(__xcodeml_template_type_0_0 const(*__value)){return(__atomic_load_n(__value,2));
}
template<typename __xcodeml_template_type_0_0>class allocator;
;
template<>class allocator<void>{public:
public:typedef void(*pointer);
public:typedef void const(*const_pointer);
public:typedef void value_type;
public:template<typename __xcodeml_template_type_0_0>class rebind{public:typedef allocator<__xcodeml_template_type_0_0>;
}
;
;
}
;
template<>class allocator<void const>{public:
public:typedef void const(*pointer);
public:typedef void const(*const_pointer);
public:typedef void const value_type;
public:template<typename __xcodeml_template_type_0_0>class rebind{public:typedef allocator<__xcodeml_template_type_0_0>;
}
;
;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __has_element_type:public integral_constant<bool,0>{}
;
;
template<typename __xcodeml_template_type_0_0>class __has_element_type<__xcodeml_template_type_0_0,typename __void_t<typename __xcodeml_template_type_0_0::element_type>::type>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0,bool=__has_element_type<__xcodeml_template_type_0_0,void>::value>class __pointer_traits_element_type;
;
template<typename __xcodeml_template_type_0_0>class __pointer_traits_element_type<__xcodeml_template_type_0_0,1>{public:typedef typename __xcodeml_template_type_0_0::element_type type;
}
;
template<typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __pointer_traits_element_type< <__xcodeml_template_type_0_1,...>,1>{public:typedef typename <__xcodeml_template_type_0_1,...>::element_type type;
}
;
template<typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __pointer_traits_element_type< <__xcodeml_template_type_0_1,...>,0>{public:typedef __xcodeml_template_type_0_1 type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __has_difference_type:public integral_constant<bool,0>{}
;
template<>class __has_difference_type<class::std::__1::allocator<int>,void>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class __has_difference_type<__xcodeml_template_type_0_0,typename __void_t<typename __xcodeml_template_type_0_0::difference_type>::type>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0,bool=__has_difference_type<__xcodeml_template_type_0_0,void>::value>class __pointer_traits_difference_type{public:typedef long type;
}
;
;
template<typename __xcodeml_template_type_0_0>class __pointer_traits_difference_type<__xcodeml_template_type_0_0,1>{public:typedef typename __xcodeml_template_type_0_0::difference_type type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __has_rebind{private:
private:class __two{public:char __lx;
public:char __lxx;
}
;
private:template<typename __xcodeml_template_type_1_0>static class::std::__1::__has_rebind::__two __test(...)
private:template<typename __xcodeml_template_type_1_0>static char __test(void/*(*)*/)
public:
public:static bool const value=((sizeof((__xcodeml_template_type_0_0(0))))==1);
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,bool=__has_rebind<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::value>class __pointer_traits_rebind{public:typedef void/*type*/;
}
;
;
template<typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>class __pointer_traits_rebind< <__xcodeml_template_type_0_1,...>,__xcodeml_template_type_0_3,1>{public:typedef void/*type*/;
}
;
template<typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>class __pointer_traits_rebind< <__xcodeml_template_type_0_1,...>,__xcodeml_template_type_0_3,0>{public:typedef<__xcodeml_template_type_0_3,...>;
}
;
template<typename __xcodeml_template_type_0_0>class pointer_traits{public:typedef __xcodeml_template_type_0_0 pointer;
public:typedef typename __pointer_traits_element_type<__xcodeml_template_type_0_0,expression>::type element_type;
public:typedef typename __pointer_traits_difference_type<__xcodeml_template_type_0_0,expression>::type difference_type;
public:template<typename __xcodeml_template_type_1_0>using rebind=typename __pointer_traits_rebind<__xcodeml_template_type_0_0,__xcodeml_template_type_1_0,expression>::type;
private:
private:class __nat{}
;
public:
public:static __xcodeml_template_type_0_0 pointer_to(typename conditional<expression,class::std::__1::pointer_traits::__nat,typename __pointer_traits_element_type<__xcodeml_template_type_0_0,expression>::type>::type&__r){return(__xcodeml_template_type_0_0::pointer_to(__r));
}
}
;
template<>class pointer_traits<int(*)>{public:typedef int(*pointer);
public:typedef int element_type;
public:typedef long difference_type;
public:template<typename __xcodeml_template_type_0_0>using rebind=__xcodeml_template_type_0_0(*);
private:
private:class __nat;
public:
public:static int(*pointer_to(int&__r));
}
;
template<typename __xcodeml_template_type_0_0>class pointer_traits<__xcodeml_template_type_0_0(*)>{public:typedef __xcodeml_template_type_0_0(*pointer);
public:typedef __xcodeml_template_type_0_0 element_type;
public:typedef long difference_type;
public:template<typename __xcodeml_template_type_1_0>using rebind=__xcodeml_template_type_1_0(*);
private:
private:class __nat{}
;
public:
public:static __xcodeml_template_type_0_0(*pointer_to(typename conditional<expression,class __nat,__xcodeml_template_type_0_0>::type&__r)){return(std::__1::(__r));
}
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __rebind_pointer{public:typedef void/*type*/;
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __has_pointer_type:public integral_constant<bool,0>{}
;
template<>class __has_pointer_type<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,void>:public integral_constant<bool,0>{}
template<>class __has_pointer_type<class::std::__1::allocator<int>,void>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class __has_pointer_type<__xcodeml_template_type_0_0,typename __void_t<typename __xcodeml_template_type_0_0::pointer>::type>:public integral_constant<bool,1>{}
;
namespace __pointer_type_imp{template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,bool=__has_pointer_type<__xcodeml_template_type_0_1,void>::value>class __pointer_type{public:typedef typename __xcodeml_template_type_0_1::pointer type;
}
;
template<>class __pointer_type<void,class::std::__1::__builtin_new_allocator::__builtin_new_deleter,0>{public:typedef void(*type);
}
template<>class __pointer_type<int,class::std::__1::allocator<int>,1>{public:typedef int(*type);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __pointer_type<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,0>{public:typedef __xcodeml_template_type_0_0(*type);
}
;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __pointer_type{public:typedef typename __pointer_type<__xcodeml_template_type_0_0,typename remove_reference<__xcodeml_template_type_0_1>::type,expression>::type type;
}
;
template<>class __pointer_type<void,class::std::__1::__builtin_new_allocator::__builtin_new_deleter>{public:typedef void(*type);
}
template<>class __pointer_type<int,class::std::__1::allocator<int> >{public:typedef int(*type);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __has_const_pointer:public integral_constant<bool,0>{}
;
template<>class __has_const_pointer<class::std::__1::allocator<int>,void>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class __has_const_pointer<__xcodeml_template_type_0_0,typename __void_t<typename __xcodeml_template_type_0_0::const_pointer>::type>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,bool=__has_const_pointer<__xcodeml_template_type_0_2,void>::value>class __const_pointer{public:typedef typename __xcodeml_template_type_0_2::const_pointer type;
}
;
template<>class __const_pointer<int,int(*),class::std::__1::allocator<int>,1>{public:typedef int const(*type);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __const_pointer<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2,0>{public:typedef void/*type*/;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __has_void_pointer:public integral_constant<bool,0>{}
;
template<>class __has_void_pointer<class::std::__1::allocator<int>,void>:public integral_constant<bool,0>{}
;
template<typename __xcodeml_template_type_0_0>class __has_void_pointer<__xcodeml_template_type_0_0,typename __void_t<typename __xcodeml_template_type_0_0::void_pointer>::type>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,bool=__has_void_pointer<__xcodeml_template_type_0_1,void>::value>class __void_pointer{public:typedef typename __xcodeml_template_type_0_1::void_pointer type;
}
;
template<>class __void_pointer<int(*),class::std::__1::allocator<int>,0>{public:typedef void(*type);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __void_pointer<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,0>{public:typedef void/*type*/;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __has_const_void_pointer:public integral_constant<bool,0>{}
;
template<>class __has_const_void_pointer<class::std::__1::allocator<int>,void>:public integral_constant<bool,0>{}
;
template<typename __xcodeml_template_type_0_0>class __has_const_void_pointer<__xcodeml_template_type_0_0,typename __void_t<typename __xcodeml_template_type_0_0::const_void_pointer>::type>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,bool=__has_const_void_pointer<__xcodeml_template_type_0_1,void>::value>class __const_void_pointer{public:typedef typename __xcodeml_template_type_0_1::const_void_pointer type;
}
;
template<>class __const_void_pointer<int(*),class::std::__1::allocator<int>,0>{public:typedef void const(*type);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __const_void_pointer<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,0>{public:typedef void/*type*/;
}
;
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0(*__to_raw_pointer(__xcodeml_template_type_0_0(*__p))){return __p;
}
template <>int(*__to_raw_pointer(int(*__p))){return __p;
}
template<typename __xcodeml_template_type_0_0>typename pointer_traits<__xcodeml_template_type_0_0>::element_type(*__to_raw_pointer(__xcodeml_template_type_0_0 __p)){return(std::__1::((__p.())));
}
template <>int(*__to_raw_pointer(int(*__p)))
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __has_size_type:public integral_constant<bool,0>{}
;
template<>class __has_size_type<class::std::__1::allocator<int>,void>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class __has_size_type<__xcodeml_template_type_0_0,typename __void_t<typename __xcodeml_template_type_0_0::size_type>::type>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,bool=__has_size_type<__xcodeml_template_type_0_0,void>::value>class __size_type{public:typedef typename make_unsigned<__xcodeml_template_type_0_1>::type type;
}
;
template<>class __size_type<class::std::__1::allocator<int>,long,1>{public:typedef unsigned long type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __size_type<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,1>{public:typedef typename __xcodeml_template_type_0_0::size_type type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __has_propagate_on_container_copy_assignment:public integral_constant<bool,0>{}
;
template<>class __has_propagate_on_container_copy_assignment<class::std::__1::allocator<int>,void>:public integral_constant<bool,0>{}
;
template<typename __xcodeml_template_type_0_0>class __has_propagate_on_container_copy_assignment<__xcodeml_template_type_0_0,typename __void_t<typename __xcodeml_template_type_0_0::propagate_on_container_copy_assignment>::type>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0,bool=__has_propagate_on_container_copy_assignment<__xcodeml_template_type_0_0,void>::value>class __propagate_on_container_copy_assignment{public:typedef class::std::__1::integral_constant<bool,0>type;
}
;
template<>class __propagate_on_container_copy_assignment<class::std::__1::allocator<int>,0>{public:typedef class::std::__1::integral_constant<bool,0>type;
}
;
template<typename __xcodeml_template_type_0_0>class __propagate_on_container_copy_assignment<__xcodeml_template_type_0_0,1>{public:typedef typename __xcodeml_template_type_0_0::propagate_on_container_copy_assignment type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __has_propagate_on_container_move_assignment:public integral_constant<bool,0>{}
;
template<>class __has_propagate_on_container_move_assignment<class::std::__1::allocator<int>,void>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class __has_propagate_on_container_move_assignment<__xcodeml_template_type_0_0,typename __void_t<typename __xcodeml_template_type_0_0::propagate_on_container_move_assignment>::type>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0,bool=__has_propagate_on_container_move_assignment<__xcodeml_template_type_0_0,void>::value>class __propagate_on_container_move_assignment{public:typedef class::std::__1::integral_constant<bool,0>type;
}
;
template<>class __propagate_on_container_move_assignment<class::std::__1::allocator<int>,1>{public:typedef class::std::__1::integral_constant<bool,1>type;
}
;
template<typename __xcodeml_template_type_0_0>class __propagate_on_container_move_assignment<__xcodeml_template_type_0_0,1>{public:typedef typename __xcodeml_template_type_0_0::propagate_on_container_move_assignment type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __has_propagate_on_container_swap:public integral_constant<bool,0>{}
;
template<>class __has_propagate_on_container_swap<class::std::__1::allocator<int>,void>:public integral_constant<bool,0>{}
;
template<typename __xcodeml_template_type_0_0>class __has_propagate_on_container_swap<__xcodeml_template_type_0_0,typename __void_t<typename __xcodeml_template_type_0_0::propagate_on_container_swap>::type>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0,bool=__has_propagate_on_container_swap<__xcodeml_template_type_0_0,void>::value>class __propagate_on_container_swap{public:typedef class::std::__1::integral_constant<bool,0>type;
}
;
template<>class __propagate_on_container_swap<class::std::__1::allocator<int>,0>{public:typedef class::std::__1::integral_constant<bool,0>type;
}
;
template<typename __xcodeml_template_type_0_0>class __propagate_on_container_swap<__xcodeml_template_type_0_0,1>{public:typedef typename __xcodeml_template_type_0_0::propagate_on_container_swap type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __has_is_always_equal:public integral_constant<bool,0>{}
;
template<>class __has_is_always_equal<class::std::__1::allocator<int>,void>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class __has_is_always_equal<__xcodeml_template_type_0_0,typename __void_t<typename __xcodeml_template_type_0_0::is_always_equal>::type>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0,bool=__has_is_always_equal<__xcodeml_template_type_0_0,void>::value>class __is_always_equal{public:typedef typename is_empty<__xcodeml_template_type_0_0>::type type;
}
;
template<>class __is_always_equal<class::std::__1::allocator<int>,1>{public:typedef class::std::__1::integral_constant<bool,1>type;
}
;
template<typename __xcodeml_template_type_0_0>class __is_always_equal<__xcodeml_template_type_0_0,1>{public:typedef typename __xcodeml_template_type_0_0::is_always_equal type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,bool=__has_rebind<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::value>class __has_rebind_other{private:
private:class __two{public:char __lx;
public:char __lxx;
}
;
private:template<typename __xcodeml_template_type_1_0>static class::std::__1::__has_rebind_other::__two __test(...)
private:template<typename __xcodeml_template_type_1_0>static char __test(typename void/**/::other(*))
public:
public:static bool const value=((sizeof((__xcodeml_template_type_0_0(0))))==1);
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __has_rebind_other<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,0>{public:static bool const value=false;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,bool=__has_rebind_other<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,expression>::value>class __allocator_traits_rebind{public:typedef typename void/**/::other type;
}
;
;
template<typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>class __allocator_traits_rebind< <__xcodeml_template_type_0_1,...>,__xcodeml_template_type_0_3,1>{public:typedef typename void/**/::other type;
}
;
template<typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>class __allocator_traits_rebind< <__xcodeml_template_type_0_1,...>,__xcodeml_template_type_0_3,0>{public:typedef<__xcodeml_template_type_0_3,...>;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>decltype (__has_allocate_hint_test(__xcodeml_template_type_0_0(*__a),__xcodeml_template_type_0_1(*__sz),__xcodeml_template_type_0_2(*__p)))
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class::std::__1::integral_constant<bool,0>__has_allocate_hint_test(__xcodeml_template_type_0_0 const&__a,__xcodeml_template_type_0_1(*__sz),__xcodeml_template_type_0_2(*__p))
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __has_allocate_hint:public integral_constant<bool,expression>{}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>decltype (__has_construct_test(__xcodeml_template_type_0_0(*__a),__xcodeml_template_type_0_1(*__p),void/*__args*/))
template <>class::std::__1::integral_constant<bool,1>__has_construct_test(class::std::__1::allocator<int>(*__a),int(*__p),int(*__args))
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class::std::__1::integral_constant<bool,0>__has_construct_test(__xcodeml_template_type_0_0 const&__a,__xcodeml_template_type_0_1(*__p),void/*__args*/)
template <>class::std::__1::integral_constant<bool,0>__has_construct_test(class allocator const&__a,int(*(*__p)),int(*__args))
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __has_construct:public integral_constant<bool,expression>{}
;
template<>class __has_construct<class::std::__1::allocator<int>,int(*),...>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>decltype (__has_destroy_test(__xcodeml_template_type_0_0(*__a),__xcodeml_template_type_0_1(*__p)))
template <>class::std::__1::integral_constant<bool,1>__has_destroy_test(class::std::__1::allocator<int>(*__a),int(*(*__p)))
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class::std::__1::integral_constant<bool,0>__has_destroy_test(__xcodeml_template_type_0_0 const&__a,__xcodeml_template_type_0_1(*__p))
template <>class::std::__1::integral_constant<bool,0>__has_destroy_test(class allocator const&__a,int(*(*__p)))
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __has_destroy:public integral_constant<bool,expression>{}
;
template<>class __has_destroy<class::std::__1::allocator<int>,int(*)>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>decltype (__has_max_size_test(__xcodeml_template_type_0_0(*__a)))
template <>class::std::__1::integral_constant<bool,1>__has_max_size_test(class allocator const&__a)
template<typename __xcodeml_template_type_0_0>class::std::__1::integral_constant<bool,0>__has_max_size_test(__xcodeml_template_type_0_0 volatile const&__a)
template <>class::std::__1::integral_constant<bool,0>__has_max_size_test(class allocator volatile const&__a)
template<typename __xcodeml_template_type_0_0>class __has_max_size:public integral_constant<bool,expression>{}
;
template<>class __has_max_size<class allocator const>:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>decltype (__has_select_on_container_copy_construction_test(__xcodeml_template_type_0_0(*__a)))
template<typename __xcodeml_template_type_0_0>class::std::__1::integral_constant<bool,0>__has_select_on_container_copy_construction_test(__xcodeml_template_type_0_0 volatile const&__a)
template<typename __xcodeml_template_type_0_0>class __has_select_on_container_copy_construction:public integral_constant<bool,expression>{}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,bool=__has_difference_type<__xcodeml_template_type_0_0,void>::value>class __alloc_traits_difference_type{public:typedef typename pointer_traits<__xcodeml_template_type_0_1>::difference_type type;
}
;
template<>class __alloc_traits_difference_type<class::std::__1::allocator<int>,int(*),1>{public:typedef long type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __alloc_traits_difference_type<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,1>{public:typedef typename __xcodeml_template_type_0_0::difference_type type;
}
;
template<typename __xcodeml_template_type_0_0>class __is_default_allocator:public integral_constant<bool,0>{}
;
template<>class __is_default_allocator<class::std::__1::allocator<int> >:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class __is_default_allocator<allocator<__xcodeml_template_type_0_0> >:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0>class allocator_traits{public:typedef __xcodeml_template_type_0_0 allocator_type;
public:typedef typename __xcodeml_template_type_0_0::value_type value_type;
public:typedef typename __pointer_type<typename __xcodeml_template_type_0_0::value_type,__xcodeml_template_type_0_0>::type pointer;
public:typedef typename __const_pointer<typename __xcodeml_template_type_0_0::value_type,typename __pointer_type<typename __xcodeml_template_type_0_0::value_type,__xcodeml_template_type_0_0>::type,__xcodeml_template_type_0_0,expression>::type const_pointer;
public:typedef typename __void_pointer<typename __pointer_type<typename __xcodeml_template_type_0_0::value_type,__xcodeml_template_type_0_0>::type,__xcodeml_template_type_0_0,expression>::type void_pointer;
public:typedef typename __const_void_pointer<typename __pointer_type<typename __xcodeml_template_type_0_0::value_type,__xcodeml_template_type_0_0>::type,__xcodeml_template_type_0_0,expression>::type const_void_pointer;
public:typedef typename __alloc_traits_difference_type<__xcodeml_template_type_0_0,typename __pointer_type<typename __xcodeml_template_type_0_0::value_type,__xcodeml_template_type_0_0>::type,expression>::type difference_type;
public:typedef typename __size_type<__xcodeml_template_type_0_0,typename __alloc_traits_difference_type<__xcodeml_template_type_0_0,typename __pointer_type<typename __xcodeml_template_type_0_0::value_type,__xcodeml_template_type_0_0>::type,expression>::type,expression>::type size_type;
public:typedef typename __propagate_on_container_copy_assignment<__xcodeml_template_type_0_0,expression>::type propagate_on_container_copy_assignment;
public:typedef typename __propagate_on_container_move_assignment<__xcodeml_template_type_0_0,expression>::type propagate_on_container_move_assignment;
public:typedef typename __propagate_on_container_swap<__xcodeml_template_type_0_0,expression>::type propagate_on_container_swap;
public:typedef typename __is_always_equal<__xcodeml_template_type_0_0,expression>::type is_always_equal;
public:template<typename __xcodeml_template_type_1_0>using rebind_alloc=typename __allocator_traits_rebind<__xcodeml_template_type_0_0,__xcodeml_template_type_1_0,expression>::type;
public:template<typename __xcodeml_template_type_1_0>using rebind_traits=allocator_traits<typename __allocator_traits_rebind<__xcodeml_template_type_0_0,__xcodeml_template_type_1_0,expression>::type>;
public:static typename __pointer_type<typename __xcodeml_template_type_0_0::value_type,__xcodeml_template_type_0_0>::type allocate(__xcodeml_template_type_0_0&__a,typename __size_type<__xcodeml_template_type_0_0,typename __alloc_traits_difference_type<__xcodeml_template_type_0_0,typename __pointer_type<typename __xcodeml_template_type_0_0::value_type,__xcodeml_template_type_0_0>::type,expression>::type,expression>::type __n){return(__a.allocate(__n));
}
public:static typename __pointer_type<typename __xcodeml_template_type_0_0::value_type,__xcodeml_template_type_0_0>::type allocate(__xcodeml_template_type_0_0&__a,typename __size_type<__xcodeml_template_type_0_0,typename __alloc_traits_difference_type<__xcodeml_template_type_0_0,typename __pointer_type<typename __xcodeml_template_type_0_0::value_type,__xcodeml_template_type_0_0>::type,expression>::type,expression>::type __n,typename __const_void_pointer<typename __pointer_type<typename __xcodeml_template_type_0_0::value_type,__xcodeml_template_type_0_0>::type,__xcodeml_template_type_0_0,expression>::type __hint){return((__a,__n,__hint,__xcodeml_identity<__has_allocate_hint<__xcodeml_template_type_0_0,typename __size_type<__xcodeml_template_type_0_0,typename __alloc_traits_difference_type<__xcodeml_template_type_0_0,typename __pointer_type<typename __xcodeml_template_type_0_0::value_type,__xcodeml_template_type_0_0>::type,expression>::type,expression>::type,typename __const_void_pointer<typename __pointer_type<typename __xcodeml_template_type_0_0::value_type,__xcodeml_template_type_0_0>::type,__xcodeml_template_type_0_0,expression>::type> >::t()));
}
public:static void deallocate(__xcodeml_template_type_0_0&__a,typename __pointer_type<typename __xcodeml_template_type_0_0::value_type,__xcodeml_template_type_0_0>::type __p,typename __size_type<__xcodeml_template_type_0_0,typename __alloc_traits_difference_type<__xcodeml_template_type_0_0,typename __pointer_type<typename __xcodeml_template_type_0_0::value_type,__xcodeml_template_type_0_0>::type,expression>::type,expression>::type __n){(__a.deallocate(__p,__n));
}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>static void construct(__xcodeml_template_type_0_0&__a,__xcodeml_template_type_1_0(*__p),void/*__args*/){((__xcodeml_identity<__has_construct<__xcodeml_template_type_0_0,__xcodeml_template_type_1_0(*),...> >::t(),__a,__p,(std::__1::__xcodeml_template_type_1_1(__args))));
}
public:template<typename __xcodeml_template_type_1_0>static void destroy(__xcodeml_template_type_0_0&__a,__xcodeml_template_type_1_0(*__p)){((__xcodeml_identity<__has_destroy<__xcodeml_template_type_0_0,__xcodeml_template_type_1_0(*)> >::t(),__a,__p));
}
public:static typename __size_type<__xcodeml_template_type_0_0,typename __alloc_traits_difference_type<__xcodeml_template_type_0_0,typename __pointer_type<typename __xcodeml_template_type_0_0::value_type,__xcodeml_template_type_0_0>::type,expression>::type,expression>::type max_size(__xcodeml_template_type_0_0 const&__a){return((__xcodeml_identity<__has_max_size<__xcodeml_template_type_0_0 const> >::t(),__a));
}
public:static __xcodeml_template_type_0_0 select_on_container_copy_construction(__xcodeml_template_type_0_0 const&__a){return((__xcodeml_identity<__has_select_on_container_copy_construction<__xcodeml_template_type_0_0 const> >::t(),__a));
}
public:template<typename __xcodeml_template_type_1_0>static void __construct_forward(__xcodeml_template_type_0_0&__a,__xcodeml_template_type_1_0 __begin1,__xcodeml_template_type_1_0 __end1,__xcodeml_template_type_1_0&__begin2){{;for(;(__begin1,__end1);((++__begin1),((void)(++__begin2)))){((__a,(std::__1::(__begin2)),(std::__1::((*__begin1)))));}};
}
public:template<typename __xcodeml_template_type_1_0>static typename enable_if<expression,void>::type __construct_forward(__xcodeml_template_type_0_0&,__xcodeml_template_type_1_0(*__begin1),__xcodeml_template_type_1_0(*__end1),__xcodeml_template_type_1_0(*&__begin2)){long _Np=(__end1,__begin1);
if((_Np>0)){{(std::__1::memcpy(__begin2,__begin1,(_Np*(sizeof(__xcodeml_template_type_1_0)))));
(__begin2+=_Np);
};};
}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>static void __construct_range_forward(__xcodeml_template_type_0_0&__a,__xcodeml_template_type_1_0 __begin1,__xcodeml_template_type_1_0 __end1,__xcodeml_template_type_1_1&__begin2){{;for(;(__begin1,__end1);((++__begin1),((void)(++__begin2)))){((__a,(std::__1::(__begin2)),(*__begin1)));}};
}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1,typename __xcodeml_template_type_1_2,typename __xcodeml_template_type_1_3>static typename enable_if<expression,void>::type __construct_range_forward(__xcodeml_template_type_0_0&,__xcodeml_template_type_1_0(*__begin1),__xcodeml_template_type_1_0(*__end1),__xcodeml_template_type_1_1(*&__begin2)){long _Np=(__end1,__begin1);
if((_Np>0)){{(std::__1::memcpy(const_cast<__xcodeml_template_type_1_3(*)>(__begin2),__begin1,(_Np*(sizeof(__xcodeml_template_type_1_1)))));
(__begin2+=_Np);
};};
}
public:template<typename __xcodeml_template_type_1_0>static void __construct_backward(__xcodeml_template_type_0_0&__a,__xcodeml_template_type_1_0 __begin1,__xcodeml_template_type_1_0 __end1,__xcodeml_template_type_1_0&__end2){while((__end1,__begin1)){{((__a,(std::__1::((__end2,1))),(std::__1::((*(--__end1))))));
(--__end2);
};};
}
public:template<typename __xcodeml_template_type_1_0>static typename enable_if<expression,void>::type __construct_backward(__xcodeml_template_type_0_0&,__xcodeml_template_type_1_0(*__begin1),__xcodeml_template_type_1_0(*__end1),__xcodeml_template_type_1_0(*&__end2)){long _Np=(__end1,__begin1);
(__end2-=_Np);
if((_Np>0)){(std::__1::memcpy(__end2,__begin1,(_Np*(sizeof(__xcodeml_template_type_1_0)))));};
}
private:
private:static typename __pointer_type<typename __xcodeml_template_type_0_0::value_type,__xcodeml_template_type_0_0>::type __allocate(__xcodeml_template_type_0_0&__a,typename __size_type<__xcodeml_template_type_0_0,typename __alloc_traits_difference_type<__xcodeml_template_type_0_0,typename __pointer_type<typename __xcodeml_template_type_0_0::value_type,__xcodeml_template_type_0_0>::type,expression>::type,expression>::type __n,typename __const_void_pointer<typename __pointer_type<typename __xcodeml_template_type_0_0::value_type,__xcodeml_template_type_0_0>::type,__xcodeml_template_type_0_0,expression>::type __hint,class::std::__1::integral_constant<bool,1>){return(__a.allocate(__n,__hint));
}
private:static typename __pointer_type<typename __xcodeml_template_type_0_0::value_type,__xcodeml_template_type_0_0>::type __allocate(__xcodeml_template_type_0_0&__a,typename __size_type<__xcodeml_template_type_0_0,typename __alloc_traits_difference_type<__xcodeml_template_type_0_0,typename __pointer_type<typename __xcodeml_template_type_0_0::value_type,__xcodeml_template_type_0_0>::type,expression>::type,expression>::type __n,typename __const_void_pointer<typename __pointer_type<typename __xcodeml_template_type_0_0::value_type,__xcodeml_template_type_0_0>::type,__xcodeml_template_type_0_0,expression>::type,class::std::__1::integral_constant<bool,0>){return(__a.allocate(__n));
}
private:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>static void __construct(class::std::__1::integral_constant<bool,1>,__xcodeml_template_type_0_0&__a,__xcodeml_template_type_1_0(*__p),void/*__args*/){(__a.construct(__p,(std::__1::__xcodeml_template_type_1_1(__args))));
}
private:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>static void __construct(class::std::__1::integral_constant<bool,0>,__xcodeml_template_type_0_0&,__xcodeml_template_type_1_0(*__p),void/*__args*/){::new(((void(*))__p))__xcodeml_identity<__xcodeml_template_type_1_0>::t((std::__1::__xcodeml_template_type_1_1(__args)));
}
private:template<typename __xcodeml_template_type_1_0>static void __destroy(class::std::__1::integral_constant<bool,1>,__xcodeml_template_type_0_0&__a,__xcodeml_template_type_1_0(*__p)){(__a.destroy(__p));
}
private:template<typename __xcodeml_template_type_1_0>static void __destroy(class::std::__1::integral_constant<bool,0>,__xcodeml_template_type_0_0&,__xcodeml_template_type_1_0(*__p)){(__xcodeml_template_type_1_0 __p());
}
private:static typename __size_type<__xcodeml_template_type_0_0,typename __alloc_traits_difference_type<__xcodeml_template_type_0_0,typename __pointer_type<typename __xcodeml_template_type_0_0::value_type,__xcodeml_template_type_0_0>::type,expression>::type,expression>::type __max_size(class::std::__1::integral_constant<bool,1>,__xcodeml_template_type_0_0 const&__a){return(__a.max_size());
}
private:static typename __size_type<__xcodeml_template_type_0_0,typename __alloc_traits_difference_type<__xcodeml_template_type_0_0,typename __pointer_type<typename __xcodeml_template_type_0_0::value_type,__xcodeml_template_type_0_0>::type,expression>::type,expression>::type __max_size(class::std::__1::integral_constant<bool,0>,__xcodeml_template_type_0_0 const&){return((numeric_limits<typename __size_type<__xcodeml_template_type_0_0,typename __alloc_traits_difference_type<__xcodeml_template_type_0_0,typename __pointer_type<typename __xcodeml_template_type_0_0::value_type,__xcodeml_template_type_0_0>::type,expression>::type,expression>::type>::max())/(sizeof(typename __xcodeml_template_type_0_0::value_type)));
}
private:static __xcodeml_template_type_0_0 __select_on_container_copy_construction(class::std::__1::integral_constant<bool,1>,__xcodeml_template_type_0_0 const&__a){return(__a.select_on_container_copy_construction());
}
private:static __xcodeml_template_type_0_0 __select_on_container_copy_construction(class::std::__1::integral_constant<bool,0>,__xcodeml_template_type_0_0 const&__a){return __a;
}
}
;
template<>class allocator_traits<class::std::__1::allocator<int> >{public:typedef class::std::__1::allocator<int>allocator_type;
public:typedef int value_type;
public:typedef int(*pointer);
public:typedef int const(*const_pointer);
public:typedef void(*void_pointer);
public:typedef void const(*const_void_pointer);
public:typedef long difference_type;
public:typedef unsigned long size_type;
public:typedef class::std::__1::integral_constant<bool,0>propagate_on_container_copy_assignment;
public:typedef class::std::__1::integral_constant<bool,1>propagate_on_container_move_assignment;
public:typedef class::std::__1::integral_constant<bool,0>propagate_on_container_swap;
public:typedef class::std::__1::integral_constant<bool,1>is_always_equal;
public:template<typename __xcodeml_template_type_0_0>using rebind_alloc=typename __allocator_traits_rebind<class::std::__1::allocator<int>,__xcodeml_template_type_0_0,expression>::type;
public:template<typename __xcodeml_template_type_0_0>using rebind_traits=allocator_traits<typename __allocator_traits_rebind<class::std::__1::allocator<int>,__xcodeml_template_type_0_0,expression>::type>;
public:static int(*allocate(class::std::__1::allocator<int>&__a,unsigned long __n)){return(__a.allocate(__n,0));
}
public:static int(*allocate(class::std::__1::allocator<int>&__a,unsigned long __n,void const(*__hint)));
public:static void deallocate(class::std::__1::allocator<int>&__a,int(*__p),unsigned long __n){(__a.deallocate(__p,__n));
}
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>static void construct(class::std::__1::allocator<int>&__a,__xcodeml_template_type_0_0(*__p),void/*__args*/)
static template <>void construct(class::std::__1::allocator<int>&__a,int(*__p),int(*__args)){(__construct(__xcodeml_identity<class::std::__1::integral_constant<bool,1> >::t(__xcodeml_identity<class::std::__1::__has_construct<class::std::__1::allocator<int>,int(*),...> >::t()),__a,__p,(std::__1::forward<int>(__args))));
}
public:template<typename __xcodeml_template_type_0_0>static void destroy(class::std::__1::allocator<int>&__a,__xcodeml_template_type_0_0(*__p))
static template <>void destroy(class::std::__1::allocator<int>&__a,int(*__p)){(__destroy(__xcodeml_identity<class::std::__1::integral_constant<bool,1> >::t(__xcodeml_identity<class::std::__1::__has_destroy<class::std::__1::allocator<int>,int(*)> >::t()),__a,__p));
}
public:static unsigned long max_size(class allocator const&__a){return(__max_size(__xcodeml_identity<class::std::__1::integral_constant<bool,1> >::t(__xcodeml_identity<class::std::__1::__has_max_size<class allocator const> >::t()),__a));
}
public:static class::std::__1::allocator<int>select_on_container_copy_construction(class allocator const&__a);
public:template<typename __xcodeml_template_type_0_0>static void __construct_forward(class::std::__1::allocator<int>&__a,__xcodeml_template_type_0_0 __begin1,__xcodeml_template_type_0_0 __end1,__xcodeml_template_type_0_0&__begin2)
public:template<typename __xcodeml_template_type_0_0>static typename enable_if<expression,void>::type __construct_forward(class::std::__1::allocator<int>&,__xcodeml_template_type_0_0(*__begin1),__xcodeml_template_type_0_0(*__end1),__xcodeml_template_type_0_0(*&__begin2))
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>static void __construct_range_forward(class::std::__1::allocator<int>&__a,__xcodeml_template_type_0_0 __begin1,__xcodeml_template_type_0_0 __end1,__xcodeml_template_type_0_1&__begin2)
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>static typename enable_if<expression,void>::type __construct_range_forward(class::std::__1::allocator<int>&,__xcodeml_template_type_0_0(*__begin1),__xcodeml_template_type_0_0(*__end1),__xcodeml_template_type_0_1(*&__begin2))
public:template<typename __xcodeml_template_type_0_0>static void __construct_backward(class::std::__1::allocator<int>&__a,__xcodeml_template_type_0_0 __begin1,__xcodeml_template_type_0_0 __end1,__xcodeml_template_type_0_0&__end2)
static template <>void __construct_backward(class::std::__1::allocator<int>&__a,int(*__begin1),int(*__end1),int(*&__end2))
public:template<typename __xcodeml_template_type_0_0>static typename enable_if<expression,void>::type __construct_backward(class::std::__1::allocator<int>&,__xcodeml_template_type_0_0(*__begin1),__xcodeml_template_type_0_0(*__end1),__xcodeml_template_type_0_0(*&__end2))
static template <>void __construct_backward(class::std::__1::allocator<int>&,int(*__begin1),int(*__end1),int(*&__end2)){long _Np=(__end1-__begin1);
(__end2-=_Np);
if((_Np>0)){(std::__1::memcpy(__end2,__begin1,(_Np*(sizeof(int)))));};
}
private:
private:static int(*__allocate(class::std::__1::allocator<int>&__a,unsigned long __n,void const(*__hint),class::std::__1::integral_constant<bool,1>));
private:static int(*__allocate(class::std::__1::allocator<int>&__a,unsigned long __n,void const(*),class::std::__1::integral_constant<bool,0>));
private:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>static void __construct(class::std::__1::integral_constant<bool,1>,class::std::__1::allocator<int>&__a,__xcodeml_template_type_0_0(*__p),void/*__args*/)
static template <>void __construct(class::std::__1::integral_constant<bool,1>,class::std::__1::allocator<int>&__a,int(*__p),int(*__args)){(__a.construct(__p,(std::__1::forward<int>(__args))));
}
private:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>static void __construct(class::std::__1::integral_constant<bool,0>,class::std::__1::allocator<int>&,__xcodeml_template_type_0_0(*__p),void/*__args*/)
private:template<typename __xcodeml_template_type_0_0>static void __destroy(class::std::__1::integral_constant<bool,1>,class::std::__1::allocator<int>&__a,__xcodeml_template_type_0_0(*__p))
static template <>void __destroy(class::std::__1::integral_constant<bool,1>,class::std::__1::allocator<int>&__a,int(*__p)){(__a.destroy(__p));
}
private:template<typename __xcodeml_template_type_0_0>static void __destroy(class::std::__1::integral_constant<bool,0>,class::std::__1::allocator<int>&,__xcodeml_template_type_0_0(*__p))
private:static unsigned long __max_size(class::std::__1::integral_constant<bool,1>,class allocator const&__a){return(__a.max_size());
}
private:static unsigned long __max_size(class::std::__1::integral_constant<bool,0>,class allocator const&);
private:static class::std::__1::allocator<int>__select_on_container_copy_construction(class::std::__1::integral_constant<bool,1>,class allocator const&__a);
private:static class::std::__1::allocator<int>__select_on_container_copy_construction(class::std::__1::integral_constant<bool,0>,class allocator const&__a);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __rebind_alloc_helper{public:typedef void/*type*/;
}
;
;
template<typename __xcodeml_template_type_0_0>class allocator{public:
public:typedef unsigned long size_type;
public:typedef long difference_type;
public:typedef __xcodeml_template_type_0_0(*pointer);
public:typedef __xcodeml_template_type_0_0 const(*const_pointer);
public:typedef __xcodeml_template_type_0_0&reference;
public:typedef __xcodeml_template_type_0_0 const&const_reference;
public:typedef __xcodeml_template_type_0_0 value_type;
public:typedef class::std::__1::integral_constant<bool,1>propagate_on_container_move_assignment;
public:typedef class::std::__1::integral_constant<bool,1>is_always_equal;
public:template<typename __xcodeml_template_type_1_0>class rebind{public:typedef allocator<__xcodeml_template_type_1_0>;
}
;
;
public:allocator(){}
public:template<typename __xcodeml_template_type_1_0>allocator(allocator<__xcodeml_template_type_1_0>){}
public:__xcodeml_template_type_0_0(*address(__xcodeml_template_type_0_0&__x)const){return(std::__1::(__x));
}
public:__xcodeml_template_type_0_0 const(*address(__xcodeml_template_type_0_0 const&__x)const){return(std::__1::(__x));
}
public:__xcodeml_template_type_0_0(*allocate(unsigned long __n,void const(*))){if((__n,(this->max_size()))){(__throw_length_error("allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size"));};
return static_cast<__xcodeml_template_type_0_0(*)>((std::__1::__libcpp_allocate((__n*(sizeof(__xcodeml_template_type_0_0))),__xcodeml_template_type_0_0)));
}
public:void deallocate(__xcodeml_template_type_0_0(*__p),unsigned long __n){(std::__1::__libcpp_deallocate(((void(*))__p),(__n*(sizeof(__xcodeml_template_type_0_0))),__xcodeml_template_type_0_0));
}
public:unsigned long max_size()const{return(((unsigned long)(~0))/(sizeof(__xcodeml_template_type_0_0)));
}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>void construct(__xcodeml_template_type_1_0(*__p),void/*__args*/){::new(((void(*))__p))__xcodeml_identity<__xcodeml_template_type_1_0>::t((std::__1::__xcodeml_template_type_1_1(__args)));
}
public:void destroy(__xcodeml_template_type_0_0(*__p)){(__xcodeml_template_type_0_0 __p());
}
}
;
;
template<typename __xcodeml_template_type_0_0>class allocator<__xcodeml_template_type_0_0 const>{public:
public:typedef unsigned long size_type;
public:typedef long difference_type;
public:typedef __xcodeml_template_type_0_0 const(*pointer);
public:typedef __xcodeml_template_type_0_0 const(*const_pointer);
public:typedef __xcodeml_template_type_0_0 const&reference;
public:typedef __xcodeml_template_type_0_0 const&const_reference;
public:typedef __xcodeml_template_type_0_0 const value_type;
public:typedef class::std::__1::integral_constant<bool,1>propagate_on_container_move_assignment;
public:typedef class::std::__1::integral_constant<bool,1>is_always_equal;
public:template<typename __xcodeml_template_type_1_0>class rebind{public:typedef allocator<__xcodeml_template_type_1_0>;
}
;
;
public:allocator(){}
public:template<typename __xcodeml_template_type_1_0>allocator(allocator<__xcodeml_template_type_1_0>){}
public:__xcodeml_template_type_0_0 const(*address(__xcodeml_template_type_0_0 const&__x)const){return(std::__1::(__x));
}
public:__xcodeml_template_type_0_0 const(*allocate(unsigned long __n,void const(*))){if((__n,(this->max_size()))){(__throw_length_error("allocator<const T>::allocate(size_t n) 'n' exceeds maximum supported size"));};
return static_cast<__xcodeml_template_type_0_0 const(*)>((std::__1::__libcpp_allocate((__n*(sizeof(__xcodeml_template_type_0_0))),__xcodeml_template_type_0_0)));
}
public:void deallocate(__xcodeml_template_type_0_0 const(*__p),unsigned long __n){(std::__1::__libcpp_deallocate(((void(*))const_cast<__xcodeml_template_type_0_0(*)>(__p)),(__n*(sizeof(__xcodeml_template_type_0_0))),__xcodeml_template_type_0_0));
}
public:unsigned long max_size()const{return(((unsigned long)(~0))/(sizeof(__xcodeml_template_type_0_0)));
}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>void construct(__xcodeml_template_type_1_0(*__p),void/*__args*/){::new(((void(*))__p))__xcodeml_identity<__xcodeml_template_type_1_0>::t((std::__1::__xcodeml_template_type_1_1(__args)));
}
public:void destroy(__xcodeml_template_type_0_0 const(*__p)){(__xcodeml_template_type_0_0 __p());
}
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator==(allocator<__xcodeml_template_type_0_0>,allocator<__xcodeml_template_type_0_1>){return true;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator!=(allocator<__xcodeml_template_type_0_0>,allocator<__xcodeml_template_type_0_1>){return false;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class raw_storage_iterator:public iterator<class::std::__1::output_iterator_tag,__xcodeml_template_type_0_1,long,__xcodeml_template_type_0_1(*),class raw_storage_iterator&>{private:
private:__xcodeml_template_type_0_0 __x_;
public:
public:raw_storage_iterator(__xcodeml_template_type_0_0 __x):__x_(__x){}
public:class raw_storage_iterator&operator*(){return(*this);
}
public:class raw_storage_iterator&operator=(__xcodeml_template_type_0_1 const&__element){::new((std::__1::((*this->__x_))))__xcodeml_identity<__xcodeml_template_type_0_1>::t(__element);
return(*this);
}
public:class raw_storage_iterator&operator=(__xcodeml_template_type_0_1(*__element)){::new((std::__1::((*this->__x_))))__xcodeml_identity<__xcodeml_template_type_0_1>::t((std::__1::(__element)));
return(*this);
}
public:class raw_storage_iterator&operator++(){(++this->__x_);
return(*this);
}
public:class raw_storage_iterator operator++(int){class raw_storage_iterator __t=(*this);
(++this->__x_);
return __t;
}
public:__xcodeml_template_type_0_0 base()const{return this->__x_;
}
}
;
;
template<typename __xcodeml_template_type_0_0>pair<__xcodeml_template_type_0_0(*),long>{pair<__xcodeml_template_type_0_0(*),long> =0 0;
long const __m=(((~((long)0))^((long)(((long)1)<<(((sizeof(long))*8)-1))))/(sizeof(__xcodeml_template_type_0_0)));
if((__n>__m)){(__n=__m);};
while((__n>0)){{if((__is_overaligned_for_new(__xcodeml_template_type_0_0))){{return __r;
};};
(__r.first=static_cast<__xcodeml_template_type_0_0(*)>((::operator new((__n*(sizeof(__xcodeml_template_type_0_0))),nothrow))));
if(__r.first){{(__r.second=__n);
break;
};};
(__n/=2);
};};
return __r;
}
template<typename __xcodeml_template_type_0_0>void return_temporary_buffer(__xcodeml_template_type_0_0(*__p)){(std::__1::__libcpp_deallocate_unsized(((void(*))__p),__xcodeml_template_type_0_0));
}
template<typename __xcodeml_template_type_0_0>class auto_ptr_ref{public:__xcodeml_template_type_0_0(*__ptr_);
}
;
;
template<typename __xcodeml_template_type_0_0>class auto_ptr{private:
private:__xcodeml_template_type_0_0(*__ptr_);
public:
public:typedef __xcodeml_template_type_0_0 element_type;
public:auto_ptr(__xcodeml_template_type_0_0(*__p)):__ptr_(__p){}
public:auto_ptr(class auto_ptr&__p):__ptr_((__p.release())){}
public:template<typename __xcodeml_template_type_1_0>auto_ptr(auto_ptr<__xcodeml_template_type_1_0>):__ptr_((__p.release())){}
public:class auto_ptr&operator=(class auto_ptr&__p){(this->reset((__p.release())));
return(*this);
}
public:template<typename __xcodeml_template_type_1_0>class auto_ptr&operator=(auto_ptr<__xcodeml_template_type_1_0>){(this->reset((__p.release())));
return(*this);
}
public:class auto_ptr&operator=(auto_ptr_ref<__xcodeml_template_type_0_0>){(this->reset(__p.__ptr_));
return(*this);
}
public:~auto_ptr(){delete this->__ptr_;
}
public:__xcodeml_template_type_0_0&operator*()const{return(*this->__ptr_);
}
public:__xcodeml_template_type_0_0(*operator->()const){return this->__ptr_;
}
public:__xcodeml_template_type_0_0(*get()const){return this->__ptr_;
}
public:__xcodeml_template_type_0_0(*release()){__xcodeml_template_type_0_0(*__t)=this->__ptr_;
(this->__ptr_=0);
return __t;
}
public:void reset(__xcodeml_template_type_0_0(*__p)){if((this->__ptr_,__p)){delete this->__ptr_;};
(this->__ptr_=__p);
}
public:auto_ptr(auto_ptr_ref<__xcodeml_template_type_0_0>):__ptr_(__p.__ptr_){}
public:template<typename __xcodeml_template_type_1_0>
public:template<typename __xcodeml_template_type_1_0>
}
;
;
template<>class auto_ptr<void>{public:
public:typedef void element_type;
}
;
template<typename __xcodeml_template_type_0_0,int _Idx,bool _CanBeEmptyBase=(is_empty<__xcodeml_template_type_0_0>::value&&(!__libcpp_is_final<__xcodeml_template_type_0_0>::value))>class __compressed_pair_elem{public:typedef __xcodeml_template_type_0_0 _ParamT;
public:typedef __xcodeml_template_type_0_0&reference;
public:typedef __xcodeml_template_type_0_0 const&const_reference;
public:__compressed_pair_elem():__value_(){}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>__compressed_pair_elem(__xcodeml_template_type_1_0(*__u)):__value_((std::__1::__xcodeml_template_type_1_0(__u))){}
public:template<typename __xcodeml_template_type_1_0,unsigned long _Indexes>__compressed_pair_elem(class::std::__1::piecewise_construct_t,tuple<...>,__tuple_indices<...>):__value_((std::__1::__xcodeml_template_type_1_0((std::__1::_Indexes(__args))))){}
public:__xcodeml_template_type_0_0&__get(){return this->__value_;
}
public:__xcodeml_template_type_0_0 const&__get()const{return this->__value_;
}
private:
private:__xcodeml_template_type_0_0 __value_;
}
;
template<>class __compressed_pair_elem<void(*),0,0>{public:typedef void(*_ParamT);
public:typedef void(*&reference);
public:typedef void(*const&const_reference);
public:__compressed_pair_elem();
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__compressed_pair_elem(__xcodeml_template_type_0_0(*__u))
template <>__compressed_pair_elem(void(*&__u)):__value_((std::__1::forward<void(*&)>(__u))){}
template <>__compressed_pair_elem(void(*(*__u))):__value_((std::__1::forward<void(*)>(__u))){}
public:template<typename __xcodeml_template_type_0_0,unsigned long _Indexes>__compressed_pair_elem(class::std::__1::piecewise_construct_t,tuple<...>,__tuple_indices<...>)
public:void(*&__get()){return this->__value_;
}
public:void(*const&__get()const);
private:
private:void(*__value_);
}
template<>class __compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0>{public:typedef class::std::__1::__builtin_new_allocator::__builtin_new_deleter _ParamT;
public:typedef class::std::__1::__builtin_new_allocator::__builtin_new_deleter&reference;
public:typedef class __builtin_new_deleter const&const_reference;
public:__compressed_pair_elem();
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__compressed_pair_elem(__xcodeml_template_type_0_0(*__u))
template <>__compressed_pair_elem(class::std::__1::__builtin_new_allocator::__builtin_new_deleter(*__u)):__value_((std::__1::forward<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>(__u))){}
public:template<typename __xcodeml_template_type_0_0,unsigned long _Indexes>__compressed_pair_elem(class::std::__1::piecewise_construct_t,tuple<...>,__tuple_indices<...>)
public:class::std::__1::__builtin_new_allocator::__builtin_new_deleter&__get(){return this->__value_;
}
public:class __builtin_new_deleter const&__get()const;
private:
private:class::std::__1::__builtin_new_allocator::__builtin_new_deleter __value_;
}
template<>class __compressed_pair_elem<int(*),0,0>{public:typedef int(*_ParamT);
public:typedef int(*&reference);
public:typedef int(*const&const_reference);
public:__compressed_pair_elem();
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__compressed_pair_elem(__xcodeml_template_type_0_0(*__u))
template <>__compressed_pair_elem(nullptr_t(*__u)):__value_((std::__1::forward<nullptr_t>(__u))){}
public:template<typename __xcodeml_template_type_0_0,unsigned long _Indexes>__compressed_pair_elem(class::std::__1::piecewise_construct_t,tuple<...>,__tuple_indices<...>)
public:int(*&__get()){return this->__value_;
}
public:int(*const&__get()const){return this->__value_;
}
private:
private:int(*__value_);
}
template<>class __compressed_pair_elem<class::std::__1::allocator<int>,1,1>:private allocator<int>{public:typedef class::std::__1::allocator<int>_ParamT;
public:typedef class::std::__1::allocator<int>&reference;
public:typedef class allocator const&const_reference;
public:typedef class::std::__1::allocator<int>__value_type;
public:__compressed_pair_elem():allocator(){}
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__compressed_pair_elem(__xcodeml_template_type_0_0(*__u))
public:template<typename __xcodeml_template_type_0_0,unsigned long _Indexes>__compressed_pair_elem(class::std::__1::piecewise_construct_t,tuple<...>,__tuple_indices<...>)
public:class::std::__1::allocator<int>&__get(){return(*this);
}
public:class allocator const&__get()const{return(*this);
}
}
template<>class __compressed_pair_elem<class::std::__1::allocator<int>&,1,0>{public:typedef class::std::__1::allocator<int>&_ParamT;
public:typedef class::std::__1::allocator<int>&reference;
public:typedef class::std::__1::allocator<int>&const_reference;
public:__compressed_pair_elem();
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__compressed_pair_elem(__xcodeml_template_type_0_0(*__u))
template <>__compressed_pair_elem(class::std::__1::allocator<int>&__u):__value_((std::__1::forward<class::std::__1::allocator<int>&>(__u))){}
public:template<typename __xcodeml_template_type_0_0,unsigned long _Indexes>__compressed_pair_elem(class::std::__1::piecewise_construct_t,tuple<...>,__tuple_indices<...>)
public:class::std::__1::allocator<int>&__get(){return this->__value_;
}
public:class::std::__1::allocator<int>&__get()const;
private:
private:class::std::__1::allocator<int>&__value_;
}
;
template<typename __xcodeml_template_type_0_0,int _Idx>class __compressed_pair_elem<__xcodeml_template_type_0_0,expression,1>:private __xcodeml_template_type_0_0{public:typedef __xcodeml_template_type_0_0 _ParamT;
public:typedef __xcodeml_template_type_0_0&reference;
public:typedef __xcodeml_template_type_0_0 const&const_reference;
public:typedef __xcodeml_template_type_0_0 __value_type;
public:__compressed_pair_elem();
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>__compressed_pair_elem(__xcodeml_template_type_1_0(*__u)):((std::__1::__xcodeml_template_type_1_0(__u))){}
public:template<typename __xcodeml_template_type_1_0,unsigned long _Indexes>__compressed_pair_elem(class::std::__1::piecewise_construct_t,tuple<...>,__tuple_indices<...>):((std::__1::__xcodeml_template_type_1_0((std::__1::_Indexes(__args))))){}
public:__xcodeml_template_type_0_0&__get(){return(*this);
}
public:__xcodeml_template_type_0_0 const&__get()const{return(*this);
}
}
;
class __second_tag{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __compressed_pair:private __compressed_pair_elem<__xcodeml_template_type_0_0,0,expression>,private __compressed_pair_elem<__xcodeml_template_type_0_1,1,expression>{private:typedef __compressed_pair_elem<__xcodeml_template_type_0_0,0,expression>;
private:typedef __compressed_pair_elem<__xcodeml_template_type_0_1,1,expression>;

/* Ignored a member with no access specifier (!is_same<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::value)"__compressed_pair cannot be instantated when T1 and T2 are the same type; The current implementation is NOT ABI-compatible with the previous implementation for this configuration";*/

public:
public:template<bool _Dummy=true,typename __xcodeml_template_type_1_1>__compressed_pair(){}
public:template<typename __xcodeml_template_type_1_0,typename enable_if<expression,bool>::type=true>__compressed_pair(__xcodeml_template_type_1_0(*__t)):((std::__xcodeml_template_type_1_0(__t))),(){}
public:template<typename __xcodeml_template_type_1_0>__compressed_pair(class::std::__1::__second_tag,__xcodeml_template_type_1_0(*__t)):(),((std::__xcodeml_template_type_1_0(__t))){}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>__compressed_pair(__xcodeml_template_type_1_0(*__t1),__xcodeml_template_type_1_1(*__t2)):((std::__xcodeml_template_type_1_0(__t1))),((std::__xcodeml_template_type_1_1(__t2))){}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>__compressed_pair(class::std::__1::piecewise_construct_t __pc,tuple<...>,tuple<...>):(__pc(std::__1::(__first_args))__xcodeml_identity<typename __make_tuple_indices<expression,0>::type>::t()),(__pc(std::__1::(__second_args))__xcodeml_identity<typename __make_tuple_indices<expression,0>::type>::t()){}
public:typename __compressed_pair_elem<__xcodeml_template_type_0_0,0,expression>::reference first(){return(static_cast<__compressed_pair_elem<__xcodeml_template_type_0_0,0,expression> >((*this)).__get());
}
public:typename __compressed_pair_elem<__xcodeml_template_type_0_0,0,expression>::const_reference first()const{return(static_cast<__compressed_pair_elem<__xcodeml_template_type_0_0,0,expression> >((*this)).__get());
}
public:typename __compressed_pair_elem<__xcodeml_template_type_0_1,1,expression>::reference second(){return(static_cast<__compressed_pair_elem<__xcodeml_template_type_0_1,1,expression> >((*this)).__get());
}
public:typename __compressed_pair_elem<__xcodeml_template_type_0_1,1,expression>::const_reference second()const{return(static_cast<__compressed_pair_elem<__xcodeml_template_type_0_1,1,expression> >((*this)).__get());
}
public:void swap(class __compressed_pair&__x){std::;
(((()),(__x.first())));
(((()),(__x.second())));
}
}
;
template<>class __compressed_pair<void(*),class::std::__1::__builtin_new_allocator::__builtin_new_deleter>:private __compressed_pair_elem<void(*),0,0>,private __compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0>{private:typedef class::std::__1::__compressed_pair_elem<void(*),0,0>_Base1;
private:typedef class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0>_Base2;

/* Ignored a member with no access specifier (!is_same::value)"__compressed_pair cannot be instantated when T1 and T2 are the same type; The current implementation is NOT ABI-compatible with the previous implementation for this configuration";*/

public:
public:template<bool _Dummy=true,typename __xcodeml_template_type_0_1>__compressed_pair()
public:template<typename __xcodeml_template_type_0_0,typename enable_if<expression,bool>::type=true>__compressed_pair(__xcodeml_template_type_0_0(*__t))
public:template<typename __xcodeml_template_type_0_0>__compressed_pair(class::std::__1::__second_tag,__xcodeml_template_type_0_0(*__t))
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__compressed_pair(__xcodeml_template_type_0_0(*__t1),__xcodeml_template_type_0_1(*__t2))
template <>__compressed_pair(void(*&__t1),class::std::__1::__builtin_new_allocator::__builtin_new_deleter(*__t2)):__compressed_pair_elem((std::forward<void(*&)>(__t1))),__compressed_pair_elem((std::forward<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>(__t2))){}
template <>__compressed_pair(void(*(*__t1)),class::std::__1::__builtin_new_allocator::__builtin_new_deleter(*__t2)):__compressed_pair_elem((std::forward<void(*)>(__t1))),__compressed_pair_elem((std::forward<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>(__t2))){}
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__compressed_pair(class::std::__1::piecewise_construct_t __pc,tuple<...>,tuple<...>)
public:void(*&first()){return(static_cast<class::std::__1::__compressed_pair_elem<void(*),0,0>&>((*this)).__get());
}
public:void(*const&first()const);
public:class::std::__1::__builtin_new_allocator::__builtin_new_deleter&second(){return(static_cast<class::std::__1::__compressed_pair_elem<class::std::__1::__builtin_new_allocator::__builtin_new_deleter,1,0>&>((*this)).__get());
}
public:class __builtin_new_deleter const&second()const;
public:void swap(class::std::__1::__compressed_pair<void(*),class::std::__1::__builtin_new_allocator::__builtin_new_deleter>&__x);
}
template<>class __compressed_pair<int(*),class::std::__1::allocator<int> >:private __compressed_pair_elem<int(*),0,0>,private __compressed_pair_elem<class::std::__1::allocator<int>,1,1>{private:typedef class::std::__1::__compressed_pair_elem<int(*),0,0>_Base1;
private:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1>_Base2;

/* Ignored a member with no access specifier (!is_same::value)"__compressed_pair cannot be instantated when T1 and T2 are the same type; The current implementation is NOT ABI-compatible with the previous implementation for this configuration";*/

public:
public:template<bool _Dummy=true,typename __xcodeml_template_type_0_1>__compressed_pair()
public:template<typename __xcodeml_template_type_0_0,typename enable_if<expression,bool>::type=true>__compressed_pair(__xcodeml_template_type_0_0(*__t))
template <>__compressed_pair(nullptr_t(*__t)):__compressed_pair_elem((std::forward<nullptr_t>(__t))),__compressed_pair_elem(){}
public:template<typename __xcodeml_template_type_0_0>__compressed_pair(class::std::__1::__second_tag,__xcodeml_template_type_0_0(*__t))
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__compressed_pair(__xcodeml_template_type_0_0(*__t1),__xcodeml_template_type_0_1(*__t2))
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__compressed_pair(class::std::__1::piecewise_construct_t __pc,tuple<...>,tuple<...>)
public:int(*&first()){return(static_cast<class::std::__1::__compressed_pair_elem<int(*),0,0>&>((*this)).__get());
}
public:int(*const&first()const){return(static_cast<class __compressed_pair_elem const&>((*this)).__get());
}
public:class::std::__1::allocator<int>&second(){return(static_cast<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>,1,1>&>((*this)).__get());
}
public:class allocator const&second()const{return(static_cast<class __compressed_pair_elem const&>((*this)).__get());
}
public:void swap(class::std::__1::__compressed_pair<int(*),class::std::__1::allocator<int> >&__x);
}
template<>class __compressed_pair<int(*),class::std::__1::allocator<int>&>:private __compressed_pair_elem<int(*),0,0>,private __compressed_pair_elem<class::std::__1::allocator<int>&,1,0>{private:typedef class::std::__1::__compressed_pair_elem<int(*),0,0>_Base1;
private:typedef class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0>_Base2;

/* Ignored a member with no access specifier (!is_same::value)"__compressed_pair cannot be instantated when T1 and T2 are the same type; The current implementation is NOT ABI-compatible with the previous implementation for this configuration";*/

public:
public:template<bool _Dummy=true,typename __xcodeml_template_type_0_1>__compressed_pair()
public:template<typename __xcodeml_template_type_0_0,typename enable_if<expression,bool>::type=true>__compressed_pair(__xcodeml_template_type_0_0(*__t))
public:template<typename __xcodeml_template_type_0_0>__compressed_pair(class::std::__1::__second_tag,__xcodeml_template_type_0_0(*__t))
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__compressed_pair(__xcodeml_template_type_0_0(*__t1),__xcodeml_template_type_0_1(*__t2))
template <>__compressed_pair(nullptr_t(*__t1),class::std::__1::allocator<int>&__t2):__compressed_pair_elem((std::forward<nullptr_t>(__t1))),__compressed_pair_elem((std::forward<class::std::__1::allocator<int>&>(__t2))){}
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__compressed_pair(class::std::__1::piecewise_construct_t __pc,tuple<...>,tuple<...>)
public:int(*&first()){return(static_cast<class::std::__1::__compressed_pair_elem<int(*),0,0>&>((*this)).__get());
}
public:int(*const&first()const){return(static_cast<class __compressed_pair_elem const&>((*this)).__get());
}
public:class::std::__1::allocator<int>&second(){return(static_cast<class::std::__1::__compressed_pair_elem<class::std::__1::allocator<int>&,1,0>&>((*this)).__get());
}
public:class::std::__1::allocator<int>&second()const;
public:void swap(class::std::__1::__compressed_pair<int(*),class::std::__1::allocator<int>&>&__x);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void swap(__compressed_pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,__compressed_pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>){(__x.swap(__y));
}
template<typename __xcodeml_template_type_0_0>class default_delete{
/* Ignored a member with no access specifier (!is_function<__xcodeml_template_type_0_0>::value)"default_delete cannot be instantiated for function types";*/

public:default_delete();
public:template<typename __xcodeml_template_type_1_0>default_delete(default_delete<__xcodeml_template_type_1_0>,typename enable_if<expression,void>::type(*)){}
public:void operator()(__xcodeml_template_type_0_0(*__ptr))const{((sizeof(__xcodeml_template_type_0_0))>0)"default_delete can not delete incomplete type";
(!is_void<__xcodeml_template_type_0_0>::.value)"default_delete can not delete incomplete type";
delete __ptr;
}
}
;
template<>class default_delete;
template<typename __xcodeml_template_type_0_0>class default_delete<__xcodeml_template_type_0_0>{private:
private:template<typename __xcodeml_template_type_1_0>class _EnableIfConvertible:public enable_if<expression,void>{}
;
;
public:
public:default_delete();
public:template<typename __xcodeml_template_type_1_0>default_delete(default_delete<__xcodeml_template_type_1_0>,typename _EnableIfConvertible<__xcodeml_template_type_1_0>::type(*)){}
public:template<typename __xcodeml_template_type_1_0>typename _EnableIfConvertible<__xcodeml_template_type_1_0>::type operator()(__xcodeml_template_type_1_0(*__ptr))const{((sizeof(__xcodeml_template_type_0_0))>0)"default_delete can not delete incomplete type";
(!is_void<__xcodeml_template_type_0_0>::.value)"default_delete can not delete void type";
delete[]__ptr;
}
}
;
template<typename __xcodeml_template_type_0_0>class __unique_ptr_deleter_sfinae{
/* Ignored a member with no access specifier (!is_reference<__xcodeml_template_type_0_0>::value)"incorrect specialization";*/

public:typedef __xcodeml_template_type_0_0 const&__lval_ref_type;
public:typedef __xcodeml_template_type_0_0(*__good_rval_ref_type);
public:typedef class::std::__1::integral_constant<bool,1>__enable_rval_overload;
}
;
template<>class __unique_ptr_deleter_sfinae<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>{
/* Ignored a member with no access specifier (!is_reference::value)"incorrect specialization";*/

public:typedef class __builtin_new_deleter const&__lval_ref_type;
public:typedef class::std::__1::__builtin_new_allocator::__builtin_new_deleter(*__good_rval_ref_type);
public:typedef class::std::__1::integral_constant<bool,1>__enable_rval_overload;
}
;
template<typename __xcodeml_template_type_0_0>class __unique_ptr_deleter_sfinae<__xcodeml_template_type_0_0 const&>{public:typedef __xcodeml_template_type_0_0 const&__lval_ref_type;
public:typedef __xcodeml_template_type_0_0 const(*__bad_rval_ref_type);
public:typedef class::std::__1::integral_constant<bool,0>__enable_rval_overload;
}
;
template<typename __xcodeml_template_type_0_0>class __unique_ptr_deleter_sfinae<__xcodeml_template_type_0_0&>{public:typedef __xcodeml_template_type_0_0&__lval_ref_type;
public:typedef __xcodeml_template_type_0_0(*__bad_rval_ref_type);
public:typedef class::std::__1::integral_constant<bool,0>__enable_rval_overload;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class unique_ptr{public:
public:typedef __xcodeml_template_type_0_0 element_type;
public:typedef __xcodeml_template_type_0_1 deleter_type;
public:typedef typename __pointer_type<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::type pointer;

/* Ignored a member with no access specifier (!is_rvalue_reference<__xcodeml_template_type_0_1>::value)"the specified deleter type cannot be an rvalue reference";*/

private:
private:__compressed_pair<typename __pointer_type<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::type,__xcodeml_template_type_0_1>;
private:class __nat{public:int __for_bool_;
}
;
private:typedef __unique_ptr_deleter_sfinae<__xcodeml_template_type_0_1>;
private:template<bool _Dummy>using _LValRefType=typename __dependent_type<__unique_ptr_deleter_sfinae<__xcodeml_template_type_0_1>,expression>::__lval_ref_type;
private:template<bool _Dummy>using _GoodRValRefType=typename __dependent_type<__unique_ptr_deleter_sfinae<__xcodeml_template_type_0_1>,expression>::__good_rval_ref_type;
private:template<bool _Dummy>using _BadRValRefType=typename __dependent_type<__unique_ptr_deleter_sfinae<__xcodeml_template_type_0_1>,expression>::__bad_rval_ref_type;
private:template<bool _Dummy,typename __xcodeml_template_type_1_1>using _EnableIfDeleterDefaultConstructible=typename enable_if<expression,void>::type;
private:template<typename __xcodeml_template_type_1_0>using _EnableIfDeleterConstructible=typename enable_if<expression,void>::type;
private:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>using _EnableIfMoveConvertible=typename enable_if<expression,void>::type;
private:template<typename __xcodeml_template_type_1_0>using _EnableIfDeleterConvertible=typename enable_if<expression,void>::type;
private:template<typename __xcodeml_template_type_1_0>using _EnableIfDeleterAssignable=typename enable_if<expression,void>::type;
public:
public:template<bool _Dummy=true,typename __xcodeml_template_type_1_1>unique_ptr():__ptr_(__xcodeml_identity<typename __pointer_type<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::type>::t()){}
public:template<bool _Dummy=true,typename __xcodeml_template_type_1_1>unique_ptr(nullptr_t):__ptr_(__xcodeml_identity<typename __pointer_type<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::type>::t()){}
public:template<bool _Dummy=true,typename __xcodeml_template_type_1_1>unique_ptr(typename __pointer_type<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::type __p):__ptr_(__p){}
public:template<bool _Dummy=true,typename __xcodeml_template_type_1_1>unique_ptr(typename __pointer_type<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::type __p,typename __dependent_type<__unique_ptr_deleter_sfinae<__xcodeml_template_type_0_1>,expression>::__lval_ref_type __d):__ptr_(__p __d){}
public:template<bool _Dummy=true,typename __xcodeml_template_type_1_1>unique_ptr(typename __pointer_type<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::type __p,typename __dependent_type<__unique_ptr_deleter_sfinae<__xcodeml_template_type_0_1>,expression>::__good_rval_ref_type __d):__ptr_(__p(std::__1::(__d))){(!is_reference<__xcodeml_template_type_0_1>::.value)"rvalue deleter bound to reference";
}
public:template<bool _Dummy=true,typename __xcodeml_template_type_1_1>unique_ptr(typename __pointer_type<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::type __p,typename __dependent_type<__unique_ptr_deleter_sfinae<__xcodeml_template_type_0_1>,expression>::__bad_rval_ref_type __d)
public:unique_ptr(class unique_ptr(*__u)):__ptr_((__u.release())(std::__1::__xcodeml_template_type_0_1((__u.get_deleter())))){}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1,typename __xcodeml_template_type_1_2,typename __xcodeml_template_type_1_3>unique_ptr(unique_ptr<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1>):__ptr_((__u.release())(std::__1::__xcodeml_template_type_1_1((__u.get_deleter())))){}
public:template<typename __xcodeml_template_type_1_0>unique_ptr(auto_ptr<__xcodeml_template_type_1_0>,typename enable_if<expression,class::std::__1::unique_ptr::__nat>::type):__ptr_((__p.release())){}
public:class unique_ptr&operator=(class unique_ptr(*__u)){(this->reset((__u.release())));
((this->__ptr_.second())=(std::__1::__xcodeml_template_type_0_1((__u.get_deleter()))));
return(*this);
}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1,typename __xcodeml_template_type_1_2,typename __xcodeml_template_type_1_3>class unique_ptr&operator=(unique_ptr<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1>){(this->reset((__u.release())));
((this->__ptr_.second())=(std::__1::__xcodeml_template_type_1_1((__u.get_deleter()))));
return(*this);
}
public:template<typename __xcodeml_template_type_1_0>typename enable_if<expression,class unique_ptr&>::type operator=(auto_ptr<__xcodeml_template_type_1_0>){(this->reset((__p.release())));
return(*this);
}
public:~unique_ptr(){(this->reset());
}
public:class unique_ptr&operator=(nullptr_t){(this->reset());
return(*this);
}
public:typename add_lvalue_reference<__xcodeml_template_type_0_0>::type operator*()const{return(*(this->__ptr_.first()));
}
public:typename __pointer_type<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::type operator->()const{return(this->__ptr_.first());
}
public:typename __pointer_type<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::type get()const{return(this->__ptr_.first());
}
public:__xcodeml_template_type_0_1&get_deleter(){return(this->__ptr_.second());
}
public:__xcodeml_template_type_0_1 const&get_deleter()const{return(this->__ptr_.second());
}
public:operator bool()const{return((this->__ptr_.first()),nullptr);
}
public:typename __pointer_type<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::type release(){typename __pointer_type<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::type __t=(this->__ptr_.first());
((this->__ptr_.first())=__xcodeml_identity<typename __pointer_type<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::type>::t());
return __t;
}
public:void reset(typename __pointer_type<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::type __p){typename __pointer_type<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::type __tmp=(this->__ptr_.first());
((this->__ptr_.first())=__p);
if(__tmp){((this->__ptr_.second())(__tmp));};
}
public:void swap(class unique_ptr&__u){(this->__ptr_.swap(__u.__ptr_));
}
}
;
template<>class unique_ptr<void,class::std::__1::__builtin_new_allocator::__builtin_new_deleter>{public:
public:typedef void element_type;
public:typedef class::std::__1::__builtin_new_allocator::__builtin_new_deleter deleter_type;
public:typedef void(*pointer);

/* Ignored a member with no access specifier (!is_rvalue_reference::value)"the specified deleter type cannot be an rvalue reference";*/

private:
private:class::std::__1::__compressed_pair<void(*),class::std::__1::__builtin_new_allocator::__builtin_new_deleter>__ptr_;
private:class __nat;
private:typedef class::std::__1::__unique_ptr_deleter_sfinae<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>_DeleterSFINAE;
private:template<bool _Dummy>using _LValRefType=typename __dependent_type<class::std::__1::__unique_ptr_deleter_sfinae<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>,expression>::__lval_ref_type;
private:template<bool _Dummy>using _GoodRValRefType=typename __dependent_type<class::std::__1::__unique_ptr_deleter_sfinae<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>,expression>::__good_rval_ref_type;
private:template<bool _Dummy>using _BadRValRefType=typename __dependent_type<class::std::__1::__unique_ptr_deleter_sfinae<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>,expression>::__bad_rval_ref_type;
private:template<bool _Dummy,typename __xcodeml_template_type_0_1>using _EnableIfDeleterDefaultConstructible=typename enable_if<expression,void>::type;
private:template<typename __xcodeml_template_type_0_0>using _EnableIfDeleterConstructible=typename enable_if<expression,void>::type;
private:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>using _EnableIfMoveConvertible=typename enable_if<expression,void>::type;
private:template<typename __xcodeml_template_type_0_0>using _EnableIfDeleterConvertible=typename enable_if<expression,void>::type;
private:template<typename __xcodeml_template_type_0_0>using _EnableIfDeleterAssignable=typename enable_if<expression,void>::type;
public:
public:template<bool _Dummy=true,typename __xcodeml_template_type_0_1>unique_ptr()
public:template<bool _Dummy=true,typename __xcodeml_template_type_0_1>unique_ptr(nullptr_t)
public:template<bool _Dummy=true,typename __xcodeml_template_type_0_1>unique_ptr(void(*__p))
public:template<bool _Dummy=true,typename __xcodeml_template_type_0_1>unique_ptr(void(*__p),typename __dependent_type<class::std::__1::__unique_ptr_deleter_sfinae<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>,expression>::__lval_ref_type __d)
template <>unique_ptr(void(*__p),class __builtin_new_deleter const&__d)
public:template<bool _Dummy=true,typename __xcodeml_template_type_0_1>unique_ptr(void(*__p),typename __dependent_type<class::std::__1::__unique_ptr_deleter_sfinae<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>,expression>::__good_rval_ref_type __d)
template <>unique_ptr(void(*__p),class::std::__1::__builtin_new_allocator::__builtin_new_deleter(*__d)):__ptr_(__p,(std::__1::move(__d))){(!is_reference::value)"rvalue deleter bound to reference";
}
public:template<bool _Dummy=true,typename __xcodeml_template_type_0_1>unique_ptr(void(*__p),typename __dependent_type<class::std::__1::__unique_ptr_deleter_sfinae<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>,expression>::__bad_rval_ref_type __d)
public:unique_ptr(class::std::__1::unique_ptr<void,class::std::__1::__builtin_new_allocator::__builtin_new_deleter>(*__u)):__ptr_((__u.release())){}
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>unique_ptr(unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>)
template <>unique_ptr(class::std::__1::unique_ptr<void,class::std::__1::__builtin_new_allocator::__builtin_new_deleter>(*__u))
public:template<typename __xcodeml_template_type_0_0>unique_ptr(auto_ptr<__xcodeml_template_type_0_0>,typename enable_if<expression,class::std::__1::unique_ptr<void,class::std::__1::__builtin_new_allocator::__builtin_new_deleter>::__nat>::type)
public:class::std::__1::unique_ptr<void,class::std::__1::__builtin_new_allocator::__builtin_new_deleter>&operator=(class::std::__1::unique_ptr<void,class::std::__1::__builtin_new_allocator::__builtin_new_deleter>(*__u));
public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>class::std::__1::unique_ptr<void,class::std::__1::__builtin_new_allocator::__builtin_new_deleter>&operator=(unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>)
public:template<typename __xcodeml_template_type_0_0>typename enable_if<expression,class::std::__1::unique_ptr<void,class::std::__1::__builtin_new_allocator::__builtin_new_deleter>&>::type operator=(auto_ptr<__xcodeml_template_type_0_0>)
public:~unique_ptr(){(this->reset(void(*)));
}
public:class::std::__1::unique_ptr<void,class::std::__1::__builtin_new_allocator::__builtin_new_deleter>&operator=(nullptr_t);
public:void operator*()const;
public:void(*operator->()const);
public:void(*get()const);
public:class::std::__1::__builtin_new_allocator::__builtin_new_deleter&get_deleter(){return(this->__ptr_.second());
}
public:class __builtin_new_deleter const&get_deleter()const;
public:operator bool()const;
public:void(*release()){void(*__t)=(this->__ptr_.first());
((this->__ptr_.first())=void(*));
return __t;
}
public:void reset(void(*__p)){void(*__tmp)=(this->__ptr_.first());
((this->__ptr_.first())=__p);
if(__tmp){(this->__ptr_.second()).operator()(__tmp);};
}
public:void swap(class::std::__1::unique_ptr<void,class::std::__1::__builtin_new_allocator::__builtin_new_deleter>&__u);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>{public:
public:typedef __xcodeml_template_type_0_0 element_type;
public:typedef __xcodeml_template_type_0_1 deleter_type;
public:typedef typename __pointer_type<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::type pointer;
private:
private:__compressed_pair<typename __pointer_type<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::type,__xcodeml_template_type_0_1>;
private:template<typename __xcodeml_template_type_1_0>class _CheckArrayPointerConversion:public is_same<__xcodeml_template_type_1_0,typename __pointer_type<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::type>{}
;
;

/* Ignored a member with no access specifier template<typename __xcodeml_template_type_1_0>class _CheckArrayPointerConversion<__xcodeml_template_type_1_0(*)>:public integral_constant<bool,expression>{}
;*/

private:typedef __unique_ptr_deleter_sfinae<__xcodeml_template_type_0_1>;
private:template<bool _Dummy>using _LValRefType=typename __dependent_type<__unique_ptr_deleter_sfinae<__xcodeml_template_type_0_1>,expression>::__lval_ref_type;
private:template<bool _Dummy>using _GoodRValRefType=typename __dependent_type<__unique_ptr_deleter_sfinae<__xcodeml_template_type_0_1>,expression>::__good_rval_ref_type;
private:template<bool _Dummy>using _BadRValRefType=typename __dependent_type<__unique_ptr_deleter_sfinae<__xcodeml_template_type_0_1>,expression>::__bad_rval_ref_type;
private:template<bool _Dummy,typename __xcodeml_template_type_1_1>using _EnableIfDeleterDefaultConstructible=typename enable_if<expression,void>::type;
private:template<typename __xcodeml_template_type_1_0>using _EnableIfDeleterConstructible=typename enable_if<expression,void>::type;
private:template<typename __xcodeml_template_type_1_0>using _EnableIfPointerConvertible=typename enable_if<expression,void>::type;
private:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1,typename __xcodeml_template_type_1_2>using _EnableIfMoveConvertible=typename enable_if<expression,void>::type;
private:template<typename __xcodeml_template_type_1_0>using _EnableIfDeleterConvertible=typename enable_if<expression,void>::type;
private:template<typename __xcodeml_template_type_1_0>using _EnableIfDeleterAssignable=typename enable_if<expression,void>::type;
public:
public:template<bool _Dummy=true,typename __xcodeml_template_type_1_1>unique_ptr():__ptr_(__xcodeml_identity<typename __pointer_type<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::type>::t()){}
public:template<bool _Dummy=true,typename __xcodeml_template_type_1_1>unique_ptr(nullptr_t):__ptr_(__xcodeml_identity<typename __pointer_type<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::type>::t()){}
public:template<typename __xcodeml_template_type_1_0,bool _Dummy=true,typename __xcodeml_template_type_1_2,typename __xcodeml_template_type_1_3>unique_ptr(__xcodeml_template_type_1_0 __p):__ptr_(__p){}
public:template<typename __xcodeml_template_type_1_0,bool _Dummy=true,typename __xcodeml_template_type_1_2,typename __xcodeml_template_type_1_3>unique_ptr(__xcodeml_template_type_1_0 __p,typename __dependent_type<__unique_ptr_deleter_sfinae<__xcodeml_template_type_0_1>,expression>::__lval_ref_type __d):__ptr_(__p __d){}
public:template<bool _Dummy=true,typename __xcodeml_template_type_1_1>unique_ptr(nullptr_t,typename __dependent_type<__unique_ptr_deleter_sfinae<__xcodeml_template_type_0_1>,expression>::__lval_ref_type __d):__ptr_(nullptr __d){}
public:template<typename __xcodeml_template_type_1_0,bool _Dummy=true,typename __xcodeml_template_type_1_2,typename __xcodeml_template_type_1_3>unique_ptr(__xcodeml_template_type_1_0 __p,typename __dependent_type<__unique_ptr_deleter_sfinae<__xcodeml_template_type_0_1>,expression>::__good_rval_ref_type __d):__ptr_(__p(std::__1::(__d))){(!is_reference<__xcodeml_template_type_0_1>::.value)"rvalue deleter bound to reference";
}
public:template<bool _Dummy=true,typename __xcodeml_template_type_1_1>unique_ptr(nullptr_t,typename __dependent_type<__unique_ptr_deleter_sfinae<__xcodeml_template_type_0_1>,expression>::__good_rval_ref_type __d):__ptr_(nullptr(std::__1::(__d))){(!is_reference<__xcodeml_template_type_0_1>::.value)"rvalue deleter bound to reference";
}
public:template<typename __xcodeml_template_type_1_0,bool _Dummy=true,typename __xcodeml_template_type_1_2,typename __xcodeml_template_type_1_3>unique_ptr(__xcodeml_template_type_1_0 __p,typename __dependent_type<__unique_ptr_deleter_sfinae<__xcodeml_template_type_0_1>,expression>::__bad_rval_ref_type __d)
public:unique_ptr(class unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>(*__u)):__ptr_((__u.release())(std::__1::__xcodeml_template_type_0_1((__u.get_deleter())))){}
public:class unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>&operator=(class unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>(*__u)){(((__u.release())));
((this->__ptr_.second())=(std::__1::__xcodeml_template_type_0_1((__u.get_deleter()))));
return(*this);
}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1,typename __xcodeml_template_type_1_2,typename __xcodeml_template_type_1_3>unique_ptr(unique_ptr<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1>):__ptr_((__u.release())(std::__1::__xcodeml_template_type_1_1((__u.get_deleter())))){}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1,typename __xcodeml_template_type_1_2,typename __xcodeml_template_type_1_3>class unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>&operator=(unique_ptr<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1>){(((__u.release())));
((this->__ptr_.second())=(std::__1::__xcodeml_template_type_1_1((__u.get_deleter()))));
return(*this);
}
public:
public:~unique_ptr(){(());
}
public:class unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>&operator=(nullptr_t){(());
return(*this);
}
public:typename add_lvalue_reference<__xcodeml_template_type_0_0>::type operator[](unsigned long __i)const{return((this->__ptr_.first()))[__i];
}
public:typename __pointer_type<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::type get()const{return(this->__ptr_.first());
}
public:__xcodeml_template_type_0_1&get_deleter(){return(this->__ptr_.second());
}
public:__xcodeml_template_type_0_1 const&get_deleter()const{return(this->__ptr_.second());
}
public:operator bool()const{return((this->__ptr_.first()),nullptr);
}
public:typename __pointer_type<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::type release(){typename __pointer_type<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::type __t=(this->__ptr_.first());
((this->__ptr_.first())=__xcodeml_identity<typename __pointer_type<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::type>::t());
return __t;
}
public:template<typename __xcodeml_template_type_1_0>typename enable_if<expression,void>::type reset(__xcodeml_template_type_1_0 __p){typename __pointer_type<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::type __tmp=(this->__ptr_.first());
((this->__ptr_.first())=__p);
if(__tmp){((this->__ptr_.second())(__tmp));};
}
public:void reset(nullptr_t){typename __pointer_type<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::type __tmp=(this->__ptr_.first());
((this->__ptr_.first())=nullptr);
if(__tmp){((this->__ptr_.second())(__tmp));};
}
public:void swap(class unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>&__u){(this->__ptr_.swap(__u.__ptr_));
}
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename enable_if<expression,void>::type swap(unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>){(__x.swap(__y));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>bool operator==(unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,unique_ptr<__xcodeml_template_type_0_2,__xcodeml_template_type_0_3>){return((__x.get()),(__y.get()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>bool operator!=(unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,unique_ptr<__xcodeml_template_type_0_2,__xcodeml_template_type_0_3>){return(!(__x,__y));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>bool operator<(unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,unique_ptr<__xcodeml_template_type_0_2,__xcodeml_template_type_0_3>){typedef typename unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer _P1;
typedef typename unique_ptr<__xcodeml_template_type_0_2,__xcodeml_template_type_0_3>::pointer _P2;
typedef typename common_type<...>::type _Vp;
return(__xcodeml_identity<less<typename common_type<...>::type> >::t()((__x.get()),(__y.get())));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>bool operator>(unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,unique_ptr<__xcodeml_template_type_0_2,__xcodeml_template_type_0_3>){return(__y,__x);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>bool operator<=(unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,unique_ptr<__xcodeml_template_type_0_2,__xcodeml_template_type_0_3>){return(!(__y,__x));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>bool operator>=(unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,unique_ptr<__xcodeml_template_type_0_2,__xcodeml_template_type_0_3>){return(!(__x,__y));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator==(unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,nullptr_t){return(!__x);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator==(nullptr_t,unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>){return(!__x);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator!=(unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,nullptr_t){return static_cast<bool>(__x);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator!=(nullptr_t,unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>){return static_cast<bool>(__x);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator<(unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,nullptr_t){typedef typename unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer _P1;
return(__xcodeml_identity<less<typename unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer> >::t()((__x.get()),nullptr));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator<(nullptr_t,unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>){typedef typename unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer _P1;
return(__xcodeml_identity<less<typename unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer> >::t()(nullptr,(__x.get())));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator>(unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,nullptr_t){return(nullptr,__x);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator>(nullptr_t,unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>){return(__x,nullptr);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator<=(unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,nullptr_t){return(!(nullptr,__x));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator<=(nullptr_t,unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>){return(!(__x,nullptr));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator>=(unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,nullptr_t){return(!(__x,nullptr));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator>=(nullptr_t,unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>){return(!(nullptr,__x));
}
template<typename __xcodeml_template_type_0_0>class __unique_if{public:typedef unique_ptr<__xcodeml_template_type_0_0,default_delete<__xcodeml_template_type_0_0> >;
}
;
;
template<typename __xcodeml_template_type_0_0>class __unique_if<__xcodeml_template_type_0_0>{public:typedef unique_ptr<__xcodeml_template_type_0_0,default_delete<__xcodeml_template_type_0_0> >;
}
;
template<typename __xcodeml_template_type_0_0,unsigned long _Np>class __unique_if<__xcodeml_template_type_0_0>{public:typedef void __unique_array_known_bound;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename __unique_if<__xcodeml_template_type_0_0>::__unique_single make_unique(void/*__args*/){return __xcodeml_identity<unique_ptr<__xcodeml_template_type_0_0,default_delete<__xcodeml_template_type_0_0> > >::t(new __xcodeml_identity<__xcodeml_template_type_0_0>::t((std::__1::__xcodeml_template_type_0_1(__args))));
}
template<typename __xcodeml_template_type_0_0>typename __unique_if<__xcodeml_template_type_0_0>::__unique_array_unknown_bound make_unique(unsigned long __n){typedef typename remove_extent<__xcodeml_template_type_0_0>::type _Up;
return __xcodeml_identity<unique_ptr<__xcodeml_template_type_0_0,default_delete<__xcodeml_template_type_0_0> > >::t(new __xcodeml_identity<typename remove_extent<__xcodeml_template_type_0_0>::type>::t[__n]());
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename __unique_if<__xcodeml_template_type_0_0>::__unique_array_known_bound make_unique(void/**/)
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class hash<unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1> >{public:typedef unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>;
public:typedef unsigned long result_type;
public:unsigned long operator()(unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>)const{typedef typename unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer pointer;
return(__xcodeml_identity<hash<typename unique_ptr<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer> >::t()((__ptr.get())));
}
}
;
class __destruct_n{private:
private:unsigned long __size_;
private:template<typename __xcodeml_template_type_0_0>void __process(__xcodeml_template_type_0_0(*__p),class::std::__1::integral_constant<bool,0>){{unsigned long __i=0;for(;(__i<this->__size_);((++__i),(++__p))){(__xcodeml_template_type_0_0 __p());}};
}
private:template<typename __xcodeml_template_type_0_0>void __process(__xcodeml_template_type_0_0(*),class::std::__1::integral_constant<bool,1>){}
private:void __incr(class::std::__1::integral_constant<bool,0>){(++this->__size_);
}
private:void __incr(class::std::__1::integral_constant<bool,1>){}
private:void __set(unsigned long __s,class::std::__1::integral_constant<bool,0>){(this->__size_=__s);
}
private:void __set(unsigned long,class::std::__1::integral_constant<bool,1>){}
public:
public:__destruct_n(unsigned long __s):__size_(__s){}
public:template<typename __xcodeml_template_type_0_0>void __incr(__xcodeml_template_type_0_0(*)){((__xcodeml_identity<integral_constant<bool,expression> >::t()));
}
public:template<typename __xcodeml_template_type_0_0>void __set(unsigned long __s,__xcodeml_template_type_0_0(*)){((__s,__xcodeml_identity<integral_constant<bool,expression> >::t()));
}
public:template<typename __xcodeml_template_type_0_0>void operator()(__xcodeml_template_type_0_0(*__p)){((__p,__xcodeml_identity<integral_constant<bool,expression> >::t()));
}
}
;
template<typename __xcodeml_template_type_0_0>class __allocator_destructor{private:typedef allocator_traits<__xcodeml_template_type_0_0>;
public:
public:typedef typename allocator_traits<__xcodeml_template_type_0_0>::pointer pointer;
public:typedef typename allocator_traits<__xcodeml_template_type_0_0>::size_type size_type;
private:
private:__xcodeml_template_type_0_0&__alloc_;
private:typename allocator_traits<__xcodeml_template_type_0_0>::size_type __s_;
public:
public:__allocator_destructor(__xcodeml_template_type_0_0&__a,typename allocator_traits<__xcodeml_template_type_0_0>::size_type __s):__alloc_(__a),__s_(__s){}
public:void operator()(typename allocator_traits<__xcodeml_template_type_0_0>::pointer __p){(allocator_traits<__xcodeml_template_type_0_0>::.deallocate(this->__alloc_,__p,this->__s_));
}
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_1 uninitialized_copy(__xcodeml_template_type_0_0 __f,__xcodeml_template_type_0_0 __l,__xcodeml_template_type_0_1 __r){typedef typename iterator_traits<__xcodeml_template_type_0_1>::value_type value_type;
__xcodeml_template_type_0_1 __s=__r;
try{{;for(;(__f,__l);((++__f),((void)(++__r)))){::new(static_cast<void(*)>((std::__1::((*__r)))))__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_1>::value_type>::t((*__f));}};
}catch(...){{;for(;(__s,__r);(++__s)){(typename iterator_traits<__xcodeml_template_type_0_1>::value_type __s());}};
throw;
}
;
return __r;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__xcodeml_template_type_0_2 uninitialized_copy_n(__xcodeml_template_type_0_0 __f,__xcodeml_template_type_0_1 __n,__xcodeml_template_type_0_2 __r){typedef typename iterator_traits<__xcodeml_template_type_0_2>::value_type value_type;
__xcodeml_template_type_0_2 __s=__r;
try{{;for(;(__n,0);(((++__f),((void)(++__r))),((void)(--__n)))){::new(static_cast<void(*)>((std::__1::((*__r)))))__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_2>::value_type>::t((*__f));}};
}catch(...){{;for(;(__s,__r);(++__s)){(typename iterator_traits<__xcodeml_template_type_0_2>::value_type __s());}};
throw;
}
;
return __r;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void uninitialized_fill(__xcodeml_template_type_0_0 __f,__xcodeml_template_type_0_0 __l,__xcodeml_template_type_0_1 const&__x){typedef typename iterator_traits<__xcodeml_template_type_0_0>::value_type value_type;
__xcodeml_template_type_0_0 __s=__f;
try{{;for(;(__f,__l);(++__f)){::new(static_cast<void(*)>((std::__1::((*__f)))))__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_0>::value_type>::t(__x);}};
}catch(...){{;for(;(__s,__f);(++__s)){(typename iterator_traits<__xcodeml_template_type_0_0>::value_type __s());}};
throw;
}
;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__xcodeml_template_type_0_0 uninitialized_fill_n(__xcodeml_template_type_0_0 __f,__xcodeml_template_type_0_1 __n,__xcodeml_template_type_0_2 const&__x){typedef typename iterator_traits<__xcodeml_template_type_0_0>::value_type value_type;
__xcodeml_template_type_0_0 __s=__f;
try{{;for(;(__n,0);((++__f),((void)(--__n)))){::new(static_cast<void(*)>((std::__1::((*__f)))))__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_0>::value_type>::t(__x);}};
}catch(...){{;for(;(__s,__f);(++__s)){(typename iterator_traits<__xcodeml_template_type_0_0>::value_type __s());}};
throw;
}
;
return __f;
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 __libcpp_atomic_refcount_increment(__xcodeml_template_type_0_0&__t){return(__atomic_add_fetch((&__t),1,0));
}
template <>long __libcpp_atomic_refcount_increment(long&__t){return(&__t)0 1;
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 __libcpp_atomic_refcount_decrement(__xcodeml_template_type_0_0&__t){return(__atomic_add_fetch((&__t),(-1),4));
}
template <>long __libcpp_atomic_refcount_decrement(long&__t){return(&__t)4(-1);
}
class bad_weak_ptr:public exception{public:
public:virtual~bad_weak_ptr();
public:virtual char const(*what()const);
}
;
void __throw_bad_weak_ptr(){throw __xcodeml_identity<class::std::__1::bad_weak_ptr>::t();
}
template<typename __xcodeml_template_type_0_0>class weak_ptr;
;
class __shared_count{private:__shared_count(class __shared_count const&);
private:class::std::__1::__shared_count&operator=(class __shared_count const&);
protected:
protected:long __shared_owners_;
protected:virtual~__shared_count();
private:
private:virtual void __on_zero_shared()=0;
public:
public:__shared_count(long __refs):__shared_owners_(__refs){}
public:void __add_shared(){(__libcpp_atomic_refcount_increment(this->__shared_owners_));
}
public:bool __release_shared(){if(((__libcpp_atomic_refcount_decrement(this->__shared_owners_))==(-1))){{(this->__on_zero_shared());
return true;
};};
return false;
}
public:long use_count()const{return((__libcpp_relaxed_load((&this->__shared_owners_)))+1);
}
}
;
class __shared_weak_count:private __shared_count{private:long __shared_weak_owners_;
public:
public:__shared_weak_count(long __refs):__shared_count(__refs),__shared_weak_owners_(__refs){}
protected:
protected:virtual~__shared_weak_count();
public:
public:void __add_shared(){(this->__shared_count::__add_shared());
}
public:void __add_weak(){(__libcpp_atomic_refcount_increment(this->__shared_weak_owners_));
}
public:void __release_shared(){if((this->__shared_count::__release_shared())){(this->__release_weak());};
}
public:void __release_weak();
public:long use_count()const{return(this->__shared_count::use_count());
}
public:class::std::__1::__shared_weak_count(*lock());
public:virtual void const(*__get_deleter(class type_info const&)const);
private:
private:virtual void __on_zero_shared_weak()=0;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __shared_ptr_pointer:public __shared_weak_count{private:__compressed_pair<__compressed_pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,__xcodeml_template_type_0_2>;
public:
public:__shared_ptr_pointer(__xcodeml_template_type_0_0 __p,__xcodeml_template_type_0_1 __d,__xcodeml_template_type_0_2 __a):__data_(__xcodeml_identity<__compressed_pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1> >::t(__p,(std::__1::(__d)))(std::__1::(__a))){}
public:virtual void const(*__get_deleter(class type_info const&)const);
private:
private:virtual void __on_zero_shared();
private:virtual void __on_zero_shared_weak();
}
;
;
void const(*__shared_ptr_pointer::__get_deleter(class type_info const&__t)const){return(__t.operator==(__xcodeml_template_type_0_1)?(std::__1::(((this->__data_.first()).second()))):nullptr);
}
void __shared_ptr_pointer::__on_zero_shared(){(((this->__data_.first()).second())(((this->__data_.first()).first())));
(__xcodeml_template_type_0_1((this->__data_.first()).second())());
}
void __shared_ptr_pointer::__on_zero_shared_weak(){typedef typename __allocator_traits_rebind<__xcodeml_template_type_0_2,class __shared_ptr_pointer,expression>::type _Al;
typedef allocator_traits<typename __allocator_traits_rebind<__xcodeml_template_type_0_2,class __shared_ptr_pointer,expression>::type>;
typedef pointer_traits<typename allocator_traits<typename __allocator_traits_rebind<__xcodeml_template_type_0_2,class __shared_ptr_pointer,expression>::type>::pointer>;
typename __allocator_traits_rebind<__xcodeml_template_type_0_2,class __shared_ptr_pointer,expression>::type __a=(this->__data_.second());
(__xcodeml_template_type_0_2(this->__data_.second())());
(__a.deallocate((pointer_traits<typename allocator_traits<typename __allocator_traits_rebind<__xcodeml_template_type_0_2,class __shared_ptr_pointer,expression>::type>::pointer>::.pointer_to((*this))),1));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __shared_ptr_emplace:public __shared_weak_count{private:__compressed_pair<__xcodeml_template_type_0_1,__xcodeml_template_type_0_0>;
public:
public:__shared_ptr_emplace(__xcodeml_template_type_0_1 __a):__data_((std::__1::(__a))){}
public:template<typename __xcodeml_template_type_1_0>__shared_ptr_emplace(__xcodeml_template_type_0_1 __a,void/*__args*/):__data_(piecewise_construct(std::__1::(__a))(std::__1::((std::__1::__xcodeml_template_type_1_0(__args))))){}
private:
private:virtual void __on_zero_shared();
private:virtual void __on_zero_shared_weak();
public:
public:__xcodeml_template_type_0_0(*get()){return(std::__1::((this->__data_.second())));
}
}
;
;
void __shared_ptr_emplace::__on_zero_shared(){(__xcodeml_template_type_0_0(this->__data_.second())());
}
void __shared_ptr_emplace::__on_zero_shared_weak(){typedef typename __allocator_traits_rebind<__xcodeml_template_type_0_1,class __shared_ptr_emplace,expression>::type _Al;
typedef allocator_traits<typename __allocator_traits_rebind<__xcodeml_template_type_0_1,class __shared_ptr_emplace,expression>::type>;
typedef pointer_traits<typename allocator_traits<typename __allocator_traits_rebind<__xcodeml_template_type_0_1,class __shared_ptr_emplace,expression>::type>::pointer>;
typename __allocator_traits_rebind<__xcodeml_template_type_0_1,class __shared_ptr_emplace,expression>::type __a=(this->__data_.first());
(__xcodeml_template_type_0_1(this->__data_.first())());
(__a.deallocate((pointer_traits<typename allocator_traits<typename __allocator_traits_rebind<__xcodeml_template_type_0_1,class __shared_ptr_emplace,expression>::type>::pointer>::.pointer_to((*this))),1));
}
class __shared_ptr_dummy_rebind_allocator_type;
template<>class allocator<class::std::__1::__shared_ptr_dummy_rebind_allocator_type>{public:
public:template<typename __xcodeml_template_type_0_0>class rebind{public:typedef allocator<__xcodeml_template_type_0_0>;
}
;
;
}
;
template<typename __xcodeml_template_type_0_0>class enable_shared_from_this;
;
template<typename __xcodeml_template_type_0_0>class shared_ptr{public:
public:typedef __xcodeml_template_type_0_0 element_type;
private:
private:__xcodeml_template_type_0_0(*__ptr_);
private:class::std::__1::__shared_weak_count(*__cntrl_);
private:class __nat{public:int __for_bool_;
}
;
public:
public:shared_ptr();
public:shared_ptr(nullptr_t);
public:template<typename __xcodeml_template_type_1_0>shared_ptr(__xcodeml_template_type_1_0(*__p),typename enable_if<expression,class::std::__1::shared_ptr::__nat>::type)
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>shared_ptr(__xcodeml_template_type_1_0(*__p),__xcodeml_template_type_1_1 __d,typename enable_if<expression,class::std::__1::shared_ptr::__nat>::type)
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1,typename __xcodeml_template_type_1_2>shared_ptr(__xcodeml_template_type_1_0(*__p),__xcodeml_template_type_1_1 __d,__xcodeml_template_type_1_2 __a,typename enable_if<expression,class::std::__1::shared_ptr::__nat>::type)
public:template<typename __xcodeml_template_type_1_0>shared_ptr(nullptr_t __p,__xcodeml_template_type_1_0 __d)
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>shared_ptr(nullptr_t __p,__xcodeml_template_type_1_0 __d,__xcodeml_template_type_1_1 __a)
public:template<typename __xcodeml_template_type_1_0>shared_ptr(shared_ptr<__xcodeml_template_type_1_0>,__xcodeml_template_type_0_0(*__p))
public:shared_ptr(class shared_ptr const&__r);
public:template<typename __xcodeml_template_type_1_0>shared_ptr(shared_ptr<__xcodeml_template_type_1_0>,typename enable_if<expression,class::std::__1::shared_ptr::__nat>::type)
public:shared_ptr(class shared_ptr(*__r));
public:template<typename __xcodeml_template_type_1_0>shared_ptr(shared_ptr<__xcodeml_template_type_1_0>,typename enable_if<expression,class::std::__1::shared_ptr::__nat>::type)
public:template<typename __xcodeml_template_type_1_0>shared_ptr(weak_ptr<__xcodeml_template_type_1_0>,typename enable_if<expression,class::std::__1::shared_ptr::__nat>::type)
public:template<typename __xcodeml_template_type_1_0>shared_ptr(auto_ptr<__xcodeml_template_type_1_0>,typename enable_if<expression,class::std::__1::shared_ptr::__nat>::type)
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>shared_ptr(unique_ptr<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1>,typename enable_if<expression,class::std::__1::shared_ptr::__nat>::type)
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>shared_ptr(unique_ptr<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1>,typename enable_if<expression,class::std::__1::shared_ptr::__nat>::type)
public:~shared_ptr();
public:class shared_ptr&operator=(class shared_ptr const&__r);
public:template<typename __xcodeml_template_type_1_0>typename enable_if<expression,class shared_ptr&>::type operator=(shared_ptr<__xcodeml_template_type_1_0>)
public:class shared_ptr&operator=(class shared_ptr(*__r));
public:template<typename __xcodeml_template_type_1_0>typename enable_if<expression,class shared_ptr&>::type operator=(shared_ptr<__xcodeml_template_type_1_0>)
public:template<typename __xcodeml_template_type_1_0>typename enable_if<expression,class shared_ptr>::type&operator=(auto_ptr<__xcodeml_template_type_1_0>)
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>typename enable_if<expression,class shared_ptr&>::type operator=(unique_ptr<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1>)
public:void swap(class shared_ptr&__r);
public:void reset();
public:template<typename __xcodeml_template_type_1_0>typename enable_if<expression,void>::type reset(__xcodeml_template_type_1_0(*__p))
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>typename enable_if<expression,void>::type reset(__xcodeml_template_type_1_0(*__p),__xcodeml_template_type_1_1 __d)
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1,typename __xcodeml_template_type_1_2>typename enable_if<expression,void>::type reset(__xcodeml_template_type_1_0(*__p),__xcodeml_template_type_1_1 __d,__xcodeml_template_type_1_2 __a)
public:__xcodeml_template_type_0_0(*get()const){return this->__ptr_;
}
public:typename add_lvalue_reference<__xcodeml_template_type_0_0>::type operator*()const{return(*this->__ptr_);
}
public:__xcodeml_template_type_0_0(*operator->()const){return this->__ptr_;
}
public:long use_count()const{return(this->__cntrl_?(this->__cntrl_->use_count()):0);
}
public:bool unique()const{return((this->use_count()),1);
}
public:operator bool()const{return((this->get()),0);
}
public:template<typename __xcodeml_template_type_1_0>bool owner_before(shared_ptr<__xcodeml_template_type_1_0>)const{return(this->__cntrl_,__p.__cntrl_);
}
public:template<typename __xcodeml_template_type_1_0>bool owner_before(weak_ptr<__xcodeml_template_type_1_0>)const{return(this->__cntrl_,__p.__cntrl_);
}
public:bool __owner_equivalent(class shared_ptr const&__p)const{return(this->__cntrl_,__p.__cntrl_);
}
public:template<typename __xcodeml_template_type_1_0>__xcodeml_template_type_1_0(*__get_deleter()const){return static_cast<__xcodeml_template_type_1_0(*)>((this->__cntrl_?const_cast<void(*)>((this->__cntrl_->__get_deleter(__xcodeml_template_type_1_0))):nullptr));
}
public:template<typename __xcodeml_template_type_1_0>static class shared_ptr make_shared(void/*__args*/)
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>static class shared_ptr allocate_shared(__xcodeml_template_type_1_0 const&__a,void/*__args*/)
private:
private:template<typename __xcodeml_template_type_1_0,bool=is_function<__xcodeml_template_type_1_0>::value>class __shared_ptr_default_allocator{public:typedef allocator<__xcodeml_template_type_1_0>;
}
;
;

/* Ignored a member with no access specifier template<typename __xcodeml_template_type_1_0>class __shared_ptr_default_allocator<__xcodeml_template_type_1_0,1>{public:typedef class::std::__1::allocator<class::std::__1::__shared_ptr_dummy_rebind_allocator_type>type;
}
;*/

private:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>typename enable_if<expression,void>::type __enable_weak_this(enable_shared_from_this<__xcodeml_template_type_1_0>,__xcodeml_template_type_1_1(*__ptr)){typedef typename remove_cv<__xcodeml_template_type_1_0>::type _RawYp;
if((__e&&(__e.__weak_this_.expired()))){{(__e.__weak_this_=__xcodeml_identity<shared_ptr<typename remove_cv<__xcodeml_template_type_1_0>::type> >::t((*this),const_cast<typename remove_cv<__xcodeml_template_type_1_0>::type(*)>(static_cast<__xcodeml_template_type_1_0 const(*)>(__ptr))));
};};
}
private:void __enable_weak_this(...){}
public:friend template<typename __xcodeml_template_type_1_0>class shared_ptr;
;
public:friend template<typename __xcodeml_template_type_1_0>class weak_ptr;
;
}
;
;
shared_ptr::shared_ptr():__ptr_(0),__cntrl_(0){}
shared_ptr::shared_ptr(nullptr_t):__ptr_(0),__cntrl_(0){}
template<typename __xcodeml_template_type_1_0>shared_ptr::shared_ptr(__xcodeml_template_type_1_0(*__p),typename enable_if<expression,class::std::__1::shared_ptr::__nat>::type):__ptr_(__p){unique_ptr<__xcodeml_template_type_1_0,default_delete<__xcodeml_template_type_1_0> > =__p;
typedef typename __shared_ptr_default_allocator<__xcodeml_template_type_1_0,expression>::type _AllocT;
typedef __shared_ptr_pointer<__xcodeml_template_type_1_0(*),default_delete<__xcodeml_template_type_1_0>,typename __shared_ptr_default_allocator<__xcodeml_template_type_1_0,expression>::type>;
(this->__cntrl_=new __xcodeml_identity<__shared_ptr_pointer<__xcodeml_template_type_1_0(*),default_delete<__xcodeml_template_type_1_0>,typename __shared_ptr_default_allocator<__xcodeml_template_type_1_0,expression>::type> >::t(__p,__xcodeml_identity<default_delete<__xcodeml_template_type_1_0> >::t(),__xcodeml_identity<typename __shared_ptr_default_allocator<__xcodeml_template_type_1_0,expression>::type>::t()));
(__hold.release());
((__p,__p));
}
template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>shared_ptr::shared_ptr(__xcodeml_template_type_1_0(*__p),__xcodeml_template_type_1_1 __d,typename enable_if<expression,class::std::__1::shared_ptr::__nat>::type):__ptr_(__p){try{typedef typename __shared_ptr_default_allocator<__xcodeml_template_type_1_0,expression>::type _AllocT;
typedef __shared_ptr_pointer<__xcodeml_template_type_1_0(*),__xcodeml_template_type_1_1,typename __shared_ptr_default_allocator<__xcodeml_template_type_1_0,expression>::type>;
(this->__cntrl_=new __xcodeml_identity<__shared_ptr_pointer<__xcodeml_template_type_1_0(*),__xcodeml_template_type_1_1,typename __shared_ptr_default_allocator<__xcodeml_template_type_1_0,expression>::type> >::t(__p,__d,__xcodeml_identity<typename __shared_ptr_default_allocator<__xcodeml_template_type_1_0,expression>::type>::t()));
((__p,__p));
}catch(...){(__d(__p));
throw;
}
;
}
template<typename __xcodeml_template_type_1_0>shared_ptr::shared_ptr(nullptr_t __p,__xcodeml_template_type_1_0 __d):__ptr_(0){try{typedef typename __shared_ptr_default_allocator<__xcodeml_template_type_0_0,expression>::type _AllocT;
typedef __shared_ptr_pointer<nullptr_t,__xcodeml_template_type_1_0,typename __shared_ptr_default_allocator<__xcodeml_template_type_0_0,expression>::type>;
(this->__cntrl_=new __xcodeml_identity<__shared_ptr_pointer<nullptr_t,__xcodeml_template_type_1_0,typename __shared_ptr_default_allocator<__xcodeml_template_type_0_0,expression>::type> >::t(__p,__d,__xcodeml_identity<typename __shared_ptr_default_allocator<__xcodeml_template_type_0_0,expression>::type>::t()));
}catch(...){(__d(__p));
throw;
}
;
}
template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1,typename __xcodeml_template_type_1_2>shared_ptr::shared_ptr(__xcodeml_template_type_1_0(*__p),__xcodeml_template_type_1_1 __d,__xcodeml_template_type_1_2 __a,typename enable_if<expression,class::std::__1::shared_ptr::__nat>::type):__ptr_(__p){try{typedef __shared_ptr_pointer<__xcodeml_template_type_1_0(*),__xcodeml_template_type_1_1,__xcodeml_template_type_1_2>;
typedef typename __allocator_traits_rebind<__xcodeml_template_type_1_2,__shared_ptr_pointer<__xcodeml_template_type_1_0(*),__xcodeml_template_type_1_1,__xcodeml_template_type_1_2>,expression>::type _A2;
typedef __allocator_destructor<typename __allocator_traits_rebind<__xcodeml_template_type_1_2,__shared_ptr_pointer<__xcodeml_template_type_1_0(*),__xcodeml_template_type_1_1,__xcodeml_template_type_1_2>,expression>::type>;
typename __allocator_traits_rebind<__xcodeml_template_type_1_2,__shared_ptr_pointer<__xcodeml_template_type_1_0(*),__xcodeml_template_type_1_1,__xcodeml_template_type_1_2>,expression>::type __a2=__a;
unique_ptr<__shared_ptr_pointer<__xcodeml_template_type_1_0(*),__xcodeml_template_type_1_1,__xcodeml_template_type_1_2>,__allocator_destructor<typename __allocator_traits_rebind<__xcodeml_template_type_1_2,__shared_ptr_pointer<__xcodeml_template_type_1_0(*),__xcodeml_template_type_1_1,__xcodeml_template_type_1_2>,expression>::type> > =(__a2.allocate(1))__xcodeml_identity<__allocator_destructor<typename __allocator_traits_rebind<__xcodeml_template_type_1_2,__shared_ptr_pointer<__xcodeml_template_type_1_0(*),__xcodeml_template_type_1_1,__xcodeml_template_type_1_2>,expression>::type> >::t(__a2,1);
::new(static_cast<void(*)>((std::__1::((*(__hold2.get()))))))__xcodeml_identity<__shared_ptr_pointer<__xcodeml_template_type_1_0(*),__xcodeml_template_type_1_1,__xcodeml_template_type_1_2> >::t(__p,__d,__a);
(this->__cntrl_=(std::__1::((*(__hold2.release())))));
((__p,__p));
}catch(...){(__d(__p));
throw;
}
;
}
template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>shared_ptr::shared_ptr(nullptr_t __p,__xcodeml_template_type_1_0 __d,__xcodeml_template_type_1_1 __a):__ptr_(0){try{typedef __shared_ptr_pointer<nullptr_t,__xcodeml_template_type_1_0,__xcodeml_template_type_1_1>;
typedef typename __allocator_traits_rebind<__xcodeml_template_type_1_1,__shared_ptr_pointer<nullptr_t,__xcodeml_template_type_1_0,__xcodeml_template_type_1_1>,expression>::type _A2;
typedef __allocator_destructor<typename __allocator_traits_rebind<__xcodeml_template_type_1_1,__shared_ptr_pointer<nullptr_t,__xcodeml_template_type_1_0,__xcodeml_template_type_1_1>,expression>::type>;
typename __allocator_traits_rebind<__xcodeml_template_type_1_1,__shared_ptr_pointer<nullptr_t,__xcodeml_template_type_1_0,__xcodeml_template_type_1_1>,expression>::type __a2=__a;
unique_ptr<__shared_ptr_pointer<nullptr_t,__xcodeml_template_type_1_0,__xcodeml_template_type_1_1>,__allocator_destructor<typename __allocator_traits_rebind<__xcodeml_template_type_1_1,__shared_ptr_pointer<nullptr_t,__xcodeml_template_type_1_0,__xcodeml_template_type_1_1>,expression>::type> > =(__a2.allocate(1))__xcodeml_identity<__allocator_destructor<typename __allocator_traits_rebind<__xcodeml_template_type_1_1,__shared_ptr_pointer<nullptr_t,__xcodeml_template_type_1_0,__xcodeml_template_type_1_1>,expression>::type> >::t(__a2,1);
::new(static_cast<void(*)>((std::__1::((*(__hold2.get()))))))__xcodeml_identity<__shared_ptr_pointer<nullptr_t,__xcodeml_template_type_1_0,__xcodeml_template_type_1_1> >::t(__p,__d,__a);
(this->__cntrl_=(std::__1::((*(__hold2.release())))));
}catch(...){(__d(__p));
throw;
}
;
}
template<typename __xcodeml_template_type_1_0>shared_ptr::shared_ptr(shared_ptr<__xcodeml_template_type_1_0>,__xcodeml_template_type_0_0(*__p)):__ptr_(__p),__cntrl_(__r.__cntrl_){if(this->__cntrl_){(this->__cntrl_->__add_shared());};
}
shared_ptr::shared_ptr(class shared_ptr const&__r):__ptr_(__r.__ptr_),__cntrl_(__r.__cntrl_){if(this->__cntrl_){(this->__cntrl_->__add_shared());};
}
template<typename __xcodeml_template_type_1_0>shared_ptr::shared_ptr(shared_ptr<__xcodeml_template_type_1_0>,typename enable_if<expression,class::std::__1::shared_ptr::__nat>::type):__ptr_(__r.__ptr_),__cntrl_(__r.__cntrl_){if(this->__cntrl_){(this->__cntrl_->__add_shared());};
}
shared_ptr::shared_ptr(class shared_ptr(*__r)):__ptr_(__r.__ptr_),__cntrl_(__r.__cntrl_){(__r.__ptr_=0);
(__r.__cntrl_=0);
}
template<typename __xcodeml_template_type_1_0>shared_ptr::shared_ptr(shared_ptr<__xcodeml_template_type_1_0>,typename enable_if<expression,class::std::__1::shared_ptr::__nat>::type):__ptr_(__r.__ptr_),__cntrl_(__r.__cntrl_){(__r.__ptr_=0);
(__r.__cntrl_=0);
}
template<typename __xcodeml_template_type_1_0>shared_ptr::shared_ptr(auto_ptr<__xcodeml_template_type_1_0>,typename enable_if<expression,class::std::__1::shared_ptr::__nat>::type):__ptr_((__r.get())){typedef __shared_ptr_pointer<__xcodeml_template_type_1_0(*),default_delete<__xcodeml_template_type_1_0>,allocator<__xcodeml_template_type_1_0> >;
(this->__cntrl_=new __xcodeml_identity<__shared_ptr_pointer<__xcodeml_template_type_1_0(*),default_delete<__xcodeml_template_type_1_0>,allocator<__xcodeml_template_type_1_0> > >::t((__r.get()),__xcodeml_identity<default_delete<__xcodeml_template_type_1_0> >::t(),__xcodeml_identity<allocator<__xcodeml_template_type_1_0> >::t()));
(((__r.get()),(__r.get())));
(__r.release());
}
template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>shared_ptr::shared_ptr(unique_ptr<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1>,typename enable_if<expression,class::std::__1::shared_ptr::__nat>::type):__ptr_((__r.get())){if((this->__ptr_,nullptr)){(this->__cntrl_=nullptr);}else{{typedef typename __shared_ptr_default_allocator<__xcodeml_template_type_1_0,expression>::type _AllocT;
typedef __shared_ptr_pointer<__xcodeml_template_type_1_0(*),__xcodeml_template_type_1_1,typename __shared_ptr_default_allocator<__xcodeml_template_type_1_0,expression>::type>;
(this->__cntrl_=new __xcodeml_identity<__shared_ptr_pointer<__xcodeml_template_type_1_0(*),__xcodeml_template_type_1_1,typename __shared_ptr_default_allocator<__xcodeml_template_type_1_0,expression>::type> >::t((__r.get()),(__r.get_deleter()),__xcodeml_identity<typename __shared_ptr_default_allocator<__xcodeml_template_type_1_0,expression>::type>::t()));
(((__r.get()),(__r.get())));
};};
(__r.release());
}
template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>shared_ptr::shared_ptr(unique_ptr<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1>,typename enable_if<expression,class::std::__1::shared_ptr::__nat>::type):__ptr_((__r.get())){if((this->__ptr_,nullptr)){(this->__cntrl_=nullptr);}else{{typedef typename __shared_ptr_default_allocator<__xcodeml_template_type_1_0,expression>::type _AllocT;
typedef __shared_ptr_pointer<__xcodeml_template_type_1_0(*),reference_wrapper<typename remove_reference<__xcodeml_template_type_1_1>::type>,typename __shared_ptr_default_allocator<__xcodeml_template_type_1_0,expression>::type>;
(this->__cntrl_=new __xcodeml_identity<__shared_ptr_pointer<__xcodeml_template_type_1_0(*),reference_wrapper<typename remove_reference<__xcodeml_template_type_1_1>::type>,typename __shared_ptr_default_allocator<__xcodeml_template_type_1_0,expression>::type> >::t((__r.get()),(((__r.get_deleter()))),__xcodeml_identity<typename __shared_ptr_default_allocator<__xcodeml_template_type_1_0,expression>::type>::t()));
(((__r.get()),(__r.get())));
};};
(__r.release());
}
template<typename __xcodeml_template_type_1_0>class shared_ptr shared_ptr::make_shared(void/*__args*/){is_constructible<__xcodeml_template_type_0_0,...>::value"Can't construct object in make_shared";
typedef __shared_ptr_emplace<__xcodeml_template_type_0_0,allocator<__xcodeml_template_type_0_0> >;
typedef allocator<__shared_ptr_emplace<__xcodeml_template_type_0_0,allocator<__xcodeml_template_type_0_0> > >;
typedef __allocator_destructor<allocator<__shared_ptr_emplace<__xcodeml_template_type_0_0,allocator<__xcodeml_template_type_0_0> > > >;
allocator<__shared_ptr_emplace<__xcodeml_template_type_0_0,allocator<__xcodeml_template_type_0_0> > >;
unique_ptr<__shared_ptr_emplace<__xcodeml_template_type_0_0,allocator<__xcodeml_template_type_0_0> >,__allocator_destructor<allocator<__shared_ptr_emplace<__xcodeml_template_type_0_0,allocator<__xcodeml_template_type_0_0> > > > > =(__a2.allocate(1))__xcodeml_identity<__allocator_destructor<allocator<__shared_ptr_emplace<__xcodeml_template_type_0_0,allocator<__xcodeml_template_type_0_0> > > > >::t(__a2,1);
::new((__hold2.get()))__xcodeml_identity<__shared_ptr_emplace<__xcodeml_template_type_0_0,allocator<__xcodeml_template_type_0_0> > >::t(__a2,(std::__1::__xcodeml_template_type_1_0(__args)));
class shared_ptr __r;
(__r.__ptr_=((__hold2.get()).get()));
(__r.__cntrl_=(__hold2.release()));
(__r.__enable_weak_this(__r.__ptr_,__r.__ptr_));
return __r;
}
template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>class shared_ptr shared_ptr::allocate_shared(__xcodeml_template_type_1_0 const&__a,void/*__args*/){is_constructible<__xcodeml_template_type_0_0,...>::value"Can't construct object in allocate_shared";
typedef __shared_ptr_emplace<__xcodeml_template_type_0_0,__xcodeml_template_type_1_0>;
typedef typename __allocator_traits_rebind<__xcodeml_template_type_1_0,__shared_ptr_emplace<__xcodeml_template_type_0_0,__xcodeml_template_type_1_0>,expression>::type _A2;
typedef __allocator_destructor<typename __allocator_traits_rebind<__xcodeml_template_type_1_0,__shared_ptr_emplace<__xcodeml_template_type_0_0,__xcodeml_template_type_1_0>,expression>::type>;
typename __allocator_traits_rebind<__xcodeml_template_type_1_0,__shared_ptr_emplace<__xcodeml_template_type_0_0,__xcodeml_template_type_1_0>,expression>::type __a2=__a;
unique_ptr<__shared_ptr_emplace<__xcodeml_template_type_0_0,__xcodeml_template_type_1_0>,__allocator_destructor<typename __allocator_traits_rebind<__xcodeml_template_type_1_0,__shared_ptr_emplace<__xcodeml_template_type_0_0,__xcodeml_template_type_1_0>,expression>::type> > =(__a2.allocate(1))__xcodeml_identity<__allocator_destructor<typename __allocator_traits_rebind<__xcodeml_template_type_1_0,__shared_ptr_emplace<__xcodeml_template_type_0_0,__xcodeml_template_type_1_0>,expression>::type> >::t(__a2,1);
::new(static_cast<void(*)>((std::__1::((*(__hold2.get()))))))__xcodeml_identity<__shared_ptr_emplace<__xcodeml_template_type_0_0,__xcodeml_template_type_1_0> >::t(__a,(std::__1::__xcodeml_template_type_1_1(__args)));
class shared_ptr __r;
(__r.__ptr_=((__hold2.get()).get()));
(__r.__cntrl_=(std::__1::((*(__hold2.release())))));
(__r.__enable_weak_this(__r.__ptr_,__r.__ptr_));
return __r;
}
shared_ptr::~shared_ptr(){if(this->__cntrl_){(this->__cntrl_->__release_shared());};
}
class shared_ptr&shared_ptr::operator=(class shared_ptr const&__r){(__xcodeml_identity<class shared_ptr>::t(__r).swap((*this)));
return(*this);
}
template<typename __xcodeml_template_type_1_0>typename enable_if<expression,class shared_ptr&>::type shared_ptr::operator=(shared_ptr<__xcodeml_template_type_1_0>){(__xcodeml_identity<class shared_ptr>::t(__r).swap((*this)));
return(*this);
}
class shared_ptr&shared_ptr::operator=(class shared_ptr(*__r)){(__xcodeml_identity<class shared_ptr>::t((std::__1::(__r))).swap((*this)));
return(*this);
}
template<typename __xcodeml_template_type_1_0>typename enable_if<expression,class shared_ptr&>::type shared_ptr::operator=(shared_ptr<__xcodeml_template_type_1_0>){(__xcodeml_identity<class shared_ptr>::t((std::__1::(__r))).swap((*this)));
return(*this);
}
template<typename __xcodeml_template_type_1_0>typename enable_if<expression,class shared_ptr>::type&shared_ptr::operator=(auto_ptr<__xcodeml_template_type_1_0>){(__xcodeml_identity<class shared_ptr>::t((std::__1::(__r))).swap((*this)));
return(*this);
}
template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>typename enable_if<expression,class shared_ptr&>::type shared_ptr::operator=(unique_ptr<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1>){(__xcodeml_identity<class shared_ptr>::t((std::__1::(__r))).swap((*this)));
return(*this);
}
void shared_ptr::swap(class shared_ptr&__r){(std::__1::(this->__ptr_,__r.__ptr_));
(std::__1::(this->__cntrl_,__r.__cntrl_));
}
void shared_ptr::reset(){(__xcodeml_identity<class shared_ptr>::t().swap((*this)));
}
template<typename __xcodeml_template_type_1_0>typename enable_if<expression,void>::type shared_ptr::reset(__xcodeml_template_type_1_0(*__p)){(__xcodeml_identity<class shared_ptr>::t(__p).swap((*this)));
}
template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>typename enable_if<expression,void>::type shared_ptr::reset(__xcodeml_template_type_1_0(*__p),__xcodeml_template_type_1_1 __d){(__xcodeml_identity<class shared_ptr>::t(__p,__d).swap((*this)));
}
template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1,typename __xcodeml_template_type_1_2>typename enable_if<expression,void>::type shared_ptr::reset(__xcodeml_template_type_1_0(*__p),__xcodeml_template_type_1_1 __d,__xcodeml_template_type_1_2 __a){(__xcodeml_identity<class shared_ptr>::t(__p,__d,__a).swap((*this)));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename enable_if<expression,shared_ptr<__xcodeml_template_type_0_0> >::type make_shared(void/*__args*/){return(shared_ptr<__xcodeml_template_type_0_0>::make_shared((std::__1::__xcodeml_template_type_0_1(__args))));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>typename enable_if<expression,shared_ptr<__xcodeml_template_type_0_0> >::type allocate_shared(__xcodeml_template_type_0_1 const&__a,void/*__args*/){return(shared_ptr<__xcodeml_template_type_0_0>::allocate_shared(__a,(std::__1::__xcodeml_template_type_0_2(__args))));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator==(shared_ptr<__xcodeml_template_type_0_0>,shared_ptr<__xcodeml_template_type_0_1>){return((__x.get()),(__y.get()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator!=(shared_ptr<__xcodeml_template_type_0_0>,shared_ptr<__xcodeml_template_type_0_1>){return(!(__x,__y));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator<(shared_ptr<__xcodeml_template_type_0_0>,shared_ptr<__xcodeml_template_type_0_1>){return(__xcodeml_identity<class::std::__1::less<void> >::t()((__x.get()),(__y.get())));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator>(shared_ptr<__xcodeml_template_type_0_0>,shared_ptr<__xcodeml_template_type_0_1>){return(__y,__x);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator<=(shared_ptr<__xcodeml_template_type_0_0>,shared_ptr<__xcodeml_template_type_0_1>){return(!(__y,__x));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator>=(shared_ptr<__xcodeml_template_type_0_0>,shared_ptr<__xcodeml_template_type_0_1>){return(!(__x,__y));
}
template<typename __xcodeml_template_type_0_0>bool operator==(shared_ptr<__xcodeml_template_type_0_0>,nullptr_t){return(!__x);
}
template<typename __xcodeml_template_type_0_0>bool operator==(nullptr_t,shared_ptr<__xcodeml_template_type_0_0>){return(!__x);
}
template<typename __xcodeml_template_type_0_0>bool operator!=(shared_ptr<__xcodeml_template_type_0_0>,nullptr_t){return static_cast<bool>(__x);
}
template<typename __xcodeml_template_type_0_0>bool operator!=(nullptr_t,shared_ptr<__xcodeml_template_type_0_0>){return static_cast<bool>(__x);
}
template<typename __xcodeml_template_type_0_0>bool operator<(shared_ptr<__xcodeml_template_type_0_0>,nullptr_t){return(__xcodeml_identity<less<__xcodeml_template_type_0_0(*)> >::t()((__x.get()),nullptr));
}
template<typename __xcodeml_template_type_0_0>bool operator<(nullptr_t,shared_ptr<__xcodeml_template_type_0_0>){return(__xcodeml_identity<less<__xcodeml_template_type_0_0(*)> >::t()(nullptr,(__x.get())));
}
template<typename __xcodeml_template_type_0_0>bool operator>(shared_ptr<__xcodeml_template_type_0_0>,nullptr_t){return(nullptr,__x);
}
template<typename __xcodeml_template_type_0_0>bool operator>(nullptr_t,shared_ptr<__xcodeml_template_type_0_0>){return(__x,nullptr);
}
template<typename __xcodeml_template_type_0_0>bool operator<=(shared_ptr<__xcodeml_template_type_0_0>,nullptr_t){return(!(nullptr,__x));
}
template<typename __xcodeml_template_type_0_0>bool operator<=(nullptr_t,shared_ptr<__xcodeml_template_type_0_0>){return(!(__x,nullptr));
}
template<typename __xcodeml_template_type_0_0>bool operator>=(shared_ptr<__xcodeml_template_type_0_0>,nullptr_t){return(!(__x,nullptr));
}
template<typename __xcodeml_template_type_0_0>bool operator>=(nullptr_t,shared_ptr<__xcodeml_template_type_0_0>){return(!(nullptr,__x));
}
template<typename __xcodeml_template_type_0_0>void swap(shared_ptr<__xcodeml_template_type_0_0>,shared_ptr<__xcodeml_template_type_0_0>){(__x.swap(__y));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename enable_if<expression,shared_ptr<__xcodeml_template_type_0_0> >::type static_pointer_cast(shared_ptr<__xcodeml_template_type_0_1>){return __xcodeml_identity<shared_ptr<__xcodeml_template_type_0_0> >::t(__r,static_cast<__xcodeml_template_type_0_0(*)>((__r.get())));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename enable_if<expression,shared_ptr<__xcodeml_template_type_0_0> >::type dynamic_pointer_cast(shared_ptr<__xcodeml_template_type_0_1>){__xcodeml_template_type_0_0(*__p)=dynamic_cast<__xcodeml_template_type_0_0(*)>((__r.get()));
return(__p?__xcodeml_identity<shared_ptr<__xcodeml_template_type_0_0> >::t(__r,__p):__xcodeml_identity<shared_ptr<__xcodeml_template_type_0_0> >::t());
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename enable_if<expression,shared_ptr<__xcodeml_template_type_0_0> >::type const_pointer_cast(shared_ptr<__xcodeml_template_type_0_1>){typedef typename remove_extent<__xcodeml_template_type_0_0>::type _RTp;
return __xcodeml_identity<shared_ptr<__xcodeml_template_type_0_0> >::t(__r,const_cast<typename remove_extent<__xcodeml_template_type_0_0>::type(*)>((__r.get())));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0(*get_deleter(shared_ptr<__xcodeml_template_type_0_1>)){return(__p.__get_deleter());
}
template<typename __xcodeml_template_type_0_0>class weak_ptr{public:
public:typedef __xcodeml_template_type_0_0 element_type;
private:
private:__xcodeml_template_type_0_0(*__ptr_);
private:class::std::__1::__shared_weak_count(*__cntrl_);
public:
public:weak_ptr();
public:template<typename __xcodeml_template_type_1_0>weak_ptr(shared_ptr<__xcodeml_template_type_1_0>,typename enable_if<expression,class::std::__1::__nat(*)>::type)
public:weak_ptr(class weak_ptr const&__r);
public:template<typename __xcodeml_template_type_1_0>weak_ptr(weak_ptr<__xcodeml_template_type_1_0>,typename enable_if<expression,class::std::__1::__nat(*)>::type)
public:weak_ptr(class weak_ptr(*__r));
public:template<typename __xcodeml_template_type_1_0>weak_ptr(weak_ptr<__xcodeml_template_type_1_0>,typename enable_if<expression,class::std::__1::__nat(*)>::type)
public:~weak_ptr();
public:class weak_ptr&operator=(class weak_ptr const&__r);
public:template<typename __xcodeml_template_type_1_0>typename enable_if<expression,class weak_ptr&>::type operator=(weak_ptr<__xcodeml_template_type_1_0>)
public:class weak_ptr&operator=(class weak_ptr(*__r));
public:template<typename __xcodeml_template_type_1_0>typename enable_if<expression,class weak_ptr&>::type operator=(weak_ptr<__xcodeml_template_type_1_0>)
public:template<typename __xcodeml_template_type_1_0>typename enable_if<expression,class weak_ptr&>::type operator=(shared_ptr<__xcodeml_template_type_1_0>)
public:void swap(class weak_ptr&__r);
public:void reset();
public:long use_count()const{return(this->__cntrl_?(this->__cntrl_->use_count()):0);
}
public:bool expired()const{return((this->__cntrl_,0)||((this->__cntrl_->use_count())==0));
}
public:shared_ptr<__xcodeml_template_type_0_0>;
public:template<typename __xcodeml_template_type_1_0>bool owner_before(shared_ptr<__xcodeml_template_type_1_0>)const{return(this->__cntrl_,__r.__cntrl_);
}
public:template<typename __xcodeml_template_type_1_0>bool owner_before(weak_ptr<__xcodeml_template_type_1_0>)const{return(this->__cntrl_,__r.__cntrl_);
}
public:friend template<typename __xcodeml_template_type_1_0>class weak_ptr;
;
public:friend template<typename __xcodeml_template_type_1_0>class shared_ptr;
;
}
;
;
weak_ptr::weak_ptr():__ptr_(0),__cntrl_(0){}
weak_ptr::weak_ptr(class weak_ptr const&__r):__ptr_(__r.__ptr_),__cntrl_(__r.__cntrl_){if(this->__cntrl_){(this->__cntrl_->__add_weak());};
}
template<typename __xcodeml_template_type_1_0>weak_ptr::weak_ptr(shared_ptr<__xcodeml_template_type_1_0>,typename enable_if<expression,class::std::__1::__nat(*)>::type):__ptr_(__r.__ptr_),__cntrl_(__r.__cntrl_){if(this->__cntrl_){(this->__cntrl_->__add_weak());};
}
template<typename __xcodeml_template_type_1_0>weak_ptr::weak_ptr(weak_ptr<__xcodeml_template_type_1_0>,typename enable_if<expression,class::std::__1::__nat(*)>::type):__ptr_(__r.__ptr_),__cntrl_(__r.__cntrl_){if(this->__cntrl_){(this->__cntrl_->__add_weak());};
}
weak_ptr::weak_ptr(class weak_ptr(*__r)):__ptr_(__r.__ptr_),__cntrl_(__r.__cntrl_){(__r.__ptr_=0);
(__r.__cntrl_=0);
}
template<typename __xcodeml_template_type_1_0>weak_ptr::weak_ptr(weak_ptr<__xcodeml_template_type_1_0>,typename enable_if<expression,class::std::__1::__nat(*)>::type):__ptr_(__r.__ptr_),__cntrl_(__r.__cntrl_){(__r.__ptr_=0);
(__r.__cntrl_=0);
}
weak_ptr::~weak_ptr(){if(this->__cntrl_){(this->__cntrl_->__release_weak());};
}
class weak_ptr&weak_ptr::operator=(class weak_ptr const&__r){(__xcodeml_identity<class weak_ptr>::t(__r).swap((*this)));
return(*this);
}
template<typename __xcodeml_template_type_1_0>typename enable_if<expression,class weak_ptr&>::type weak_ptr::operator=(weak_ptr<__xcodeml_template_type_1_0>){(__xcodeml_identity<class weak_ptr>::t(__r).swap((*this)));
return(*this);
}
class weak_ptr&weak_ptr::operator=(class weak_ptr(*__r)){(__xcodeml_identity<class weak_ptr>::t((std::__1::(__r))).swap((*this)));
return(*this);
}
template<typename __xcodeml_template_type_1_0>typename enable_if<expression,class weak_ptr&>::type weak_ptr::operator=(weak_ptr<__xcodeml_template_type_1_0>){(__xcodeml_identity<class weak_ptr>::t((std::__1::(__r))).swap((*this)));
return(*this);
}
template<typename __xcodeml_template_type_1_0>typename enable_if<expression,class weak_ptr&>::type weak_ptr::operator=(shared_ptr<__xcodeml_template_type_1_0>){(__xcodeml_identity<class weak_ptr>::t(__r).swap((*this)));
return(*this);
}
void weak_ptr::swap(class weak_ptr&__r){(std::__1::(this->__ptr_,__r.__ptr_));
(std::__1::(this->__cntrl_,__r.__cntrl_));
}
template<typename __xcodeml_template_type_0_0>void swap(weak_ptr<__xcodeml_template_type_0_0>,weak_ptr<__xcodeml_template_type_0_0>){(__x.swap(__y));
}
void weak_ptr::reset(){(__xcodeml_identity<class weak_ptr>::t().swap((*this)));
}
template<typename __xcodeml_template_type_1_0>shared_ptr::shared_ptr(weak_ptr<__xcodeml_template_type_1_0>,typename enable_if<expression,class::std::__1::shared_ptr::__nat>::type):__ptr_(__r.__ptr_),__cntrl_((__r.__cntrl_?(__r.__cntrl_.lock()):__r.__cntrl_)){if((this->__cntrl_,0)){(__throw_bad_weak_ptr());};
}
shared_ptr<__xcodeml_template_type_0_0>{shared_ptr<__xcodeml_template_type_0_0>;
(__r.__cntrl_=(this->__cntrl_?(this->__cntrl_->lock()):this->__cntrl_));
if(__r.__cntrl_){(__r.__ptr_=this->__ptr_);};
return __r;
}
template<typename __xcodeml_template_type_0_0>class owner_less;
;
template<typename __xcodeml_template_type_0_0>class owner_less<shared_ptr<__xcodeml_template_type_0_0> >:public binary_function<shared_ptr<__xcodeml_template_type_0_0>,shared_ptr<__xcodeml_template_type_0_0>,bool>{public:typedef bool result_type;
public:bool operator()(shared_ptr<__xcodeml_template_type_0_0>,shared_ptr<__xcodeml_template_type_0_0>)const{return(__x.owner_before(__y));
}
public:bool operator()(shared_ptr<__xcodeml_template_type_0_0>,weak_ptr<__xcodeml_template_type_0_0>)const{return(__x.owner_before(__y));
}
public:bool operator()(weak_ptr<__xcodeml_template_type_0_0>,shared_ptr<__xcodeml_template_type_0_0>)const{return(__x.owner_before(__y));
}
}
;
template<typename __xcodeml_template_type_0_0>class owner_less<weak_ptr<__xcodeml_template_type_0_0> >:public binary_function<weak_ptr<__xcodeml_template_type_0_0>,weak_ptr<__xcodeml_template_type_0_0>,bool>{public:typedef bool result_type;
public:bool operator()(weak_ptr<__xcodeml_template_type_0_0>,weak_ptr<__xcodeml_template_type_0_0>)const{return(__x.owner_before(__y));
}
public:bool operator()(shared_ptr<__xcodeml_template_type_0_0>,weak_ptr<__xcodeml_template_type_0_0>)const{return(__x.owner_before(__y));
}
public:bool operator()(weak_ptr<__xcodeml_template_type_0_0>,shared_ptr<__xcodeml_template_type_0_0>)const{return(__x.owner_before(__y));
}
}
;
template<typename __xcodeml_template_type_0_0>class enable_shared_from_this{private:weak_ptr<__xcodeml_template_type_0_0>;
protected:
protected:enable_shared_from_this(){}
protected:enable_shared_from_this(class enable_shared_from_this const&){}
protected:class enable_shared_from_this&operator=(class enable_shared_from_this const&){return(*this);
}
protected:~enable_shared_from_this(){}
public:
public:shared_ptr<__xcodeml_template_type_0_0>{return __xcodeml_identity<shared_ptr<__xcodeml_template_type_0_0> >::t(this->__weak_this_);
}
public:shared_ptr<__xcodeml_template_type_0_0 const>{return __xcodeml_identity<shared_ptr<__xcodeml_template_type_0_0 const> >::t(this->__weak_this_);
}
public:friend template<typename __xcodeml_template_type_1_0>class shared_ptr;
;
}
;
;
template<typename __xcodeml_template_type_0_0>class hash<shared_ptr<__xcodeml_template_type_0_0> >{public:typedef shared_ptr<__xcodeml_template_type_0_0>;
public:typedef unsigned long result_type;
public:unsigned long operator()(shared_ptr<__xcodeml_template_type_0_0>)const{return(__xcodeml_identity<hash<__xcodeml_template_type_0_0(*)> >::t()((__ptr.get())));
}
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>basic_ostream<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>
class __sp_mut{private:void(*__lx);
public:
public:void lock();
public:void unlock();
private:
private:__sp_mut(void(*));
private:__sp_mut(class __sp_mut const&);
private:class::std::__1::__sp_mut&operator=(class __sp_mut const&);
public:friend class::std::__1::__sp_mut&__get_sp_mut(void const(*));
}
;
class::std::__1::__sp_mut&__get_sp_mut(void const(*));
template<typename __xcodeml_template_type_0_0>bool atomic_is_lock_free(shared_ptr<__xcodeml_template_type_0_0>){return false;
}
template<typename __xcodeml_template_type_0_0>shared_ptr<__xcodeml_template_type_0_0>{class::std::__1::__sp_mut&__m=((__p));
(__m.lock());
shared_ptr<__xcodeml_template_type_0_0> =(*__p);
(__m.unlock());
return __q;
}
template<typename __xcodeml_template_type_0_0>shared_ptr<__xcodeml_template_type_0_0>{return((__p));
}
template<typename __xcodeml_template_type_0_0>void atomic_store(shared_ptr<__xcodeml_template_type_0_0>,shared_ptr<__xcodeml_template_type_0_0>){class::std::__1::__sp_mut&__m=((__p));
(__m.lock());
(__p.swap(__r));
(__m.unlock());
}
template<typename __xcodeml_template_type_0_0>void atomic_store_explicit(shared_ptr<__xcodeml_template_type_0_0>,shared_ptr<__xcodeml_template_type_0_0>,enum memory_order){((__p,__r));
}
template<typename __xcodeml_template_type_0_0>shared_ptr<__xcodeml_template_type_0_0>{class::std::__1::__sp_mut&__m=((__p));
(__m.lock());
(__p.swap(__r));
(__m.unlock());
return __r;
}
template<typename __xcodeml_template_type_0_0>shared_ptr<__xcodeml_template_type_0_0>{return((__p,__r));
}
template<typename __xcodeml_template_type_0_0>bool atomic_compare_exchange_strong(shared_ptr<__xcodeml_template_type_0_0>,shared_ptr<__xcodeml_template_type_0_0>,shared_ptr<__xcodeml_template_type_0_0>){shared_ptr<__xcodeml_template_type_0_0>;
class::std::__1::__sp_mut&__m=((__p));
(__m.lock());
if((__p.__owner_equivalent((*__v)))){{(std::__1::(__temp,(*__p)));
((*__p)=__w);
(__m.unlock());
return true;
};};
(std::__1::(__temp,(*__v)));
((*__v)=(*__p));
(__m.unlock());
return false;
}
template<typename __xcodeml_template_type_0_0>bool atomic_compare_exchange_weak(shared_ptr<__xcodeml_template_type_0_0>,shared_ptr<__xcodeml_template_type_0_0>,shared_ptr<__xcodeml_template_type_0_0>){return((__p,__v,__w));
}
template<typename __xcodeml_template_type_0_0>bool atomic_compare_exchange_strong_explicit(shared_ptr<__xcodeml_template_type_0_0>,shared_ptr<__xcodeml_template_type_0_0>,shared_ptr<__xcodeml_template_type_0_0>,enum memory_order,enum memory_order){return((__p,__v,__w));
}
template<typename __xcodeml_template_type_0_0>bool atomic_compare_exchange_weak_explicit(shared_ptr<__xcodeml_template_type_0_0>,shared_ptr<__xcodeml_template_type_0_0>,shared_ptr<__xcodeml_template_type_0_0>,enum memory_order,enum memory_order){return((__p,__v,__w));
}
class pointer_safety{public:enum __lx{relaxed,preferred,strict};
public:enum __lx __v_;
public:pointer_safety():__v_(){}
public:pointer_safety(enum __lx __v):__v_(__v){}
public:operator int()const{return this->__v_;
}
}
;
class::std::__1::pointer_safety get_pointer_safety(){return __xcodeml_identity<class::std::__1::pointer_safety>::t(pointer_safety::relaxed);
}
void declare_reachable(void(*__p));
void declare_no_pointers(char(*__p),unsigned long __n);
void undeclare_no_pointers(char(*__p),unsigned long __n);
void(*__undeclare_reachable(void(*__p)));
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0(*undeclare_reachable(__xcodeml_template_type_0_0(*__p))){return static_cast<__xcodeml_template_type_0_0(*)>(((__p)));
}
void(*align(unsigned long __align,unsigned long __sz,void(*&__ptr),unsigned long&__space));
template<typename __xcodeml_template_type_0_0>void __swap_allocator(__xcodeml_template_type_0_0&__a1,__xcodeml_template_type_0_0&__a2){((__a1,__a2,__xcodeml_identity<integral_constant<bool,expression> >::t()));
}
template<typename __xcodeml_template_type_0_0>void __swap_allocator(__xcodeml_template_type_0_0&__a1,__xcodeml_template_type_0_0&__a2,class::std::__1::integral_constant<bool,1>){std::__1::;
((__a1,__a2));
}
template<typename __xcodeml_template_type_0_0>void __swap_allocator(__xcodeml_template_type_0_0&,__xcodeml_template_type_0_0&,class::std::__1::integral_constant<bool,0>){}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __noexcept_move_assign_container:public integral_constant<bool,expression>{}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __temp_value{public:typedef allocator_traits<__xcodeml_template_type_0_1>;
public:typename aligned_storage<expression,expression>::type __v;
public:__xcodeml_template_type_0_1&__a;
public:__xcodeml_template_type_0_0(*__addr()){return reinterpret_cast<__xcodeml_template_type_0_0(*)>(((this->__v)));
}
public:__xcodeml_template_type_0_0&get(){return(*(this->__addr()));
}
public:template<typename __xcodeml_template_type_1_0>__temp_value(__xcodeml_template_type_0_1&__alloc,void/*__args*/):__a(__alloc){(allocator_traits<__xcodeml_template_type_0_1>::.construct(this->__a,reinterpret_cast<__xcodeml_template_type_0_0(*)>(((this->__v))),(std::__1::__xcodeml_template_type_1_0(__args))));
}
public:~__temp_value(){(allocator_traits<__xcodeml_template_type_0_1>::.destroy(this->__a,(this->__addr())));
}
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __is_allocator:public integral_constant<bool,0>{}
;
;
template<typename __xcodeml_template_type_0_0>class __is_allocator<__xcodeml_template_type_0_0,typename __void_t<typename __xcodeml_template_type_0_0::value_type>::type,typename __void_t<decltype ()>::type>:public integral_constant<bool,1>{}
;
class __builtin_new_allocator{public:class __builtin_new_deleter{public:typedef void(*pointer_type);
public:__builtin_new_deleter(unsigned long __size,unsigned long __align):__size_(__size),__align_(__align){}
public:void operator()(void(*p))const{(std::__libcpp_deallocate(p,this->__size_,this->__align_));
}
private:
private:unsigned long __size_;
private:unsigned long __align_;
}
;
public:typedef class::std::__1::unique_ptr<void,class::std::__1::__builtin_new_allocator::__builtin_new_deleter>__holder_t;
public:static class::std::__1::unique_ptr<void,class::std::__1::__builtin_new_allocator::__builtin_new_deleter>__allocate_bytes(unsigned long __s,unsigned long __align){return __xcodeml_identity<class::std::__1::unique_ptr<void,class::std::__1::__builtin_new_allocator::__builtin_new_deleter> >::t((std::__libcpp_allocate(__s,__align)),__xcodeml_identity<class::std::__1::__builtin_new_allocator::__builtin_new_deleter>::t(__s,__align));
}
public:static void __deallocate_bytes(void(*__p),unsigned long __s,unsigned long __align){(std::__libcpp_deallocate(__p,__s,__align));
}
public:template<typename __xcodeml_template_type_0_0>static class::std::__1::unique_ptr<void,class::std::__1::__builtin_new_allocator::__builtin_new_deleter>__allocate_type(unsigned long __n){return(__allocate_bytes((__n*(sizeof(__xcodeml_template_type_0_0))),__xcodeml_template_type_0_0));
}
public:template<typename __xcodeml_template_type_0_0>static void __deallocate_type(void(*__p),unsigned long __n){(__deallocate_bytes(__p,(__n*(sizeof(__xcodeml_template_type_0_0))),__xcodeml_template_type_0_0));
}
}
;
}
}
namespace std{namespace __1{template<typename __xcodeml_template_type_0_0>class plus:public binary_function<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0,__xcodeml_template_type_0_0>{public:__xcodeml_template_type_0_0 operator()(__xcodeml_template_type_0_0 const&__x,__xcodeml_template_type_0_0 const&__y)const{return(__x,__y);
}
}
;
;
template<>class plus<void>{public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>decltype (operator()(__xcodeml_template_type_0_0(*__t),__xcodeml_template_type_0_1(*__u))const){return((std::__1::__xcodeml_template_type_0_0(__t)),(std::__1::__xcodeml_template_type_0_1(__u)));
}
public:typedef void is_transparent;
}
;
template<typename __xcodeml_template_type_0_0>class minus:public binary_function<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0,__xcodeml_template_type_0_0>{public:__xcodeml_template_type_0_0 operator()(__xcodeml_template_type_0_0 const&__x,__xcodeml_template_type_0_0 const&__y)const{return(__x,__y);
}
}
;
;
template<>class minus<void>{public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>decltype (operator()(__xcodeml_template_type_0_0(*__t),__xcodeml_template_type_0_1(*__u))const){return((std::__1::__xcodeml_template_type_0_0(__t)),(std::__1::__xcodeml_template_type_0_1(__u)));
}
public:typedef void is_transparent;
}
;
template<typename __xcodeml_template_type_0_0>class multiplies:public binary_function<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0,__xcodeml_template_type_0_0>{public:__xcodeml_template_type_0_0 operator()(__xcodeml_template_type_0_0 const&__x,__xcodeml_template_type_0_0 const&__y)const{return(__x*__y);
}
}
;
;
template<>class multiplies<void>{public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>decltype (operator()(__xcodeml_template_type_0_0(*__t),__xcodeml_template_type_0_1(*__u))const){return((std::__1::__xcodeml_template_type_0_0(__t))*(std::__1::__xcodeml_template_type_0_1(__u)));
}
public:typedef void is_transparent;
}
;
template<typename __xcodeml_template_type_0_0>class divides:public binary_function<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0,__xcodeml_template_type_0_0>{public:__xcodeml_template_type_0_0 operator()(__xcodeml_template_type_0_0 const&__x,__xcodeml_template_type_0_0 const&__y)const{return(__x/__y);
}
}
;
;
template<>class divides<void>{public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>decltype (operator()(__xcodeml_template_type_0_0(*__t),__xcodeml_template_type_0_1(*__u))const){return((std::__1::__xcodeml_template_type_0_0(__t))/(std::__1::__xcodeml_template_type_0_1(__u)));
}
public:typedef void is_transparent;
}
;
template<typename __xcodeml_template_type_0_0>class modulus:public binary_function<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0,__xcodeml_template_type_0_0>{public:__xcodeml_template_type_0_0 operator()(__xcodeml_template_type_0_0 const&__x,__xcodeml_template_type_0_0 const&__y)const{return(__x%__y);
}
}
;
;
template<>class modulus<void>{public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>decltype (operator()(__xcodeml_template_type_0_0(*__t),__xcodeml_template_type_0_1(*__u))const){return((std::__1::__xcodeml_template_type_0_0(__t))%(std::__1::__xcodeml_template_type_0_1(__u)));
}
public:typedef void is_transparent;
}
;
template<typename __xcodeml_template_type_0_0>class negate:public unary_function<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0>{public:__xcodeml_template_type_0_0 operator()(__xcodeml_template_type_0_0 const&__x)const{return(__x);
}
}
;
;
template<>class negate<void>{public:template<typename __xcodeml_template_type_0_0>decltype (operator()(__xcodeml_template_type_0_0(*__x))const){return((std::__1::__xcodeml_template_type_0_0(__x)));
}
public:typedef void is_transparent;
}
;
template<typename __xcodeml_template_type_0_0>class equal_to:public binary_function<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0,bool>{public:bool operator()(__xcodeml_template_type_0_0 const&__x,__xcodeml_template_type_0_0 const&__y)const{return(__x,__y);
}
}
;
;
template<>class equal_to<void>{public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>decltype (operator()(__xcodeml_template_type_0_0(*__t),__xcodeml_template_type_0_1(*__u))const){return((std::__1::__xcodeml_template_type_0_0(__t)),(std::__1::__xcodeml_template_type_0_1(__u)));
}
public:typedef void is_transparent;
}
;
template<typename __xcodeml_template_type_0_0>class not_equal_to:public binary_function<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0,bool>{public:bool operator()(__xcodeml_template_type_0_0 const&__x,__xcodeml_template_type_0_0 const&__y)const{return(__x,__y);
}
}
;
;
template<>class not_equal_to<void>{public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>decltype (operator()(__xcodeml_template_type_0_0(*__t),__xcodeml_template_type_0_1(*__u))const){return((std::__1::__xcodeml_template_type_0_0(__t)),(std::__1::__xcodeml_template_type_0_1(__u)));
}
public:typedef void is_transparent;
}
;
template<typename __xcodeml_template_type_0_0>class greater:public binary_function<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0,bool>{public:bool operator()(__xcodeml_template_type_0_0 const&__x,__xcodeml_template_type_0_0 const&__y)const{return(__x,__y);
}
}
;
;
template<>class greater<void>{public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>decltype (operator()(__xcodeml_template_type_0_0(*__t),__xcodeml_template_type_0_1(*__u))const){return((std::__1::__xcodeml_template_type_0_0(__t)),(std::__1::__xcodeml_template_type_0_1(__u)));
}
public:typedef void is_transparent;
}
;
template<typename __xcodeml_template_type_0_0>class greater_equal:public binary_function<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0,bool>{public:bool operator()(__xcodeml_template_type_0_0 const&__x,__xcodeml_template_type_0_0 const&__y)const{return(__x,__y);
}
}
;
;
template<>class greater_equal<void>{public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>decltype (operator()(__xcodeml_template_type_0_0(*__t),__xcodeml_template_type_0_1(*__u))const){return((std::__1::__xcodeml_template_type_0_0(__t)),(std::__1::__xcodeml_template_type_0_1(__u)));
}
public:typedef void is_transparent;
}
;
template<typename __xcodeml_template_type_0_0>class less_equal:public binary_function<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0,bool>{public:bool operator()(__xcodeml_template_type_0_0 const&__x,__xcodeml_template_type_0_0 const&__y)const{return(__x,__y);
}
}
;
;
template<>class less_equal<void>{public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>decltype (operator()(__xcodeml_template_type_0_0(*__t),__xcodeml_template_type_0_1(*__u))const){return((std::__1::__xcodeml_template_type_0_0(__t)),(std::__1::__xcodeml_template_type_0_1(__u)));
}
public:typedef void is_transparent;
}
;
template<typename __xcodeml_template_type_0_0>class logical_and:public binary_function<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0,bool>{public:bool operator()(__xcodeml_template_type_0_0 const&__x,__xcodeml_template_type_0_0 const&__y)const{return(__x&&__y);
}
}
;
;
template<>class logical_and<void>{public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>decltype (operator()(__xcodeml_template_type_0_0(*__t),__xcodeml_template_type_0_1(*__u))const){return((std::__1::__xcodeml_template_type_0_0(__t))&&(std::__1::__xcodeml_template_type_0_1(__u)));
}
public:typedef void is_transparent;
}
;
template<typename __xcodeml_template_type_0_0>class logical_or:public binary_function<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0,bool>{public:bool operator()(__xcodeml_template_type_0_0 const&__x,__xcodeml_template_type_0_0 const&__y)const{return(__x||__y);
}
}
;
;
template<>class logical_or<void>{public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>decltype (operator()(__xcodeml_template_type_0_0(*__t),__xcodeml_template_type_0_1(*__u))const){return((std::__1::__xcodeml_template_type_0_0(__t))||(std::__1::__xcodeml_template_type_0_1(__u)));
}
public:typedef void is_transparent;
}
;
template<typename __xcodeml_template_type_0_0>class logical_not:public unary_function<__xcodeml_template_type_0_0,bool>{public:bool operator()(__xcodeml_template_type_0_0 const&__x)const{return(!__x);
}
}
;
;
template<>class logical_not<void>{public:template<typename __xcodeml_template_type_0_0>decltype (operator()(__xcodeml_template_type_0_0(*__x))const){return(!(std::__1::__xcodeml_template_type_0_0(__x)));
}
public:typedef void is_transparent;
}
;
template<typename __xcodeml_template_type_0_0>class bit_and:public binary_function<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0,__xcodeml_template_type_0_0>{public:__xcodeml_template_type_0_0 operator()(__xcodeml_template_type_0_0 const&__x,__xcodeml_template_type_0_0 const&__y)const{return(__x&__y);
}
}
;
;
template<>class bit_and<void>{public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>decltype (operator()(__xcodeml_template_type_0_0(*__t),__xcodeml_template_type_0_1(*__u))const){return((std::__1::__xcodeml_template_type_0_0(__t))&(std::__1::__xcodeml_template_type_0_1(__u)));
}
public:typedef void is_transparent;
}
;
template<typename __xcodeml_template_type_0_0>class bit_or:public binary_function<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0,__xcodeml_template_type_0_0>{public:__xcodeml_template_type_0_0 operator()(__xcodeml_template_type_0_0 const&__x,__xcodeml_template_type_0_0 const&__y)const{return(__x|__y);
}
}
;
;
template<>class bit_or<void>{public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>decltype (operator()(__xcodeml_template_type_0_0(*__t),__xcodeml_template_type_0_1(*__u))const){return((std::__1::__xcodeml_template_type_0_0(__t))|(std::__1::__xcodeml_template_type_0_1(__u)));
}
public:typedef void is_transparent;
}
;
template<typename __xcodeml_template_type_0_0>class bit_xor:public binary_function<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0,__xcodeml_template_type_0_0>{public:__xcodeml_template_type_0_0 operator()(__xcodeml_template_type_0_0 const&__x,__xcodeml_template_type_0_0 const&__y)const{return(__x^__y);
}
}
;
;
template<>class bit_xor<void>{public:template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>decltype (operator()(__xcodeml_template_type_0_0(*__t),__xcodeml_template_type_0_1(*__u))const){return((std::__1::__xcodeml_template_type_0_0(__t))^(std::__1::__xcodeml_template_type_0_1(__u)));
}
public:typedef void is_transparent;
}
;
template<typename __xcodeml_template_type_0_0>class bit_not:public unary_function<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0>{public:__xcodeml_template_type_0_0 operator()(__xcodeml_template_type_0_0 const&__x)const{return(~__x);
}
}
;
;
template<>class bit_not<void>{public:template<typename __xcodeml_template_type_0_0>decltype (operator()(__xcodeml_template_type_0_0(*__x))const){return(~(std::__1::__xcodeml_template_type_0_0(__x)));
}
public:typedef void is_transparent;
}
;
template<typename __xcodeml_template_type_0_0>class unary_negate:public unary_function<typename __xcodeml_template_type_0_0::argument_type,bool>{private:__xcodeml_template_type_0_0 __pred_;
public:
public:unary_negate(__xcodeml_template_type_0_0 const&__pred):__pred_(__pred){}
public:bool operator()(typename __xcodeml_template_type_0_0::argument_type const&__x)const{return(!(this->__pred_(__x)));
}
}
;
;
template<typename __xcodeml_template_type_0_0>unary_negate<__xcodeml_template_type_0_0>{return __xcodeml_identity<unary_negate<__xcodeml_template_type_0_0> >::t(__pred);
}
template<typename __xcodeml_template_type_0_0>class binary_negate:public binary_function<typename __xcodeml_template_type_0_0::first_argument_type,typename __xcodeml_template_type_0_0::second_argument_type,bool>{private:__xcodeml_template_type_0_0 __pred_;
public:
public:binary_negate(__xcodeml_template_type_0_0 const&__pred):__pred_(__pred){}
public:bool operator()(typename __xcodeml_template_type_0_0::first_argument_type const&__x,typename __xcodeml_template_type_0_0::second_argument_type const&__y)const{return(!(this->__pred_(__x,__y)));
}
}
;
;
template<typename __xcodeml_template_type_0_0>binary_negate<__xcodeml_template_type_0_0>{return __xcodeml_identity<binary_negate<__xcodeml_template_type_0_0> >::t(__pred);
}
template<typename __xcodeml_template_type_0_0>class binder1st:public unary_function<typename __xcodeml_template_type_0_0::second_argument_type,typename __xcodeml_template_type_0_0::result_type>{protected:
protected:__xcodeml_template_type_0_0 op;
protected:typename __xcodeml_template_type_0_0::first_argument_type value;
public:
public:binder1st(__xcodeml_template_type_0_0 const&__x,typename __xcodeml_template_type_0_0::first_argument_type __y):op(__x),value(__y){}
public:typename __xcodeml_template_type_0_0::result_type operator()(typename __xcodeml_template_type_0_0::second_argument_type&__x)const{return(this->op(this->value,__x));
}
public:typename __xcodeml_template_type_0_0::result_type operator()(typename __xcodeml_template_type_0_0::second_argument_type const&__x)const{return(this->op(this->value,__x));
}
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>binder1st<__xcodeml_template_type_0_0>{return __xcodeml_identity<binder1st<__xcodeml_template_type_0_0> >::t(__op,__x);
}
template<typename __xcodeml_template_type_0_0>class binder2nd:public unary_function<typename __xcodeml_template_type_0_0::first_argument_type,typename __xcodeml_template_type_0_0::result_type>{protected:
protected:__xcodeml_template_type_0_0 op;
protected:typename __xcodeml_template_type_0_0::second_argument_type value;
public:
public:binder2nd(__xcodeml_template_type_0_0 const&__x,typename __xcodeml_template_type_0_0::second_argument_type __y):op(__x),value(__y){}
public:typename __xcodeml_template_type_0_0::result_type operator()(typename __xcodeml_template_type_0_0::first_argument_type&__x)const{return(this->op(__x,this->value));
}
public:typename __xcodeml_template_type_0_0::result_type operator()(typename __xcodeml_template_type_0_0::first_argument_type const&__x)const{return(this->op(__x,this->value));
}
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>binder2nd<__xcodeml_template_type_0_0>{return __xcodeml_identity<binder2nd<__xcodeml_template_type_0_0> >::t(__op,__x);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class pointer_to_unary_function:public unary_function<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>{private:__xcodeml_template_type_0_1(*__f_)(__xcodeml_template_type_0_0);
public:
public:pointer_to_unary_function(__xcodeml_template_type_0_1(*__f)(__xcodeml_template_type_0_0)):__f_(__f){}
public:__xcodeml_template_type_0_1 operator()(__xcodeml_template_type_0_0 __x)const{return(this->__f_(__x));
}
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>pointer_to_unary_function<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>{return __xcodeml_identity<pointer_to_unary_function<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1> >::t(__f);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class pointer_to_binary_function:public binary_function<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2>{private:__xcodeml_template_type_0_2(*__f_)(__xcodeml_template_type_0_0,__xcodeml_template_type_0_1);
public:
public:pointer_to_binary_function(__xcodeml_template_type_0_2(*__f)(__xcodeml_template_type_0_0,__xcodeml_template_type_0_1)):__f_(__f){}
public:__xcodeml_template_type_0_2 operator()(__xcodeml_template_type_0_0 __x,__xcodeml_template_type_0_1 __y)const{return(this->__f_(__x,__y));
}
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>pointer_to_binary_function<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2>{return __xcodeml_identity<pointer_to_binary_function<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2> >::t(__f);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class mem_fun_t:public unary_function<__xcodeml_template_type_0_1(*),__xcodeml_template_type_0_0>{private:__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*__p_)();
public:
public:mem_fun_t(__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*__p)()):__p_(__p){}
public:__xcodeml_template_type_0_0 operator()(__xcodeml_template_type_0_1(*__p))const{return((__p::*this->__p_)());
}
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class mem_fun1_t:public binary_function<__xcodeml_template_type_0_1(*),__xcodeml_template_type_0_2,__xcodeml_template_type_0_0>{private:__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*__p_)(__xcodeml_template_type_0_2);
public:
public:mem_fun1_t(__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*__p)(__xcodeml_template_type_0_2)):__p_(__p){}
public:__xcodeml_template_type_0_0 operator()(__xcodeml_template_type_0_1(*__p),__xcodeml_template_type_0_2 __x)const{return((__p::*this->__p_)(__x));
}
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>mem_fun_t<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>{return __xcodeml_identity<mem_fun_t<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1> >::t(__f);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>mem_fun1_t<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2>{return __xcodeml_identity<mem_fun1_t<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2> >::t(__f);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class mem_fun_ref_t:public unary_function<__xcodeml_template_type_0_1,__xcodeml_template_type_0_0>{private:__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*__p_)();
public:
public:mem_fun_ref_t(__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*__p)()):__p_(__p){}
public:__xcodeml_template_type_0_0 operator()(__xcodeml_template_type_0_1&__p)const{return((__p.*this->__p_)());
}
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class mem_fun1_ref_t:public binary_function<__xcodeml_template_type_0_1,__xcodeml_template_type_0_2,__xcodeml_template_type_0_0>{private:__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*__p_)(__xcodeml_template_type_0_2);
public:
public:mem_fun1_ref_t(__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*__p)(__xcodeml_template_type_0_2)):__p_(__p){}
public:__xcodeml_template_type_0_0 operator()(__xcodeml_template_type_0_1&__p,__xcodeml_template_type_0_2 __x)const{return((__p.*this->__p_)(__x));
}
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>mem_fun_ref_t<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>{return __xcodeml_identity<mem_fun_ref_t<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1> >::t(__f);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>mem_fun1_ref_t<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2>{return __xcodeml_identity<mem_fun1_ref_t<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2> >::t(__f);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class const_mem_fun_t:public unary_function<__xcodeml_template_type_0_1 const(*),__xcodeml_template_type_0_0>{private:__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*__p_)()const;
public:
public:const_mem_fun_t(__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*__p)()const):__p_(__p){}
public:__xcodeml_template_type_0_0 operator()(__xcodeml_template_type_0_1 const(*__p))const{return((__p::*this->__p_)());
}
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class const_mem_fun1_t:public binary_function<__xcodeml_template_type_0_1 const(*),__xcodeml_template_type_0_2,__xcodeml_template_type_0_0>{private:__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*__p_)(__xcodeml_template_type_0_2)const;
public:
public:const_mem_fun1_t(__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*__p)(__xcodeml_template_type_0_2)const):__p_(__p){}
public:__xcodeml_template_type_0_0 operator()(__xcodeml_template_type_0_1 const(*__p),__xcodeml_template_type_0_2 __x)const{return((__p::*this->__p_)(__x));
}
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>const_mem_fun_t<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>{return __xcodeml_identity<const_mem_fun_t<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1> >::t(__f);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>const_mem_fun1_t<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2>{return __xcodeml_identity<const_mem_fun1_t<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2> >::t(__f);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class const_mem_fun_ref_t:public unary_function<__xcodeml_template_type_0_1,__xcodeml_template_type_0_0>{private:__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*__p_)()const;
public:
public:const_mem_fun_ref_t(__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*__p)()const):__p_(__p){}
public:__xcodeml_template_type_0_0 operator()(__xcodeml_template_type_0_1 const&__p)const{return((__p.*this->__p_)());
}
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class const_mem_fun1_ref_t:public binary_function<__xcodeml_template_type_0_1,__xcodeml_template_type_0_2,__xcodeml_template_type_0_0>{private:__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*__p_)(__xcodeml_template_type_0_2)const;
public:
public:const_mem_fun1_ref_t(__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*__p)(__xcodeml_template_type_0_2)const):__p_(__p){}
public:__xcodeml_template_type_0_0 operator()(__xcodeml_template_type_0_1 const&__p,__xcodeml_template_type_0_2 __x)const{return((__p.*this->__p_)(__x));
}
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>const_mem_fun_ref_t<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>{return __xcodeml_identity<const_mem_fun_ref_t<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1> >::t(__f);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>const_mem_fun1_ref_t<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2>{return __xcodeml_identity<const_mem_fun1_ref_t<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2> >::t(__f);
}
template<typename __xcodeml_template_type_0_0>class __mem_fn:public __weak_result_type<__xcodeml_template_type_0_0>{public:
public:typedef __xcodeml_template_type_0_0 type;
private:
private:__xcodeml_template_type_0_0 __f_;
public:
public:__mem_fn(__xcodeml_template_type_0_0 __f):__f_(__f){}
public:template<typename __xcodeml_template_type_1_0>typename __invoke_return<__xcodeml_template_type_0_0,...>::type operator()(void/*__args*/)const{return((this->__f_,(std::__1::__xcodeml_template_type_1_0(__args))));
}
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__mem_fn<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)>{return __xcodeml_identity<__mem_fn<__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*)> >::t(__pm);
}
class bad_function_call:public exception{}
;
void __throw_bad_function_call(){throw __xcodeml_identity<class::std::__1::bad_function_call>::t();
}
template<typename __xcodeml_template_type_0_0>class function;
;
namespace __function{template<typename __xcodeml_template_type_0_0>class __maybe_derive_from_unary_function{}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __maybe_derive_from_unary_function<__xcodeml_template_type_0_0(__xcodeml_template_type_0_1)>:public unary_function<__xcodeml_template_type_0_1,__xcodeml_template_type_0_0>{}
;
template<typename __xcodeml_template_type_0_0>class __maybe_derive_from_binary_function{}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __maybe_derive_from_binary_function<__xcodeml_template_type_0_0(__xcodeml_template_type_0_1,__xcodeml_template_type_0_2)>:public binary_function<__xcodeml_template_type_0_1,__xcodeml_template_type_0_2,__xcodeml_template_type_0_0>{}
;
template<typename __xcodeml_template_type_0_0>bool __not_null(__xcodeml_template_type_0_0 const&){return true;
}
template<typename __xcodeml_template_type_0_0>bool __not_null(__xcodeml_template_type_0_0(*__ptr)){return __ptr;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool __not_null(__xcodeml_template_type_0_0(__xcodeml_identity<__xcodeml_template_type_0_1>::t::*__ptr)){return __ptr;
}
template<typename __xcodeml_template_type_0_0>bool __not_null(function<__xcodeml_template_type_0_0>){return(!(!__f));
}
}
namespace __function{template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __alloc_func;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __default_alloc_func;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>class __alloc_func<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2(void/**/)>{private:__compressed_pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>;
public:
public:typedef __xcodeml_template_type_0_0 _Target;
public:typedef __xcodeml_template_type_0_1 _Alloc;
public:__xcodeml_template_type_0_0 const&__target()const{return(this->__f_.first());
}
public:__xcodeml_template_type_0_1 const&__get_allocator()const{return(this->__f_.second());
}
public:__alloc_func(__xcodeml_template_type_0_0(*__f)):__f_(piecewise_construct(std::__1::((std::__1::(__f))))(std::__1::forward_as_tuple())){}
public:__alloc_func(__xcodeml_template_type_0_0 const&__f,__xcodeml_template_type_0_1 const&__a):__f_(piecewise_construct(std::__1::(__f))(std::__1::(__a))){}
public:__alloc_func(__xcodeml_template_type_0_0 const&__f,__xcodeml_template_type_0_1(*__a)):__f_(piecewise_construct(std::__1::(__f))(std::__1::((std::__1::(__a))))){}
public:__alloc_func(__xcodeml_template_type_0_0(*__f),__xcodeml_template_type_0_1(*__a)):__f_(piecewise_construct(std::__1::((std::__1::(__f))))(std::__1::((std::__1::(__a))))){}
public:__xcodeml_template_type_0_2 operator()(void/*__arg*/){typedef __invoke_void_return_wrapper<__xcodeml_template_type_0_2>;
return(__invoke_void_return_wrapper<__xcodeml_template_type_0_2>::.__call((this->__f_.first()),(std::__1::__xcodeml_template_type_0_3(__arg))));
}
public:class __alloc_func<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2(void/**/)>(*__clone()const){typedef allocator_traits<__xcodeml_template_type_0_1>;
typedef typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_1>,class __alloc_func<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2(void/**/)> >::type _AA;
typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_1>,class __alloc_func<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2(void/**/)> >::type __a=(this->__f_.second());
typedef __allocator_destructor<typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_1>,class __alloc_func<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2(void/**/)> >::type>;
unique_ptr<class __alloc_func<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2(void/**/)>,__allocator_destructor<typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_1>,class __alloc_func<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2(void/**/)> >::type> > =(__a.allocate(1))__xcodeml_identity<__allocator_destructor<typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_1>,class __alloc_func<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2(void/**/)> >::type> >::t(__a,1);
::new(((void(*))(__hold.get())))__xcodeml_identity<class __alloc_func<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2(void/**/)> >::t((this->__f_.first()),__xcodeml_identity<__xcodeml_template_type_0_1>::t(__a));
return(__hold.release());
}
public:void destroy(){(void/**/this->__f_());
}
public:static void __destroy_and_delete(class __alloc_func<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2(void/**/)>(*__f)){typedef allocator_traits<__xcodeml_template_type_0_1>;
typedef typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_1>,class __alloc_func<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2(void/**/)> >::type _FunAlloc;
typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_1>,class __alloc_func<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2(void/**/)> >::type __a=(__f.__get_allocator());
(__f.destroy());
(__a.deallocate(__f,1));
}
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __default_alloc_func<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1(void/**/)>{private:__xcodeml_template_type_0_0 __f_;
public:
public:typedef __xcodeml_template_type_0_0 _Target;
public:__xcodeml_template_type_0_0 const&__target()const{return this->__f_;
}
public:__default_alloc_func(__xcodeml_template_type_0_0(*__f)):__f_((std::(__f))){}
public:__default_alloc_func(__xcodeml_template_type_0_0 const&__f):__f_(__f){}
public:__xcodeml_template_type_0_1 operator()(void/*__arg*/){typedef __invoke_void_return_wrapper<__xcodeml_template_type_0_1>;
return(__invoke_void_return_wrapper<__xcodeml_template_type_0_1>::.__call(this->__f_,(std::__1::__xcodeml_template_type_0_2(__arg))));
}
public:class __default_alloc_func<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1(void/**/)>(*__clone()const){class::std::__1::unique_ptr<void,class::std::__1::__builtin_new_allocator::__builtin_new_deleter>__hold=(__builtin_new_allocator::class __default_alloc_func<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1(void/**/)>(1));
class __default_alloc_func<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1(void/**/)>(*__res)=::new((__hold.get()))__xcodeml_identity<class __default_alloc_func<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1(void/**/)> >::t(this->__f_);
((void)(__hold.release()));
return __res;
}
public:void destroy(){(__xcodeml_template_type_0_0 this->__f_());
}
public:static void __destroy_and_delete(class __default_alloc_func<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1(void/**/)>(*__f)){(__f.destroy());
(__builtin_new_allocator::class __default_alloc_func<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1(void/**/)>(__f,1));
}
}
;
template<typename __xcodeml_template_type_0_0>class __base;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __base<__xcodeml_template_type_0_0(void/**/)>{private:__base(class __base const&);
private:class __base<__xcodeml_template_type_0_0(void/**/)>&operator=(class __base const&);
public:
public:__base(){}
public:virtual~__base(){}
public:virtual class __base<__xcodeml_template_type_0_0(void/**/)>(*__clone()const)=0;
public:virtual void __clone(class __base<__xcodeml_template_type_0_0(void/**/)>(*))const=0;
public:virtual void destroy()=0;
public:virtual void destroy_deallocate()=0;
public:virtual __xcodeml_template_type_0_0 operator()(void/**/)=0;
public:virtual void const(*target(class type_info const&)const)=0;
public:virtual class type_info const&target_type()const=0;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __func;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>class __func<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2(void/**/)>:public __base<__xcodeml_template_type_0_2(void/**/)>{private:__alloc_func<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2(void/**/)>;
public:
public:__func(__xcodeml_template_type_0_0(*__f)):__f_((std::__1::(__f))){}
public:__func(__xcodeml_template_type_0_0 const&__f,__xcodeml_template_type_0_1 const&__a):__f_(__f __a){}
public:__func(__xcodeml_template_type_0_0 const&__f,__xcodeml_template_type_0_1(*__a)):__f_(__f(std::__1::(__a))){}
public:__func(__xcodeml_template_type_0_0(*__f),__xcodeml_template_type_0_1(*__a)):__f_((std::__1::(__f))(std::__1::(__a))){}
public:virtual __base<__xcodeml_template_type_0_2(void/**/)>;
public:virtual void __clone(__base<__xcodeml_template_type_0_2(void/**/)>)const;
public:virtual void destroy();
public:virtual void destroy_deallocate();
public:virtual __xcodeml_template_type_0_2 operator()(void/*__arg*/);
public:virtual void const(*target(class type_info const&)const);
public:virtual class type_info const&target_type()const;
}
;
__base<__xcodeml_template_type_0_2(void/**/)>{typedef allocator_traits<__xcodeml_template_type_0_1>;
typedef typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_1>,class __func<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2(void/**/)> >::type _Ap;
typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_1>,class __func<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2(void/**/)> >::type __a=(this->__f_.__get_allocator());
typedef __allocator_destructor<typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_1>,class __func<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2(void/**/)> >::type>;
unique_ptr<class __func<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2(void/**/)>,__allocator_destructor<typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_1>,class __func<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2(void/**/)> >::type> > =(__a.allocate(1))__xcodeml_identity<__allocator_destructor<typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_1>,class __func<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2(void/**/)> >::type> >::t(__a,1);
::new(((void(*))(__hold.get())))__xcodeml_identity<class __func<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2(void/**/)> >::t((this->__f_.__target()),__xcodeml_identity<__xcodeml_template_type_0_1>::t(__a));
return(__hold.release());
}
void __func::__clone(__base<__xcodeml_template_type_0_2(void/**/)>)const{::new(__p)__xcodeml_identity<class __func<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2(void/**/)> >::t((this->__f_.__target()),(this->__f_.__get_allocator()));
}
void __func::destroy(){(this->__f_.destroy());
}
void __func::destroy_deallocate(){typedef allocator_traits<__xcodeml_template_type_0_1>;
typedef typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_1>,class __func<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2(void/**/)> >::type _Ap;
typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_1>,class __func<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2(void/**/)> >::type __a=(this->__f_.__get_allocator());
(this->__f_.destroy());
(__a.deallocate(this,1));
}
__xcodeml_template_type_0_2 __func::operator()(void/*__arg*/){return(this->__f_((std::__1::__xcodeml_template_type_0_3(__arg))));
}
void const(*__func::target(class type_info const&__ti)const){if(__ti.operator==(__xcodeml_template_type_0_0)){return(&(this->__f_.__target()));};
return((void const(*))0);
}
class type_info const&__func::target_type()const{return __xcodeml_template_type_0_0;
}
template<typename __xcodeml_template_type_0_0>class __value_func;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __value_func<__xcodeml_template_type_0_0(void/**/)>{private:class::std::__1::aligned_storage<24,16>::type __buf_;
private:typedef __base<__xcodeml_template_type_0_0(void/**/)>;
private:__base<__xcodeml_template_type_0_0(void/**/)>;
private:static __base<__xcodeml_template_type_0_0(void/**/)>{return reinterpret_cast<__base<__xcodeml_template_type_0_0(void/**/)> >(p);
}
public:
public:__value_func():__f_(0){}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>__value_func(__xcodeml_template_type_1_0(*__f),__xcodeml_template_type_1_1 const&__a):__f_(0){typedef allocator_traits<__xcodeml_template_type_1_1>;
typedef __func<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1,__xcodeml_template_type_0_0(void/**/)>;
typedef typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_1_1>,__func<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1,__xcodeml_template_type_0_0(void/**/)> >::type _FunAlloc;
if((__function::(__f))){{typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_1_1>,__func<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1,__xcodeml_template_type_0_0(void/**/)> >::type __af=__a;
if(((((sizeof(__func<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1,__xcodeml_template_type_0_0(void/**/)>))<=(sizeof(this->__buf_)))&&is_nothrow_copy_constructible<__xcodeml_template_type_1_0>::.value)&&is_nothrow_copy_constructible<typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_1_1>,__func<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1,__xcodeml_template_type_0_0(void/**/)> >::type>::.value)){{(this->__f_=::new(((void(*))(&this->__buf_)))__xcodeml_identity<__func<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1,__xcodeml_template_type_0_0(void/**/)> >::t((std::__1::(__f)),__xcodeml_identity<__xcodeml_template_type_1_1>::t(__af)));
};}else{{typedef __allocator_destructor<typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_1_1>,__func<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1,__xcodeml_template_type_0_0(void/**/)> >::type>;
unique_ptr<__base<__xcodeml_template_type_0_0(void/**/)>,__allocator_destructor<typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_1_1>,__func<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1,__xcodeml_template_type_0_0(void/**/)> >::type> > =(__af.allocate(1))__xcodeml_identity<__allocator_destructor<typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_1_1>,__func<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1,__xcodeml_template_type_0_0(void/**/)> >::type> >::t(__af,1);
::new(((void(*))(__hold.get())))__xcodeml_identity<__func<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1,__xcodeml_template_type_0_0(void/**/)> >::t((std::__1::(__f)),__xcodeml_identity<__xcodeml_template_type_1_1>::t(__a));
(this->__f_=(__hold.release()));
};};
};};
}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>__value_func(__xcodeml_template_type_1_0(*__f)):__value_func((std::__xcodeml_template_type_1_0(__f))__xcodeml_identity<allocator<__xcodeml_template_type_1_0> >::t()){}
public:__value_func(class __value_func const&__f){if((__f.__f_,0)){(this->__f_=0);}else{if((((void(*))__f.__f_),(&__f.__buf_))){{(this->__f_=(__as_base((&this->__buf_))));
(__f.__f_.__clone(this->__f_));
};}else{(this->__f_=(__f.__f_.__clone()));};};
}
public:__value_func(class __value_func<__xcodeml_template_type_0_0(void/**/)>(*__f)){if((__f.__f_,0)){(this->__f_=0);}else{if((((void(*))__f.__f_),(&__f.__buf_))){{(this->__f_=(__as_base((&this->__buf_))));
(__f.__f_.__clone(this->__f_));
};}else{{(this->__f_=__f.__f_);
(__f.__f_=0);
};};};
}
public:~__value_func(){if((((void(*))this->__f_),(&this->__buf_))){(this->__f_.destroy());}else{if(this->__f_){(this->__f_.destroy_deallocate());};};
}
public:class __value_func<__xcodeml_template_type_0_0(void/**/)>&operator=(class __value_func<__xcodeml_template_type_0_0(void/**/)>(*__f)){((*this)=nullptr);
if((__f.__f_,0)){(this->__f_=0);}else{if((((void(*))__f.__f_),(&__f.__buf_))){{(this->__f_=(__as_base((&this->__buf_))));
(__f.__f_.__clone(this->__f_));
};}else{{(this->__f_=__f.__f_);
(__f.__f_=0);
};};};
return(*this);
}
public:class __value_func<__xcodeml_template_type_0_0(void/**/)>&operator=(nullptr_t){__base<__xcodeml_template_type_0_0(void/**/)> =this->__f_;
(this->__f_=0);
if((((void(*))__f),(&this->__buf_))){(__f.destroy());}else{if(__f){(__f.destroy_deallocate());};};
return(*this);
}
public:__xcodeml_template_type_0_0 operator()(void/*__args*/)const{if((this->__f_,0)){(__throw_bad_function_call());};
return((*this->__f_)((std::__1::__xcodeml_template_type_0_1(__args))));
}
public:void swap(class __value_func<__xcodeml_template_type_0_0(void/**/)>&__f){if(((&__f),this)){return;};
if(((((void(*))this->__f_),(&this->__buf_))&&(((void(*))__f.__f_),(&__f.__buf_)))){{typename aligned_storage<expression,expression>::type __tempbuf;
__base<__xcodeml_template_type_0_0(void/**/)> =(__as_base((&__tempbuf)));
(this->__f_.__clone(__t));
(this->__f_.destroy());
(this->__f_=0);
(__f.__f_.__clone((__as_base((&this->__buf_)))));
(__f.__f_.destroy());
(__f.__f_=0);
(this->__f_=(__as_base((&this->__buf_))));
(__t.__clone((__as_base((&__f.__buf_)))));
(__t.destroy());
(__f.__f_=(__as_base((&__f.__buf_))));
};}else{if((((void(*))this->__f_),(&this->__buf_))){{(this->__f_.__clone((__as_base((&__f.__buf_)))));
(this->__f_.destroy());
(this->__f_=__f.__f_);
(__f.__f_=(__as_base((&__f.__buf_))));
};}else{if((((void(*))__f.__f_),(&__f.__buf_))){{(__f.__f_.__clone((__as_base((&this->__buf_)))));
(__f.__f_.destroy());
(__f.__f_=this->__f_);
(this->__f_=(__as_base((&this->__buf_))));
};}else{(std::__1::(this->__f_,__f.__f_));};};};
}
public:operator bool()const{return(this->__f_,0);
}
public:class type_info const&target_type()const{if((this->__f_,0)){return void;};
return(this->__f_.target_type());
}
public:template<typename __xcodeml_template_type_1_0>__xcodeml_template_type_1_0 const(*target()const){if((this->__f_,0)){return 0;};
return((__xcodeml_template_type_1_0 const(*))(this->__f_.target(__xcodeml_template_type_1_0)));
}
}
;
union __policy_storage{public:char __small[16];
public:void(*__large);
}
;
template<typename __xcodeml_template_type_0_0>class __use_small_storage:public integral_constant<bool,expression>{}
;
;
class __policy{public:void(*(*const __clone)(void const(*)));
public:void(*const __destroy)(void(*));
public:bool const __is_null;
public:class type_info const(*const __type_info);
public:template<typename __xcodeml_template_type_0_0>static class __policy const(*__create()){return(__xcodeml_template_type_0_0(__xcodeml_identity<__use_small_storage<__xcodeml_template_type_0_0> >::t()));
}
public:static class __policy const(*__create_empty()){static constexpr class __policy const __policy_={nullptr,nullptr,true,(&void)};
return(&__policy_);
}
private:
private:template<typename __xcodeml_template_type_0_0>static void(*__large_clone(void const(*__s))){__xcodeml_template_type_0_0 const(*__f)=static_cast<__xcodeml_template_type_0_0 const(*)>(__s);
return(__f.__clone());
}
private:template<typename __xcodeml_template_type_0_0>static void __large_destroy(void(*__s)){(__xcodeml_template_type_0_0::__destroy_and_delete(static_cast<__xcodeml_template_type_0_0(*)>(__s)));
}
private:template<typename __xcodeml_template_type_0_0>static class __policy const(*__choose_policy(class::std::__1::integral_constant<bool,0>)){static constexpr class __policy const __policy_={(&__xcodeml_template_type_0_0),(&__xcodeml_template_type_0_0),false,(&typename __xcodeml_template_type_0_0::_Target)};
return(&__policy_);
}
private:template<typename __xcodeml_template_type_0_0>static class __policy const(*__choose_policy(class::std::__1::integral_constant<bool,1>)){static constexpr class __policy const __policy_={nullptr,nullptr,false,(&typename __xcodeml_template_type_0_0::_Target)};
return(&__policy_);
}
}
;
template<typename __xcodeml_template_type_0_0>using __fast_forward=typename conditional<expression,__xcodeml_template_type_0_0,__xcodeml_template_type_0_0(*)>::type;
template<typename __xcodeml_template_type_0_0>class __policy_invoker;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __policy_invoker<__xcodeml_template_type_0_0(void/**/)>{public:typedef __xcodeml_template_type_0_0(*__Call)(union __policy_storage const(*),void/**/);
public:__xcodeml_template_type_0_0(*__call_)(union __policy_storage const(*),void/**/);
public:__policy_invoker():__call_((&__call_empty)){}
public:template<typename __xcodeml_template_type_1_0>static class __policy_invoker<__xcodeml_template_type_0_0(void/**/)>__create(){return __xcodeml_identity<class __policy_invoker<__xcodeml_template_type_0_0(void/**/)> >::t((&__xcodeml_template_type_1_0));
}
private:
private:__policy_invoker(__xcodeml_template_type_0_0(*__c)(union __policy_storage const(*),void/**/)):__call_(__c){}
private:static __xcodeml_template_type_0_0 __call_empty(union __policy_storage const(*),void/**/){(__throw_bad_function_call());
}
private:template<typename __xcodeml_template_type_1_0>static __xcodeml_template_type_0_0 __call_impl(union __policy_storage const(*__buf),void/*__args*/){__xcodeml_template_type_1_0(*__f)=reinterpret_cast<__xcodeml_template_type_1_0(*)>((__use_small_storage<__xcodeml_template_type_1_0>::value?(&__buf->__small):__buf->__large));
return((*__f)((std::__1::__xcodeml_template_type_0_1(__args))));
}
}
;
template<typename __xcodeml_template_type_0_0>class __policy_func;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __policy_func<__xcodeml_template_type_0_0(void/**/)>{private:union::std::__1::__function::__policy_storage __buf_;
private:typedef __policy_invoker<__xcodeml_template_type_0_0(void/**/)>;
private:__policy_invoker<__xcodeml_template_type_0_0(void/**/)>;
private:class __policy const(*__policy_);
public:
public:__policy_func():__policy_((__policy::__create_empty())){}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>__policy_func(__xcodeml_template_type_1_0(*__f),__xcodeml_template_type_1_1 const&__a):__policy_((__policy::__create_empty())){typedef __alloc_func<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1,__xcodeml_template_type_0_0(void/**/)>;
typedef allocator_traits<__xcodeml_template_type_1_1>;
typedef typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_1_1>,__alloc_func<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1,__xcodeml_template_type_0_0(void/**/)> >::type _FunAlloc;
if((__function::(__f))){{(this->__invoker_=(__policy_invoker<__xcodeml_template_type_0_0(void/**/)>::.__create()));
(this->__policy_=(__policy::__alloc_func<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1,__xcodeml_template_type_0_0(void/**/)>()));
typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_1_1>,__alloc_func<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1,__xcodeml_template_type_0_0(void/**/)> >::type __af=__a;
if(__xcodeml_identity<__use_small_storage<__alloc_func<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1,__xcodeml_template_type_0_0(void/**/)> > >::t()){{::new(((void(*))(&this->__buf_.__small)))__xcodeml_identity<__alloc_func<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1,__xcodeml_template_type_0_0(void/**/)> >::t((std::__1::(__f)),__xcodeml_identity<__xcodeml_template_type_1_1>::t(__af));
};}else{{typedef __allocator_destructor<typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_1_1>,__alloc_func<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1,__xcodeml_template_type_0_0(void/**/)> >::type>;
unique_ptr<__alloc_func<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1,__xcodeml_template_type_0_0(void/**/)>,__allocator_destructor<typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_1_1>,__alloc_func<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1,__xcodeml_template_type_0_0(void/**/)> >::type> > =(__af.allocate(1))__xcodeml_identity<__allocator_destructor<typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_1_1>,__alloc_func<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1,__xcodeml_template_type_0_0(void/**/)> >::type> >::t(__af,1);
::new(((void(*))(__hold.get())))__xcodeml_identity<__alloc_func<__xcodeml_template_type_1_0,__xcodeml_template_type_1_1,__xcodeml_template_type_0_0(void/**/)> >::t((std::__1::(__f)),__xcodeml_identity<__xcodeml_template_type_1_1>::t(__af));
(this->__buf_.__large=(__hold.release()));
};};
};};
}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>__policy_func(__xcodeml_template_type_1_0(*__f)):__policy_((__policy::__create_empty())){typedef __default_alloc_func<__xcodeml_template_type_1_0,__xcodeml_template_type_0_0(void/**/)>;
if((__function::(__f))){{(this->__invoker_=(__policy_invoker<__xcodeml_template_type_0_0(void/**/)>::.__create()));
(this->__policy_=(__policy::__default_alloc_func<__xcodeml_template_type_1_0,__xcodeml_template_type_0_0(void/**/)>()));
if(__xcodeml_identity<__use_small_storage<__default_alloc_func<__xcodeml_template_type_1_0,__xcodeml_template_type_0_0(void/**/)> > >::t()){{::new(((void(*))(&this->__buf_.__small)))__xcodeml_identity<__default_alloc_func<__xcodeml_template_type_1_0,__xcodeml_template_type_0_0(void/**/)> >::t((std::__1::(__f)));
};}else{{class::std::__1::unique_ptr<void,class::std::__1::__builtin_new_allocator::__builtin_new_deleter>__hold=(__builtin_new_allocator::__default_alloc_func<__xcodeml_template_type_1_0,__xcodeml_template_type_0_0(void/**/)>(1));
(this->__buf_.__large=::new((__hold.get()))__xcodeml_identity<__default_alloc_func<__xcodeml_template_type_1_0,__xcodeml_template_type_0_0(void/**/)> >::t((std::__1::(__f))));
((void)(__hold.release()));
};};
};};
}
public:__policy_func(class __policy_func const&__f):__buf_(__f.__buf_),__invoker_(__f.__invoker_),__policy_(__f.__policy_){if(this->__policy_->__clone){(this->__buf_.__large=(this->__policy_->__clone(__f.__buf_.__large)));};
}
public:__policy_func(class __policy_func<__xcodeml_template_type_0_0(void/**/)>(*__f)):__buf_(__f.__buf_),__invoker_(__f.__invoker_),__policy_(__f.__policy_){if(this->__policy_->__destroy){{(__f.__policy_=(__policy::__create_empty()));
(__f.__invoker_=__xcodeml_identity<__policy_invoker<__xcodeml_template_type_0_0(void/**/)> >::t());
};};
}
public:~__policy_func(){if(this->__policy_->__destroy){(this->__policy_->__destroy(this->__buf_.__large));};
}
public:class __policy_func<__xcodeml_template_type_0_0(void/**/)>&operator=(class __policy_func<__xcodeml_template_type_0_0(void/**/)>(*__f)){((*this)=nullptr);
(this->__buf_=__f.__buf_);
(this->__invoker_=__f.__invoker_);
(this->__policy_=__f.__policy_);
(__f.__policy_=(__policy::__create_empty()));
(__f.__invoker_=__xcodeml_identity<__policy_invoker<__xcodeml_template_type_0_0(void/**/)> >::t());
return(*this);
}
public:class __policy_func<__xcodeml_template_type_0_0(void/**/)>&operator=(nullptr_t){class __policy const(*__p)=this->__policy_;
(this->__policy_=(__policy::__create_empty()));
(this->__invoker_=__xcodeml_identity<__policy_invoker<__xcodeml_template_type_0_0(void/**/)> >::t());
if(__p->__destroy){(__p->__destroy(this->__buf_.__large));};
return(*this);
}
public:__xcodeml_template_type_0_0 operator()(void/*__args*/)const{return(this->__invoker_.__call_((std::__1::(this->__buf_)),(std::__1::__xcodeml_template_type_0_1(__args))));
}
public:void swap(class __policy_func<__xcodeml_template_type_0_0(void/**/)>&__f){(std::__1::(this->__invoker_,__f.__invoker_));
(std::__1::(this->__policy_,__f.__policy_));
(std::__1::(this->__buf_,__f.__buf_));
}
public:operator bool()const{return(!this->__policy_->__is_null);
}
public:class type_info const&target_type()const{return(*this->__policy_->__type_info);
}
public:template<typename __xcodeml_template_type_1_0>__xcodeml_template_type_1_0 const(*target()const){if((this->__policy_->__is_null||__xcodeml_template_type_1_0.operator!=((*this->__policy_->__type_info)))){return nullptr;};
if(this->__policy_->__clone){return reinterpret_cast<__xcodeml_template_type_1_0 const(*)>(this->__buf_.__large);}else{return reinterpret_cast<__xcodeml_template_type_1_0 const(*)>((&this->__buf_.__small));};
}
}
;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class function<__xcodeml_template_type_0_0(void/**/)>:public __maybe_derive_from_unary_function<__xcodeml_template_type_0_0(void/**/)>,public __maybe_derive_from_binary_function<__xcodeml_template_type_0_0(void/**/)>{private:typedef __value_func<__xcodeml_template_type_0_0(void/**/)>;
private:__value_func<__xcodeml_template_type_0_0(void/**/)>;
private:template<typename __xcodeml_template_type_1_0,bool=void/**/::value>class __callable;
;

/* Ignored a member with no access specifier template<typename __xcodeml_template_type_1_0>class __callable<__xcodeml_template_type_1_0,1>{public:static bool const value=(is_same<void,__xcodeml_template_type_0_0>::value||is_convertible<typename __invoke_of<__xcodeml_template_type_1_0&,...>::type,__xcodeml_template_type_0_0>::value);
}
;*/


/* Ignored a member with no access specifier template<typename __xcodeml_template_type_1_0>class __callable<__xcodeml_template_type_1_0,0>{public:static bool const value=false;
}
;*/

private:template<typename __xcodeml_template_type_1_0>using _EnableIfCallable=typename enable_if<expression,void>::type;
public:
public:typedef __xcodeml_template_type_0_0 result_type;
public:function(){}
public:function(nullptr_t){}
public:function(class function const&);
public:function(class function<__xcodeml_template_type_0_0(void/**/)>(*));
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>function(__xcodeml_template_type_1_0)
public:template<typename __xcodeml_template_type_1_0>function(class::std::__1::allocator_arg_t,__xcodeml_template_type_1_0 const&){}
public:template<typename __xcodeml_template_type_1_0>function(class::std::__1::allocator_arg_t,__xcodeml_template_type_1_0 const&,nullptr_t){}
public:template<typename __xcodeml_template_type_1_0>function(class::std::__1::allocator_arg_t,__xcodeml_template_type_1_0 const&,class function const&)
public:template<typename __xcodeml_template_type_1_0>function(class::std::__1::allocator_arg_t,__xcodeml_template_type_1_0 const&,class function<__xcodeml_template_type_0_0(void/**/)>(*))
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1,typename __xcodeml_template_type_1_2>function(class::std::__1::allocator_arg_t,__xcodeml_template_type_1_1 const&__a,__xcodeml_template_type_1_0 __f)
public:class function<__xcodeml_template_type_0_0(void/**/)>&operator=(class function const&);
public:class function<__xcodeml_template_type_0_0(void/**/)>&operator=(class function<__xcodeml_template_type_0_0(void/**/)>(*));
public:class function<__xcodeml_template_type_0_0(void/**/)>&operator=(nullptr_t);
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>class function<__xcodeml_template_type_0_0(void/**/)>&operator=(__xcodeml_template_type_1_0(*))
public:~function();
public:void swap(class function<__xcodeml_template_type_0_0(void/**/)>&);
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>void assign(__xcodeml_template_type_1_0(*__f),__xcodeml_template_type_1_1 const&__a){(__xcodeml_identity<class function<__xcodeml_template_type_0_0(void/**/)> >::t(allocator_arg,__a,(std::__1::__xcodeml_template_type_1_0(__f))).swap((*this)));
}
public:operator bool()const{return static_cast<bool>(this->__f_);
}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>bool operator==(function<__xcodeml_template_type_1_0(void/**/)>)const
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>bool operator!=(function<__xcodeml_template_type_1_0(void/**/)>)const
public:
public:__xcodeml_template_type_0_0 operator()(void/**/)const;
public:class type_info const&target_type()const;
public:template<typename __xcodeml_template_type_1_0>__xcodeml_template_type_1_0(*target())
public:template<typename __xcodeml_template_type_1_0>__xcodeml_template_type_1_0 const(*target()const)
}
;
function::function(class function const&__f):__f_(__f.__f_){}
template<typename __xcodeml_template_type_1_0>function::function(class::std::__1::allocator_arg_t,__xcodeml_template_type_1_0 const&,class function const&__f):__f_(__f.__f_){}
function::function(class function<__xcodeml_template_type_0_0(void/**/)>(*__f)):__f_((std::__1::(__f.__f_))){}
template<typename __xcodeml_template_type_1_0>function::function(class::std::__1::allocator_arg_t,__xcodeml_template_type_1_0 const&,class function<__xcodeml_template_type_0_0(void/**/)>(*__f)):__f_((std::__1::(__f.__f_))){}
template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>function::function(__xcodeml_template_type_1_0 __f):__f_((std::__1::(__f))){}
template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1,typename __xcodeml_template_type_1_2>function::function(class::std::__1::allocator_arg_t,__xcodeml_template_type_1_1 const&__a,__xcodeml_template_type_1_0 __f):__f_((std::__1::(__f))__a){}
class function<__xcodeml_template_type_0_0(void/**/)>&function::operator=(class function const&__f){(__xcodeml_identity<class function<__xcodeml_template_type_0_0(void/**/)> >::t(__f).swap((*this)));
return(*this);
}
class function<__xcodeml_template_type_0_0(void/**/)>&function::operator=(class function<__xcodeml_template_type_0_0(void/**/)>(*__f)){(this->__f_=(std::(__f.__f_)));
return(*this);
}
class function<__xcodeml_template_type_0_0(void/**/)>&function::operator=(nullptr_t){(this->__f_=nullptr);
return(*this);
}
template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>class function<__xcodeml_template_type_0_0(void/**/)>&function::operator=(__xcodeml_template_type_1_0(*__f)){(__xcodeml_identity<class function<__xcodeml_template_type_0_0(void/**/)> >::t((std::__1::__xcodeml_template_type_1_0(__f))).swap((*this)));
return(*this);
}
function::~function(){}
void function::swap(class function<__xcodeml_template_type_0_0(void/**/)>&__f){(this->__f_.swap(__f.__f_));
}
__xcodeml_template_type_0_0 function::operator()(void/*__arg*/)const{return(this->__f_((std::__1::__xcodeml_template_type_0_1(__arg))));
}
class type_info const&function::target_type()const{return(this->__f_.target_type());
}
template<typename __xcodeml_template_type_1_0>__xcodeml_template_type_1_0(*function::target()){return((__xcodeml_template_type_1_0(*))(this->__f_.target()));
}
template<typename __xcodeml_template_type_1_0>__xcodeml_template_type_1_0 const(*function::target()const){return(this->__f_.target());
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator==(function<__xcodeml_template_type_0_0(void/**/)>,nullptr_t){return(!__f);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator==(nullptr_t,function<__xcodeml_template_type_0_0(void/**/)>){return(!__f);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator!=(function<__xcodeml_template_type_0_0(void/**/)>,nullptr_t){return((bool)__f);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator!=(nullptr_t,function<__xcodeml_template_type_0_0(void/**/)>){return((bool)__f);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void swap(function<__xcodeml_template_type_0_0(void/**/)>,function<__xcodeml_template_type_0_0(void/**/)>){return(__x.swap(__y));
}
template<typename __xcodeml_template_type_0_0>class __is_bind_expression:public integral_constant<bool,0>{}
;
;
template<typename __xcodeml_template_type_0_0>class is_bind_expression:public __is_bind_expression<typename remove_cv<__xcodeml_template_type_0_0>::type>{}
;
;
template<typename __xcodeml_template_type_0_0>class __is_placeholder:public integral_constant<int,0>{}
;
;
template<typename __xcodeml_template_type_0_0>class is_placeholder:public __is_placeholder<typename remove_cv<__xcodeml_template_type_0_0>::type>{}
;
;
namespace placeholders{template<int _Np>class __ph{}
;
template<>class __ph<1>{}
template<>class __ph<2>{}
template<>class __ph<3>{}
template<>class __ph<4>{}
template<>class __ph<5>{}
template<>class __ph<6>{}
template<>class __ph<7>{}
template<>class __ph<8>{}
template<>class __ph<9>{}
template<>class __ph<10>{}
;
constexpr class __ph const _1={};
constexpr class __ph const _2={};
constexpr class __ph const _3={};
constexpr class __ph const _4={};
constexpr class __ph const _5={};
constexpr class __ph const _6={};
constexpr class __ph const _7={};
constexpr class __ph const _8={};
constexpr class __ph const _9={};
constexpr class __ph const _10={};
}
template<int _Np>class __is_placeholder<__ph<expression> >:public integral_constant<int,expression>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0&__mu(reference_wrapper<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_1&){return(__t.get());
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,unsigned long _Indx>typename __invoke_of<__xcodeml_template_type_0_0&,...>::type __mu_expand(__xcodeml_template_type_0_0&__ti,tuple<...>,__tuple_indices<...>){return(__ti((std::__1::__xcodeml_template_type_0_1((std::__1::_Indx(__uj))))));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename void/**/::type __mu(__xcodeml_template_type_0_0&__ti,tuple<...>){typedef typename __make_tuple_indices<expression,0>::type __indices;
return((__ti,__uj,__xcodeml_identity<typename __make_tuple_indices<expression,0>::type>::t()));
}
template<bool IsPh,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __mu_return2{}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __mu_return2<1,__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>{public:typedef typename tuple_element<expression,__xcodeml_template_type_0_1>::type type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename enable_if<expression,typename __mu_return2<expression,__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::type>::type __mu(__xcodeml_template_type_0_0&,__xcodeml_template_type_0_1&__uj){unsigned long const _Indx=(is_placeholder<__xcodeml_template_type_0_0>::value,1);
return(std::__1::typename tuple_element<expression,__xcodeml_template_type_0_1>::type((std::__1::_Indx(__uj))));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename enable_if<expression,__xcodeml_template_type_0_0&>::type __mu(__xcodeml_template_type_0_0&__ti,__xcodeml_template_type_0_1&){return __ti;
}
template<typename __xcodeml_template_type_0_0,bool IsReferenceWrapper,bool IsBindEx,bool IsPh,typename __xcodeml_template_type_0_4>class __mu_return_impl;
;
template<bool _Invokable,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __mu_return_invokable{public:typedef class::std::__1::__nat type;
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __mu_return_invokable<1,__xcodeml_template_type_0_0,...>{public:typedef typename __invoke_of<__xcodeml_template_type_0_0&,...>::type type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __mu_return_impl<__xcodeml_template_type_0_0,0,1,0,tuple<...> >:public __mu_return_invokable<expression,__xcodeml_template_type_0_0,...>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __mu_return_impl<__xcodeml_template_type_0_0,0,0,1,__xcodeml_template_type_0_1>{public:typedef typename tuple_element<expression,__xcodeml_template_type_0_1>::type(*type);
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __mu_return_impl<__xcodeml_template_type_0_0,1,0,0,__xcodeml_template_type_0_1>{public:typedef typename __xcodeml_template_type_0_0::type&type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __mu_return_impl<__xcodeml_template_type_0_0,0,0,0,__xcodeml_template_type_0_1>{public:typedef __xcodeml_template_type_0_0&type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __mu_return:public __mu_return_impl<__xcodeml_template_type_0_0,expression,expression,expression,__xcodeml_template_type_0_1>{}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __is_valid_bind_return{public:static bool const value=false;
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __is_valid_bind_return<__xcodeml_template_type_0_0,tuple<...>,__xcodeml_template_type_0_2>{public:static bool const value=__invokable_r<void,__xcodeml_template_type_0_0,...>::value;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __is_valid_bind_return<__xcodeml_template_type_0_0,tuple<...>,__xcodeml_template_type_0_2>{public:static bool const value=__invokable_r<void,__xcodeml_template_type_0_0,...>::value;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,bool=__is_valid_bind_return<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_2>::value>class __bind_return;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __bind_return<__xcodeml_template_type_0_0,tuple<...>,__xcodeml_template_type_0_2,1>{public:typedef typename __invoke_of<__xcodeml_template_type_0_0&,...>::type type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __bind_return<__xcodeml_template_type_0_0,tuple<...>,__xcodeml_template_type_0_2,1>{public:typedef typename __invoke_of<__xcodeml_template_type_0_0&,...>::type type;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,unsigned long _Indx,typename __xcodeml_template_type_0_3>typename __bind_return<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,__xcodeml_template_type_0_3,expression>::type __apply_functor(__xcodeml_template_type_0_0&__f,__xcodeml_template_type_0_1&__bound_args,__tuple_indices<...>,__xcodeml_template_type_0_3(*__args)){return(std::__1::(__f,(std::__1::((std::__1::_Indx(__bound_args)),__args))));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __bind:public __weak_result_type<typename decay<__xcodeml_template_type_0_0>::type>{protected:
protected:typedef typename decay<__xcodeml_template_type_0_0>::type _Fd;
protected:typedef tuple<...>;
private:
private:typename decay<__xcodeml_template_type_0_0>::type __f_;
private:tuple<...>;
private:typedef typename __make_tuple_indices<expression,0>::type __indices;
public:
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1,typename __xcodeml_template_type_1_2>__bind(__xcodeml_template_type_1_0(*__f),void/*__bound_args*/):__f_((std::__1::__xcodeml_template_type_1_0(__f))),__bound_args_((std::__1::__xcodeml_template_type_1_1(__bound_args))){}
public:template<typename __xcodeml_template_type_1_0>typename __bind_return<typename decay<__xcodeml_template_type_0_0>::type,tuple<...>,tuple<...>,expression>::type operator()(void/*__args*/){return(std::__1::(this->__f_,this->__bound_args_,__xcodeml_identity<typename __make_tuple_indices<expression,0>::type>::t(),__xcodeml_identity<tuple<...> >::t((std::__1::__xcodeml_template_type_1_0(__args)))));
}
public:template<typename __xcodeml_template_type_1_0>typename __bind_return<typename decay<__xcodeml_template_type_0_0>::type const,tuple<...>,tuple<...>,expression>::type operator()(void/*__args*/)const{return(std::__1::(this->__f_,this->__bound_args_,__xcodeml_identity<typename __make_tuple_indices<expression,0>::type>::t(),__xcodeml_identity<tuple<...> >::t((std::__1::__xcodeml_template_type_1_0(__args)))));
}
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __is_bind_expression<__bind<__xcodeml_template_type_0_0,...> >:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __bind_r:public __bind<__xcodeml_template_type_0_1,...>{private:typedef __bind<__xcodeml_template_type_0_1,...>;
private:typedef typename __bind<__xcodeml_template_type_0_1,...>::_Fd _Fd;
private:typedef typename __bind<__xcodeml_template_type_0_1,...>::_Td _Td;
public:
public:typedef __xcodeml_template_type_0_0 result_type;
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1,typename __xcodeml_template_type_1_2>__bind_r(__xcodeml_template_type_1_0(*__f),void/*__bound_args*/):((std::__1::__xcodeml_template_type_1_0(__f))(std::__1::__xcodeml_template_type_1_1(__bound_args))){}
public:template<typename __xcodeml_template_type_1_0>typename enable_if<expression,__xcodeml_template_type_0_0>::type operator()(void/*__args*/){typedef __invoke_void_return_wrapper<__xcodeml_template_type_0_0>;
return(__invoke_void_return_wrapper<__xcodeml_template_type_0_0>::.__call(static_cast<__bind<__xcodeml_template_type_0_1,...> >((*this)),(std::__1::__xcodeml_template_type_1_0(__args))));
}
public:template<typename __xcodeml_template_type_1_0>typename enable_if<expression,__xcodeml_template_type_0_0>::type operator()(void/*__args*/)const{typedef __invoke_void_return_wrapper<__xcodeml_template_type_0_0>;
return(__invoke_void_return_wrapper<__xcodeml_template_type_0_0>::.__call(static_cast<__bind<__xcodeml_template_type_0_1,...> >((*this)),(std::__1::__xcodeml_template_type_1_0(__args))));
}
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>class __is_bind_expression<__bind_r<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,...> >:public integral_constant<bool,1>{}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__bind<__xcodeml_template_type_0_0,...>{typedef __bind<__xcodeml_template_type_0_0,...>;
return __xcodeml_identity<__bind<__xcodeml_template_type_0_0,...> >::t((std::__1::__xcodeml_template_type_0_0(__f)),(std::__1::__xcodeml_template_type_0_1(__bound_args)));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__bind_r<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,...>{typedef __bind_r<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,...>;
return __xcodeml_identity<__bind_r<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1,...> >::t((std::__1::__xcodeml_template_type_0_1(__f)),(std::__1::__xcodeml_template_type_0_2(__bound_args)));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>pair<__xcodeml_template_type_0_1,__xcodeml_template_type_0_1>{if((__first2,__last2)){return((__first1,__first1));};
while(true){{while(true){{if((__first1,__last1)){return((__last1,__last1));};
if((__pred((*__first1),(*__first2)))){break;};
(++__first1);
};};
__xcodeml_template_type_0_1 __m1=__first1;
__xcodeml_template_type_0_2 __m2=__first2;
while(true){{if(((++__m2),__last2)){return((__first1,__m1));};
if(((++__m1),__last1)){return((__last1,__last1));};
if((!(__pred((*__m1),(*__m2))))){{(++__first1);
break;
};};
};};
};};
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>pair<__xcodeml_template_type_0_1,__xcodeml_template_type_0_1>{typedef typename iterator_traits<__xcodeml_template_type_0_1>::difference_type _D1;
typedef typename iterator_traits<__xcodeml_template_type_0_2>::difference_type _D2;
typename iterator_traits<__xcodeml_template_type_0_2>::difference_type const __len2=(__last2,__first2);
if((__len2,0)){return((__first1,__first1));};
typename iterator_traits<__xcodeml_template_type_0_1>::difference_type const __len1=(__last1,__first1);
if((__len1,__len2)){return((__last1,__last1));};
__xcodeml_template_type_0_1 const __s=(__last1,(__len2,1));
while(true){{while(true){{if((__first1,__s)){return((__last1,__last1));};
if((__pred((*__first1),(*__first2)))){break;};
(++__first1);
};};
__xcodeml_template_type_0_1 __m1=__first1;
__xcodeml_template_type_0_2 __m2=__first2;
while(true){{if(((++__m2),__last2)){return((__first1,(__first1,__len2)));};
(++__m1);
if((!(__pred((*__m1),(*__m2))))){{(++__first1);
break;
};};
};};
};};
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void __libcpp_erase_if_container(__xcodeml_template_type_0_0&__c,__xcodeml_template_type_0_1 __pred){{typename __xcodeml_template_type_0_0::iterator __iter=(__c.begin());typename __xcodeml_template_type_0_0::iterator __last=(__c.end());for(;(__iter,__last);){{if((__pred((*__iter)))){(__iter=(__c.erase(__iter)));}else{(++__iter);};
};}};
}
}
}
namespace std{namespace __1{template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __equal_to{public:bool operator()(__xcodeml_template_type_0_0 const&__x,__xcodeml_template_type_0_0 const&__y)const{return(__x,__y);
}
public:bool operator()(__xcodeml_template_type_0_0 const&__x,__xcodeml_template_type_0_1 const&__y)const{return(__x,__y);
}
public:bool operator()(__xcodeml_template_type_0_1 const&__x,__xcodeml_template_type_0_0 const&__y)const{return(__x,__y);
}
public:bool operator()(__xcodeml_template_type_0_1 const&__x,__xcodeml_template_type_0_1 const&__y)const{return(__x,__y);
}
}
;
;
template<typename __xcodeml_template_type_0_0>class __equal_to<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0>{public:bool operator()(__xcodeml_template_type_0_0 const&__x,__xcodeml_template_type_0_0 const&__y)const{return(__x,__y);
}
}
;
template<typename __xcodeml_template_type_0_0>class __equal_to<__xcodeml_template_type_0_0 const,__xcodeml_template_type_0_0>{public:bool operator()(__xcodeml_template_type_0_0 const&__x,__xcodeml_template_type_0_0 const&__y)const{return(__x,__y);
}
}
;
template<typename __xcodeml_template_type_0_0>class __equal_to<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0 const>{public:bool operator()(__xcodeml_template_type_0_0 const&__x,__xcodeml_template_type_0_0 const&__y)const{return(__x,__y);
}
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __less{public:bool operator()(__xcodeml_template_type_0_0 const&__x,__xcodeml_template_type_0_0 const&__y)const{return(__x,__y);
}
public:bool operator()(__xcodeml_template_type_0_0 const&__x,__xcodeml_template_type_0_1 const&__y)const{return(__x,__y);
}
public:bool operator()(__xcodeml_template_type_0_1 const&__x,__xcodeml_template_type_0_0 const&__y)const{return(__x,__y);
}
public:bool operator()(__xcodeml_template_type_0_1 const&__x,__xcodeml_template_type_0_1 const&__y)const{return(__x,__y);
}
}
;
template<>class __less<unsigned long,unsigned long>{public:bool operator()(unsigned long const&__x,unsigned long const&__y)const{return(__x<__y);
}
}
template<>class __less template<>class __less template<>class __less template<>class __less template<>class __less template<>class __less template<>class __less template<>class __less template<>class __less template<>class __less template<>class __less template<>class __less template<>class __less template<>class __less;
template<typename __xcodeml_template_type_0_0>class __less<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0>{public:bool operator()(__xcodeml_template_type_0_0 const&__x,__xcodeml_template_type_0_0 const&__y)const{return(__x,__y);
}
}
;
template<typename __xcodeml_template_type_0_0>class __less<__xcodeml_template_type_0_0 const,__xcodeml_template_type_0_0>{public:bool operator()(__xcodeml_template_type_0_0 const&__x,__xcodeml_template_type_0_0 const&__y)const{return(__x,__y);
}
}
;
template<typename __xcodeml_template_type_0_0>class __less<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0 const>{public:bool operator()(__xcodeml_template_type_0_0 const&__x,__xcodeml_template_type_0_0 const&__y)const{return(__x,__y);
}
}
;
template<typename __xcodeml_template_type_0_0>class __invert{private:
private:__xcodeml_template_type_0_0 __p_;
public:
public:__invert(){}
public:__invert(__xcodeml_template_type_0_0 __p):__p_(__p){}
public:template<typename __xcodeml_template_type_1_0>bool operator()(__xcodeml_template_type_1_0 const&__x){return(!(this->__p_(__x)));
}
public:template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>bool operator()(__xcodeml_template_type_1_0 const&__x,__xcodeml_template_type_1_1 const&__y){return(this->__p_(__y,__x));
}
}
;
;
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,__xcodeml_template_type_0_0>::type __half_positive(__xcodeml_template_type_0_0 __value){return static_cast<__xcodeml_template_type_0_0>((static_cast<typename make_unsigned<__xcodeml_template_type_0_0>::type>(__value)/2));
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,__xcodeml_template_type_0_0>::type __half_positive(__xcodeml_template_type_0_0 __value){return(__value/2);
}
template<typename __xcodeml_template_type_0_0>class __comp_ref_type{public:typedef typename add_lvalue_reference<__xcodeml_template_type_0_0>::type type;
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool all_of(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __pred){{;for(;(__first,__last);(++__first)){if((!(__pred((*__first))))){return false;};}};
return true;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool any_of(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __pred){{;for(;(__first,__last);(++__first)){if((__pred((*__first)))){return true;};}};
return false;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool none_of(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __pred){{;for(;(__first,__last);(++__first)){if((__pred((*__first)))){return false;};}};
return true;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_1 for_each(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __f){{;for(;(__first,__last);(++__first)){(__f((*__first)));}};
return __f;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0 find(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 const&__value_){{;for(;(__first,__last);(++__first)){if(((*__first),__value_)){break;};}};
return __first;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0 find_if(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __pred){{;for(;(__first,__last);(++__first)){if((__pred((*__first)))){break;};}};
return __first;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0 find_if_not(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __pred){{;for(;(__first,__last);(++__first)){if((!(__pred((*__first))))){break;};}};
return __first;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__xcodeml_template_type_0_1 __find_end(__xcodeml_template_type_0_1 __first1,__xcodeml_template_type_0_1 __last1,__xcodeml_template_type_0_2 __first2,__xcodeml_template_type_0_2 __last2,__xcodeml_template_type_0_0 __pred,class::std::__1::forward_iterator_tag,class::std::__1::forward_iterator_tag){__xcodeml_template_type_0_1 __r=__last1;
if((__first2,__last2)){return __r;};
while(true){{while(true){{if((__first1,__last1)){return __r;};
if((__pred((*__first1),(*__first2)))){break;};
(++__first1);
};};
__xcodeml_template_type_0_1 __m1=__first1;
__xcodeml_template_type_0_2 __m2=__first2;
while(true){{if(((++__m2),__last2)){{(__r=__first1);
(++__first1);
break;
};};
if(((++__m1),__last1)){return __r;};
if((!(__pred((*__m1),(*__m2))))){{(++__first1);
break;
};};
};};
};};
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__xcodeml_template_type_0_1 __find_end(__xcodeml_template_type_0_1 __first1,__xcodeml_template_type_0_1 __last1,__xcodeml_template_type_0_2 __first2,__xcodeml_template_type_0_2 __last2,__xcodeml_template_type_0_0 __pred,class::std::__1::bidirectional_iterator_tag,class::std::__1::bidirectional_iterator_tag){if((__first2,__last2)){return __last1;};
__xcodeml_template_type_0_1 __l1=__last1;
__xcodeml_template_type_0_2 __l2=__last2;
(--__l2);
while(true){{while(true){{if((__first1,__l1)){return __last1;};
if((__pred((*(--__l1)),(*__l2)))){break;};
};};
__xcodeml_template_type_0_1 __m1=__l1;
__xcodeml_template_type_0_2 __m2=__l2;
while(true){{if((__m2,__first2)){return __m1;};
if((__m1,__first1)){return __last1;};
if((!(__pred((*(--__m1)),(*(--__m2)))))){{break;
};};
};};
};};
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__xcodeml_template_type_0_1 __find_end(__xcodeml_template_type_0_1 __first1,__xcodeml_template_type_0_1 __last1,__xcodeml_template_type_0_2 __first2,__xcodeml_template_type_0_2 __last2,__xcodeml_template_type_0_0 __pred,class::std::__1::random_access_iterator_tag,class::std::__1::random_access_iterator_tag){typename iterator_traits<__xcodeml_template_type_0_2>::difference_type __len2=(__last2,__first2);
if((__len2,0)){return __last1;};
typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __len1=(__last1,__first1);
if((__len1,__len2)){return __last1;};
__xcodeml_template_type_0_1 const __s=(__first1,(__len2,1));
__xcodeml_template_type_0_1 __l1=__last1;
__xcodeml_template_type_0_2 __l2=__last2;
(--__l2);
while(true){{while(true){{if((__s,__l1)){return __last1;};
if((__pred((*(--__l1)),(*__l2)))){break;};
};};
__xcodeml_template_type_0_1 __m1=__l1;
__xcodeml_template_type_0_2 __m2=__l2;
while(true){{if((__m2,__first2)){return __m1;};
if((!(__pred((*(--__m1)),(*(--__m2)))))){{break;
};};
};};
};};
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__xcodeml_template_type_0_0 find_end(__xcodeml_template_type_0_0 __first1,__xcodeml_template_type_0_0 __last1,__xcodeml_template_type_0_1 __first2,__xcodeml_template_type_0_1 __last2,__xcodeml_template_type_0_2 __pred){return(std::__1::typename add_lvalue_reference<__xcodeml_template_type_0_2>::type(__first1,__last1,__first2,__last2,__pred,__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_0>::iterator_category>::t(),__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_1>::iterator_category>::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0 find_end(__xcodeml_template_type_0_0 __first1,__xcodeml_template_type_0_0 __last1,__xcodeml_template_type_0_1 __first2,__xcodeml_template_type_0_1 __last2){typedef typename iterator_traits<__xcodeml_template_type_0_0>::value_type __v1;
typedef typename iterator_traits<__xcodeml_template_type_0_1>::value_type __v2;
return(std::__1::(__first1,__last1,__first2,__last2,__xcodeml_identity<__equal_to<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_1>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__xcodeml_template_type_0_0 __find_first_of_ce(__xcodeml_template_type_0_0 __first1,__xcodeml_template_type_0_0 __last1,__xcodeml_template_type_0_1 __first2,__xcodeml_template_type_0_1 __last2,__xcodeml_template_type_0_2 __pred){{;for(;(__first1,__last1);(++__first1)){{__xcodeml_template_type_0_1 __j=__first2;for(;(__j,__last2);(++__j)){if((__pred((*__first1),(*__j)))){return __first1;};}};}};
return __last1;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__xcodeml_template_type_0_0 find_first_of(__xcodeml_template_type_0_0 __first1,__xcodeml_template_type_0_0 __last1,__xcodeml_template_type_0_1 __first2,__xcodeml_template_type_0_1 __last2,__xcodeml_template_type_0_2 __pred){return(std::__1::(__first1,__last1,__first2,__last2,__pred));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0 find_first_of(__xcodeml_template_type_0_0 __first1,__xcodeml_template_type_0_0 __last1,__xcodeml_template_type_0_1 __first2,__xcodeml_template_type_0_1 __last2){typedef typename iterator_traits<__xcodeml_template_type_0_0>::value_type __v1;
typedef typename iterator_traits<__xcodeml_template_type_0_1>::value_type __v2;
return(std::__1::(__first1,__last1,__first2,__last2,__xcodeml_identity<__equal_to<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_1>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0 adjacent_find(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __pred){if((__first,__last)){{__xcodeml_template_type_0_0 __i=__first;
while(((++__i),__last)){{if((__pred((*__first),(*__i)))){return __first;};
(__first=__i);
};};
};};
return __last;
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 adjacent_find(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last){typedef typename iterator_traits<__xcodeml_template_type_0_0>::value_type __v;
return(std::__1::(__first,__last,__xcodeml_identity<__equal_to<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_0>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename iterator_traits<__xcodeml_template_type_0_0>::difference_type count(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 const&__value_){typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __r=0;
{;for(;(__first,__last);(++__first)){if(((*__first),__value_)){(++__r);};}};
return __r;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename iterator_traits<__xcodeml_template_type_0_0>::difference_type count_if(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __pred){typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __r=0;
{;for(;(__first,__last);(++__first)){if((__pred((*__first)))){(++__r);};}};
return __r;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>{{;for(;(__first1,__last1);((++__first1),((void)(++__first2)))){if((!(__pred((*__first1),(*__first2))))){break;};}};
return __xcodeml_identity<pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1> >::t(__first1,__first2);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>{typedef typename iterator_traits<__xcodeml_template_type_0_0>::value_type __v1;
typedef typename iterator_traits<__xcodeml_template_type_0_1>::value_type __v2;
return(std::__1::(__first1,__last1,__first2,__xcodeml_identity<__equal_to<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_1>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>{{;for(;((__first1,__last1)&&(__first2,__last2));((++__first1),((void)(++__first2)))){if((!(__pred((*__first1),(*__first2))))){break;};}};
return __xcodeml_identity<pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1> >::t(__first1,__first2);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>{typedef typename iterator_traits<__xcodeml_template_type_0_0>::value_type __v1;
typedef typename iterator_traits<__xcodeml_template_type_0_1>::value_type __v2;
return(std::__1::(__first1,__last1,__first2,__last2,__xcodeml_identity<__equal_to<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_1>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>bool equal(__xcodeml_template_type_0_0 __first1,__xcodeml_template_type_0_0 __last1,__xcodeml_template_type_0_1 __first2,__xcodeml_template_type_0_2 __pred){{;for(;(__first1,__last1);((++__first1),((void)(++__first2)))){if((!(__pred((*__first1),(*__first2))))){return false;};}};
return true;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool equal(__xcodeml_template_type_0_0 __first1,__xcodeml_template_type_0_0 __last1,__xcodeml_template_type_0_1 __first2){typedef typename iterator_traits<__xcodeml_template_type_0_0>::value_type __v1;
typedef typename iterator_traits<__xcodeml_template_type_0_1>::value_type __v2;
return(std::__1::(__first1,__last1,__first2,__xcodeml_identity<__equal_to<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_1>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>bool __equal(__xcodeml_template_type_0_1 __first1,__xcodeml_template_type_0_1 __last1,__xcodeml_template_type_0_2 __first2,__xcodeml_template_type_0_2 __last2,__xcodeml_template_type_0_0 __pred,class::std::__1::input_iterator_tag,class::std::__1::input_iterator_tag){{;for(;((__first1,__last1)&&(__first2,__last2));((++__first1),((void)(++__first2)))){if((!(__pred((*__first1),(*__first2))))){return false;};}};
return((__first1,__last1)&&(__first2,__last2));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>bool __equal(__xcodeml_template_type_0_1 __first1,__xcodeml_template_type_0_1 __last1,__xcodeml_template_type_0_2 __first2,__xcodeml_template_type_0_2 __last2,__xcodeml_template_type_0_0 __pred,class::std::__1::random_access_iterator_tag,class::std::__1::random_access_iterator_tag){if(((std::__1::(__first1,__last1)),(std::__1::(__first2,__last2)))){return false;};
return(std::__1::__xcodeml_template_type_0_1 __xcodeml_template_type_0_2 typename add_lvalue_reference<__xcodeml_template_type_0_0>::type(__first1,__last1,__first2,__pred));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>bool equal(__xcodeml_template_type_0_0 __first1,__xcodeml_template_type_0_0 __last1,__xcodeml_template_type_0_1 __first2,__xcodeml_template_type_0_1 __last2,__xcodeml_template_type_0_2 __pred){return(std::__1::typename add_lvalue_reference<__xcodeml_template_type_0_2>::type(__first1,__last1,__first2,__last2,__pred,__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_0>::iterator_category>::t(),__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_1>::iterator_category>::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool equal(__xcodeml_template_type_0_0 __first1,__xcodeml_template_type_0_0 __last1,__xcodeml_template_type_0_1 __first2,__xcodeml_template_type_0_1 __last2){typedef typename iterator_traits<__xcodeml_template_type_0_0>::value_type __v1;
typedef typename iterator_traits<__xcodeml_template_type_0_1>::value_type __v2;
return(std::__1::(__first1,__last1,__first2,__last2,__xcodeml_identity<__equal_to<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_1>::value_type> >::t(),__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_0>::iterator_category>::t(),__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_1>::iterator_category>::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>bool is_permutation(__xcodeml_template_type_0_0 __first1,__xcodeml_template_type_0_0 __last1,__xcodeml_template_type_0_1 __first2,__xcodeml_template_type_0_2 __pred){{;for(;(__first1,__last1);((++__first1),((void)(++__first2)))){if((!(__pred((*__first1),(*__first2))))){break;};}};
if((__first1,__last1)){return true;};
typedef typename iterator_traits<__xcodeml_template_type_0_0>::difference_type _D1;
typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __l1=(std::__1::(__first1,__last1));
if((__l1,__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_0>::difference_type>::t(1))){return false;};
__xcodeml_template_type_0_1 __last2=(std::__1::(__first2,__l1));
{__xcodeml_template_type_0_0 __i=__first1;for(;(__i,__last1);(++__i)){{__xcodeml_template_type_0_0 __match=__first1;
{;for(;(__match,__i);(++__match)){if((__pred((*__match),(*__i)))){break;};}};
if((__match,__i)){{typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __c2=0;
{__xcodeml_template_type_0_1 __j=__first2;for(;(__j,__last2);(++__j)){if((__pred((*__i),(*__j)))){(++__c2);};}};
if((__c2,0)){return false;};
typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __c1=1;
{__xcodeml_template_type_0_0 __j=(std::__1::(__i));for(;(__j,__last1);(++__j)){if((__pred((*__i),(*__j)))){(++__c1);};}};
if((__c1,__c2)){return false;};
};};
};}};
return true;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool is_permutation(__xcodeml_template_type_0_0 __first1,__xcodeml_template_type_0_0 __last1,__xcodeml_template_type_0_1 __first2){typedef typename iterator_traits<__xcodeml_template_type_0_0>::value_type __v1;
typedef typename iterator_traits<__xcodeml_template_type_0_1>::value_type __v2;
return(std::__1::(__first1,__last1,__first2,__xcodeml_identity<__equal_to<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_1>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>bool __is_permutation(__xcodeml_template_type_0_1 __first1,__xcodeml_template_type_0_1 __last1,__xcodeml_template_type_0_2 __first2,__xcodeml_template_type_0_2 __last2,__xcodeml_template_type_0_0 __pred,class::std::__1::forward_iterator_tag,class::std::__1::forward_iterator_tag){{;for(;((__first1,__last1)&&(__first2,__last2));((++__first1),((void)(++__first2)))){if((!(__pred((*__first1),(*__first2))))){break;};}};
if((__first1,__last1)){return(__first2,__last2);}else{if((__first2,__last2)){return false;};};
typedef typename iterator_traits<__xcodeml_template_type_0_1>::difference_type _D1;
typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __l1=(std::__1::(__first1,__last1));
typedef typename iterator_traits<__xcodeml_template_type_0_2>::difference_type _D2;
typename iterator_traits<__xcodeml_template_type_0_2>::difference_type __l2=(std::__1::(__first2,__last2));
if((__l1,__l2)){return false;};
{__xcodeml_template_type_0_1 __i=__first1;for(;(__i,__last1);(++__i)){{__xcodeml_template_type_0_1 __match=__first1;
{;for(;(__match,__i);(++__match)){if((__pred((*__match),(*__i)))){break;};}};
if((__match,__i)){{typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __c2=0;
{__xcodeml_template_type_0_2 __j=__first2;for(;(__j,__last2);(++__j)){if((__pred((*__i),(*__j)))){(++__c2);};}};
if((__c2,0)){return false;};
typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __c1=1;
{__xcodeml_template_type_0_1 __j=(std::__1::(__i));for(;(__j,__last1);(++__j)){if((__pred((*__i),(*__j)))){(++__c1);};}};
if((__c1,__c2)){return false;};
};};
};}};
return true;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>bool __is_permutation(__xcodeml_template_type_0_1 __first1,__xcodeml_template_type_0_2 __last1,__xcodeml_template_type_0_1 __first2,__xcodeml_template_type_0_2 __last2,__xcodeml_template_type_0_0 __pred,class::std::__1::random_access_iterator_tag,class::std::__1::random_access_iterator_tag){if(((std::__1::(__first1,__last1)),(std::__1::(__first2,__last2)))){return false;};
return(std::__1::__xcodeml_template_type_0_1 __xcodeml_template_type_0_2 typename add_lvalue_reference<__xcodeml_template_type_0_0>::type(__first1,__last1,__first2,__pred));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>bool is_permutation(__xcodeml_template_type_0_0 __first1,__xcodeml_template_type_0_0 __last1,__xcodeml_template_type_0_1 __first2,__xcodeml_template_type_0_1 __last2,__xcodeml_template_type_0_2 __pred){return(std::__1::typename add_lvalue_reference<__xcodeml_template_type_0_2>::type(__first1,__last1,__first2,__last2,__pred,__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_0>::iterator_category>::t(),__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_1>::iterator_category>::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool is_permutation(__xcodeml_template_type_0_0 __first1,__xcodeml_template_type_0_0 __last1,__xcodeml_template_type_0_1 __first2,__xcodeml_template_type_0_1 __last2){typedef typename iterator_traits<__xcodeml_template_type_0_0>::value_type __v1;
typedef typename iterator_traits<__xcodeml_template_type_0_1>::value_type __v2;
return(std::__1::(__first1,__last1,__first2,__last2,__xcodeml_identity<__equal_to<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_1>::value_type> >::t(),__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_0>::iterator_category>::t(),__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_1>::iterator_category>::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__xcodeml_template_type_0_0 search(__xcodeml_template_type_0_0 __first1,__xcodeml_template_type_0_0 __last1,__xcodeml_template_type_0_1 __first2,__xcodeml_template_type_0_1 __last2,__xcodeml_template_type_0_2 __pred){return(std::__1::typename add_lvalue_reference<__xcodeml_template_type_0_2>::type(__first1,__last1,__first2,__last2,__pred,__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_0>::iterator_category>::t(),__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_1>::iterator_category>::t())).first;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0 search(__xcodeml_template_type_0_0 __first1,__xcodeml_template_type_0_0 __last1,__xcodeml_template_type_0_1 __first2,__xcodeml_template_type_0_1 __last2){typedef typename iterator_traits<__xcodeml_template_type_0_0>::value_type __v1;
typedef typename iterator_traits<__xcodeml_template_type_0_1>::value_type __v2;
return(std::__1::(__first1,__last1,__first2,__last2,__xcodeml_identity<__equal_to<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_1>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>__xcodeml_template_type_0_1 __search_n(__xcodeml_template_type_0_1 __first,__xcodeml_template_type_0_1 __last,__xcodeml_template_type_0_2 __count,__xcodeml_template_type_0_3 const&__value_,__xcodeml_template_type_0_0 __pred,class::std::__1::forward_iterator_tag){if((__count,0)){return __first;};
while(true){{while(true){{if((__first,__last)){return __last;};
if((__pred((*__first),__value_))){break;};
(++__first);
};};
__xcodeml_template_type_0_1 __m=__first;
__xcodeml_template_type_0_2 __c=0;
while(true){{if(((++__c),__count)){return __first;};
if(((++__m),__last)){return __last;};
if((!(__pred((*__m),__value_)))){{(__first=__m);
(++__first);
break;
};};
};};
};};
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>__xcodeml_template_type_0_1 __search_n(__xcodeml_template_type_0_1 __first,__xcodeml_template_type_0_1 __last,__xcodeml_template_type_0_2 __count,__xcodeml_template_type_0_3 const&__value_,__xcodeml_template_type_0_0 __pred,class::std::__1::random_access_iterator_tag){if((__count,0)){return __first;};
__xcodeml_template_type_0_2 __len=static_cast<__xcodeml_template_type_0_2>((__last,__first));
if((__len,__count)){return __last;};
__xcodeml_template_type_0_1 const __s=(__last,(__count,1));
while(true){{while(true){{if((__first,__s)){return __last;};
if((__pred((*__first),__value_))){break;};
(++__first);
};};
__xcodeml_template_type_0_1 __m=__first;
__xcodeml_template_type_0_2 __c=0;
while(true){{if(((++__c),__count)){return __first;};
(++__m);
if((!(__pred((*__m),__value_)))){{(__first=__m);
(++__first);
break;
};};
};};
};};
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>__xcodeml_template_type_0_0 search_n(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __count,__xcodeml_template_type_0_2 const&__value_,__xcodeml_template_type_0_3 __pred){return(std::__1::typename add_lvalue_reference<__xcodeml_template_type_0_3>::type(__first,__last,((__count)),__value_,__pred,__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_0>::iterator_category>::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__xcodeml_template_type_0_0 search_n(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __count,__xcodeml_template_type_0_2 const&__value_){typedef typename iterator_traits<__xcodeml_template_type_0_0>::value_type __v;
return(std::__1::(__first,__last,((__count)),__value_,__xcodeml_identity<__equal_to<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,__xcodeml_template_type_0_2> >::t()));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 __unwrap_iter(__xcodeml_template_type_0_0 __i){return __i;
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,__xcodeml_template_type_0_0(*)>::type __unwrap_iter(move_iterator<__xcodeml_template_type_0_0(*)>){return(__i.base());
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,__xcodeml_template_type_0_0(*)>::type __unwrap_iter(__wrap_iter<__xcodeml_template_type_0_0(*)>){return(__i.base());
}
template<typename __xcodeml_template_type_0_0>typename enable_if<expression,__xcodeml_template_type_0_0 const(*)>::type __unwrap_iter(__wrap_iter<__xcodeml_template_type_0_0 const(*)>){return(__i.base());
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_1 __copy(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __result){{;for(;(__first,__last);((++__first),((void)(++__result)))){((*__result)=(*__first));}};
return __result;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename enable_if<expression,__xcodeml_template_type_0_1(*)>::type __copy(__xcodeml_template_type_0_0(*__first),__xcodeml_template_type_0_0(*__last),__xcodeml_template_type_0_1(*__result)){unsigned long const __n=static_cast<unsigned long>((__last,__first));
if((__n>0)){(std::__1::memmove(__result,__first,(__n*(sizeof(__xcodeml_template_type_0_1)))));};
return(__result,__n);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_1 copy(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __result){return(std::__1::(((__first)),((__last)),((__result))));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_1 __copy_backward(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __result){while((__first,__last)){((*(--__result))=(*(--__last)));};
return __result;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename enable_if<expression,__xcodeml_template_type_0_1(*)>::type __copy_backward(__xcodeml_template_type_0_0(*__first),__xcodeml_template_type_0_0(*__last),__xcodeml_template_type_0_1(*__result)){unsigned long const __n=static_cast<unsigned long>((__last,__first));
if((__n>0)){{(__result-=__n);
(std::__1::memmove(__result,__first,(__n*(sizeof(__xcodeml_template_type_0_1)))));
};};
return __result;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_1 copy_backward(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __result){return(std::__1::(((__first)),((__last)),((__result))));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__xcodeml_template_type_0_1 copy_if(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __result,__xcodeml_template_type_0_2 __pred){{;for(;(__first,__last);(++__first)){{if((__pred((*__first)))){{((*__result)=(*__first));
(++__result);
};};
};}};
return __result;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>typename enable_if<expression,__xcodeml_template_type_0_2>::type copy_n(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_1 __orig_n,__xcodeml_template_type_0_2 __result){typedef decltype (_IntegralSize);
decltype (__n)=__orig_n;
if((__n,0)){{((*__result)=(*__first));
(++__result);
{(--__n);for(;(__n,0);(--__n)){{(++__first);
((*__result)=(*__first));
(++__result);
};}};
};};
return __result;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>typename enable_if<expression,__xcodeml_template_type_0_2>::type copy_n(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_1 __orig_n,__xcodeml_template_type_0_2 __result){typedef decltype (_IntegralSize);
decltype (__n)=__orig_n;
return(std::__1::(__first,(__first,__n),__result));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_1 __move(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __result){{;for(;(__first,__last);((++__first),((void)(++__result)))){((*__result)=(std::__1::((*__first))));}};
return __result;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename enable_if<expression,__xcodeml_template_type_0_1(*)>::type __move(__xcodeml_template_type_0_0(*__first),__xcodeml_template_type_0_0(*__last),__xcodeml_template_type_0_1(*__result)){unsigned long const __n=static_cast<unsigned long>((__last,__first));
if((__n>0)){(std::__1::memmove(__result,__first,(__n*(sizeof(__xcodeml_template_type_0_1)))));};
return(__result,__n);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_1 move(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __result){return(std::__1::(((__first)),((__last)),((__result))));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_1 __move_backward(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __result){while((__first,__last)){((*(--__result))=(std::__1::((*(--__last)))));};
return __result;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>typename enable_if<expression,__xcodeml_template_type_0_1(*)>::type __move_backward(__xcodeml_template_type_0_0(*__first),__xcodeml_template_type_0_0(*__last),__xcodeml_template_type_0_1(*__result)){unsigned long const __n=static_cast<unsigned long>((__last,__first));
if((__n>0)){{(__result-=__n);
(std::__1::memmove(__result,__first,(__n*(sizeof(__xcodeml_template_type_0_1)))));
};};
return __result;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_1 move_backward(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __result){return(std::__1::(((__first)),((__last)),((__result))));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__xcodeml_template_type_0_1 transform(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __result,__xcodeml_template_type_0_2 __op){{;for(;(__first,__last);((++__first),((void)(++__result)))){((*__result)=(__op((*__first))));}};
return __result;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>__xcodeml_template_type_0_2 transform(__xcodeml_template_type_0_0 __first1,__xcodeml_template_type_0_0 __last1,__xcodeml_template_type_0_1 __first2,__xcodeml_template_type_0_2 __result,__xcodeml_template_type_0_3 __binary_op){{;for(;(__first1,__last1);(((++__first1),((void)(++__first2))),(++__result))){((*__result)=(__binary_op((*__first1),(*__first2))));}};
return __result;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void replace(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 const&__old_value,__xcodeml_template_type_0_1 const&__new_value){{;for(;(__first,__last);(++__first)){if(((*__first),__old_value)){((*__first)=__new_value);};}};
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>void replace_if(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __pred,__xcodeml_template_type_0_2 const&__new_value){{;for(;(__first,__last);(++__first)){if((__pred((*__first)))){((*__first)=__new_value);};}};
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__xcodeml_template_type_0_1 replace_copy(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __result,__xcodeml_template_type_0_2 const&__old_value,__xcodeml_template_type_0_2 const&__new_value){{;for(;(__first,__last);((++__first),((void)(++__result)))){if(((*__first),__old_value)){((*__result)=__new_value);}else{((*__result)=(*__first));};}};
return __result;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>__xcodeml_template_type_0_1 replace_copy_if(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __result,__xcodeml_template_type_0_2 __pred,__xcodeml_template_type_0_3 const&__new_value){{;for(;(__first,__last);((++__first),((void)(++__result)))){if((__pred((*__first)))){((*__result)=__new_value);}else{((*__result)=(*__first));};}};
return __result;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__xcodeml_template_type_0_0 __fill_n(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_1 __n,__xcodeml_template_type_0_2 const&__value_){{;for(;(__n,0);((++__first),((void)(--__n)))){((*__first)=__value_);}};
return __first;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__xcodeml_template_type_0_0 fill_n(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_1 __n,__xcodeml_template_type_0_2 const&__value_){return(std::__1::(__first,((__n)),__value_));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void __fill(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 const&__value_,class::std::__1::forward_iterator_tag){{;for(;(__first,__last);(++__first)){((*__first)=__value_);}};
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void __fill(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 const&__value_,class::std::__1::random_access_iterator_tag){(std::__1::(__first,(__last,__first),__value_));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void fill(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 const&__value_){(std::__1::(__first,__last,__value_,__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_0>::iterator_category>::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void generate(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __gen){{;for(;(__first,__last);(++__first)){((*__first)=(__gen()));}};
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__xcodeml_template_type_0_0 generate_n(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_1 __orig_n,__xcodeml_template_type_0_2 __gen){typedef decltype (_IntegralSize);
decltype (__n)=__orig_n;
{;for(;(__n,0);((++__first),((void)(--__n)))){((*__first)=(__gen()));}};
return __first;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0 remove(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 const&__value_){(__first=(std::__1::(__first,__last,__value_)));
if((__first,__last)){{__xcodeml_template_type_0_0 __i=__first;
while(((++__i),__last)){{if((!((*__i),__value_))){{((*__first)=(std::__1::((*__i))));
(++__first);
};};
};};
};};
return __first;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0 remove_if(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __pred){(__first=(std::__1::__xcodeml_template_type_0_0 typename add_lvalue_reference<__xcodeml_template_type_0_1>::type(__first,__last,__pred)));
if((__first,__last)){{__xcodeml_template_type_0_0 __i=__first;
while(((++__i),__last)){{if((!(__pred((*__i))))){{((*__first)=(std::__1::((*__i))));
(++__first);
};};
};};
};};
return __first;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__xcodeml_template_type_0_1 remove_copy(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __result,__xcodeml_template_type_0_2 const&__value_){{;for(;(__first,__last);(++__first)){{if((!((*__first),__value_))){{((*__result)=(*__first));
(++__result);
};};
};}};
return __result;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__xcodeml_template_type_0_1 remove_copy_if(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __result,__xcodeml_template_type_0_2 __pred){{;for(;(__first,__last);(++__first)){{if((!(__pred((*__first))))){{((*__result)=(*__first));
(++__result);
};};
};}};
return __result;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0 unique(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __pred){(__first=(std::__1::__xcodeml_template_type_0_0 typename add_lvalue_reference<__xcodeml_template_type_0_1>::type(__first,__last,__pred)));
if((__first,__last)){{__xcodeml_template_type_0_0 __i=__first;
{(++__i);for(;((++__i),__last);){if((!(__pred((*__first),(*__i))))){((*(++__first))=(std::__1::((*__i))));};}};
(++__first);
};};
return __first;
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 unique(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last){typedef typename iterator_traits<__xcodeml_template_type_0_0>::value_type __v;
return(std::__1::(__first,__last,__xcodeml_identity<__equal_to<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_0>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__xcodeml_template_type_0_2 __unique_copy(__xcodeml_template_type_0_1 __first,__xcodeml_template_type_0_1 __last,__xcodeml_template_type_0_2 __result,__xcodeml_template_type_0_0 __pred,class::std::__1::input_iterator_tag,class::std::__1::output_iterator_tag){if((__first,__last)){{typename iterator_traits<__xcodeml_template_type_0_1>::value_type __t=(*__first);
((*__result)=__t);
(++__result);
while(((++__first),__last)){{if((!(__pred(__t,(*__first))))){{(__t=(*__first));
((*__result)=__t);
(++__result);
};};
};};
};};
return __result;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__xcodeml_template_type_0_2 __unique_copy(__xcodeml_template_type_0_1 __first,__xcodeml_template_type_0_1 __last,__xcodeml_template_type_0_2 __result,__xcodeml_template_type_0_0 __pred,class::std::__1::forward_iterator_tag,class::std::__1::output_iterator_tag){if((__first,__last)){{__xcodeml_template_type_0_1 __i=__first;
((*__result)=(*__i));
(++__result);
while(((++__first),__last)){{if((!(__pred((*__i),(*__first))))){{((*__result)=(*__first));
(++__result);
(__i=__first);
};};
};};
};};
return __result;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__xcodeml_template_type_0_2 __unique_copy(__xcodeml_template_type_0_1 __first,__xcodeml_template_type_0_1 __last,__xcodeml_template_type_0_2 __result,__xcodeml_template_type_0_0 __pred,class::std::__1::input_iterator_tag,class::std::__1::forward_iterator_tag){if((__first,__last)){{((*__result)=(*__first));
while(((++__first),__last)){if((!(__pred((*__result),(*__first))))){((*(++__result))=(*__first));};};
(++__result);
};};
return __result;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__xcodeml_template_type_0_1 unique_copy(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __result,__xcodeml_template_type_0_2 __pred){return(std::__1::typename add_lvalue_reference<__xcodeml_template_type_0_2>::type(__first,__last,__result,__pred,__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_0>::iterator_category>::t(),__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_1>::iterator_category>::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_1 unique_copy(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __result){typedef typename iterator_traits<__xcodeml_template_type_0_0>::value_type __v;
return(std::__1::(__first,__last,__result,__xcodeml_identity<__equal_to<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_0>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0>void __reverse(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,class::std::__1::bidirectional_iterator_tag){while((__first,__last)){{if((__first,(--__last))){break;};
(std::__1::(__first,__last));
(++__first);
};};
}
template<typename __xcodeml_template_type_0_0>void __reverse(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,class::std::__1::random_access_iterator_tag){if((__first,__last)){{;for(;(__first,(--__last));(++__first)){(std::__1::(__first,__last));}};};
}
template<typename __xcodeml_template_type_0_0>void reverse(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last){(std::__1::(__first,__last,__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_0>::iterator_category>::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_1 reverse_copy(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __result){{;for(;(__first,__last);(++__result)){((*__result)=(*(--__last)));}};
return __result;
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 __rotate_left(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last){typedef typename iterator_traits<__xcodeml_template_type_0_0>::value_type value_type;
typename iterator_traits<__xcodeml_template_type_0_0>::value_type __tmp=(std::__1::((*__first)));
__xcodeml_template_type_0_0 __lm1=(std::__1::((std::__1::(__first)),__last,__first));
((*__lm1)=(std::__1::(__tmp)));
return __lm1;
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 __rotate_right(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last){typedef typename iterator_traits<__xcodeml_template_type_0_0>::value_type value_type;
__xcodeml_template_type_0_0 __lm1=(std::__1::(__last));
typename iterator_traits<__xcodeml_template_type_0_0>::value_type __tmp=(std::__1::((*__lm1)));
__xcodeml_template_type_0_0 __fp1=(std::__1::(__first,__lm1,__last));
((*__first)=(std::__1::(__tmp)));
return __fp1;
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 __rotate_forward(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __middle,__xcodeml_template_type_0_0 __last){__xcodeml_template_type_0_0 __i=__middle;
while(true){{(((*__first),(*__i)));
(++__first);
if(((++__i),__last)){break;};
if((__first,__middle)){(__middle=__i);};
};};
__xcodeml_template_type_0_0 __r=__first;
if((__first,__middle)){{(__i=__middle);
while(true){{(((*__first),(*__i)));
(++__first);
if(((++__i),__last)){{if((__first,__middle)){break;};
(__i=__middle);
};}else{if((__first,__middle)){(__middle=__i);};};
};};
};};
return __r;
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 __algo_gcd(__xcodeml_template_type_0_0 __x,__xcodeml_template_type_0_0 __y){do{{__xcodeml_template_type_0_0 __t=(__x%__y);
(__x=__y);
(__y=__t);
};}while(__y);
return __x;
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 __rotate_gcd(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __middle,__xcodeml_template_type_0_0 __last){typedef typename iterator_traits<__xcodeml_template_type_0_0>::difference_type difference_type;
typedef typename iterator_traits<__xcodeml_template_type_0_0>::value_type value_type;
typename iterator_traits<__xcodeml_template_type_0_0>::difference_type const __m1=(__middle,__first);
typename iterator_traits<__xcodeml_template_type_0_0>::difference_type const __m2=(__last,__middle);
if((__m1,__m2)){{(std::__1::(__first,__middle,__middle));
return __middle;
};};
typename iterator_traits<__xcodeml_template_type_0_0>::difference_type const __g=(std::__1::(__m1,__m2));
{__xcodeml_template_type_0_0 __p=(__first,__g);for(;(__p,__first);){{typename iterator_traits<__xcodeml_template_type_0_0>::value_type __t=(std::__1::((*(--__p))));
__xcodeml_template_type_0_0 __p1=__p;
__xcodeml_template_type_0_0 __p2=(__p1,__m1);
do{{((*__p1)=(std::__1::((*__p2))));
(__p1=__p2);
typename iterator_traits<__xcodeml_template_type_0_0>::difference_type const __d=(__last,__p2);
if((__m1,__d)){(__p2+=__m1);}else{(__p2=(__first,(__m1,__d)));};
};}while((__p2,__p));
((*__p1)=(std::__1::(__t)));
};}};
return(__first,__m2);
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 __rotate(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __middle,__xcodeml_template_type_0_0 __last,class::std::__1::forward_iterator_tag){typedef typename iterator_traits<__xcodeml_template_type_0_0>::value_type value_type;
if(std::__1::is_trivially_move_assignable<typename iterator_traits<__xcodeml_template_type_0_0>::value_type>::value){{if(((std::__1::(__first)),__middle)){return(std::__1::(__first,__last));};
};};
return(std::__1::(__first,__middle,__last));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 __rotate(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __middle,__xcodeml_template_type_0_0 __last,class::std::__1::bidirectional_iterator_tag){typedef typename iterator_traits<__xcodeml_template_type_0_0>::value_type value_type;
if(std::__1::is_trivially_move_assignable<typename iterator_traits<__xcodeml_template_type_0_0>::value_type>::value){{if(((std::__1::(__first)),__middle)){return(std::__1::(__first,__last));};
if(((std::__1::(__middle)),__last)){return(std::__1::(__first,__last));};
};};
return(std::__1::(__first,__middle,__last));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 __rotate(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __middle,__xcodeml_template_type_0_0 __last,class::std::__1::random_access_iterator_tag){typedef typename iterator_traits<__xcodeml_template_type_0_0>::value_type value_type;
if(std::__1::is_trivially_move_assignable<typename iterator_traits<__xcodeml_template_type_0_0>::value_type>::value){{if(((std::__1::(__first)),__middle)){return(std::__1::(__first,__last));};
if(((std::__1::(__middle)),__last)){return(std::__1::(__first,__last));};
return(std::__1::(__first,__middle,__last));
};};
return(std::__1::(__first,__middle,__last));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 rotate(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __middle,__xcodeml_template_type_0_0 __last){if((__first,__middle)){return __last;};
if((__middle,__last)){return __first;};
return(std::__1::(__first,__middle,__last,__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_0>::iterator_category>::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_1 rotate_copy(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __middle,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __result){return(std::__1::(__first,__middle,(std::__1::(__middle,__last,__result))));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0 min_element(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __comp){__is_forward_iterator<__xcodeml_template_type_0_0>::value"std::min_element requires a ForwardIterator";
if((__first,__last)){{__xcodeml_template_type_0_0 __i=__first;
while(((++__i),__last)){if((__comp((*__i),(*__first)))){(__first=__i);};};
};};
return __first;
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 min_element(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last){return(std::__1::(__first,__last,__xcodeml_identity<__less<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_0>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0 const&min(__xcodeml_template_type_0_0 const&__a,__xcodeml_template_type_0_0 const&__b,__xcodeml_template_type_0_1 __comp){return((__comp(__b,__a))?__b:__a);
}
template <>unsigned long const&min(unsigned long const&__a,unsigned long const&__b,class::std::__1::__less<unsigned long,unsigned long>__comp){return(__comp.operator()(__b,__a)?__b:__a);
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 const&min(__xcodeml_template_type_0_0 const&__a,__xcodeml_template_type_0_0 const&__b){return(std::__1::(__a,__b,__xcodeml_identity<__less<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0> >::t()));
}
template <>unsigned long const&min(unsigned long const&__a,unsigned long const&__b){return(std::__1::min(__a,__b,__xcodeml_identity<class::std::__1::__less<unsigned long,unsigned long> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0 min(initializer_list<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_1 __comp){return(*(std::__1::((__t.begin()),(__t.end()),__comp)));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 min(initializer_list<__xcodeml_template_type_0_0>){return(*(std::__1::((__t.begin()),(__t.end()),__xcodeml_identity<__less<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0> >::t())));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0 max_element(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __comp){__is_forward_iterator<__xcodeml_template_type_0_0>::value"std::max_element requires a ForwardIterator";
if((__first,__last)){{__xcodeml_template_type_0_0 __i=__first;
while(((++__i),__last)){if((__comp((*__first),(*__i)))){(__first=__i);};};
};};
return __first;
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 max_element(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last){return(std::__1::(__first,__last,__xcodeml_identity<__less<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_0>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0 const&max(__xcodeml_template_type_0_0 const&__a,__xcodeml_template_type_0_0 const&__b,__xcodeml_template_type_0_1 __comp){return((__comp(__a,__b))?__b:__a);
}
template <>unsigned long const&max(unsigned long const&__a,unsigned long const&__b,class::std::__1::__less<unsigned long,unsigned long>__comp){return(__comp.operator()(__a,__b)?__b:__a);
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 const&max(__xcodeml_template_type_0_0 const&__a,__xcodeml_template_type_0_0 const&__b){return(std::__1::(__a,__b,__xcodeml_identity<__less<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0> >::t()));
}
template <>unsigned long const&max(unsigned long const&__a,unsigned long const&__b){return(std::__1::max(__a,__b,__xcodeml_identity<class::std::__1::__less<unsigned long,unsigned long> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0 max(initializer_list<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_1 __comp){return(*(std::__1::((__t.begin()),(__t.end()),__comp)));
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 max(initializer_list<__xcodeml_template_type_0_0>){return(*(std::__1::((__t.begin()),(__t.end()),__xcodeml_identity<__less<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0> >::t())));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0>{__is_forward_iterator<__xcodeml_template_type_0_0>::value"std::minmax_element requires a ForwardIterator";
pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0> =__first __first;
if((__first,__last)){{if(((++__first),__last)){{if((__comp((*__first),(*__result.first)))){(__result.first=__first);}else{(__result.second=__first);};
while(((++__first),__last)){{__xcodeml_template_type_0_0 __i=__first;
if(((++__first),__last)){{if((__comp((*__i),(*__result.first)))){(__result.first=__i);}else{if((!(__comp((*__i),(*__result.second))))){(__result.second=__i);};};
break;
};}else{{if((__comp((*__first),(*__i)))){{if((__comp((*__first),(*__result.first)))){(__result.first=__first);};
if((!(__comp((*__i),(*__result.second))))){(__result.second=__i);};
};}else{{if((__comp((*__i),(*__result.first)))){(__result.first=__i);};
if((!(__comp((*__first),(*__result.second))))){(__result.second=__first);};
};};
};};
};};
};};
};};
return __result;
}
template<typename __xcodeml_template_type_0_0>pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0>{return(std::__1::(__first,__last,__xcodeml_identity<__less<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_0>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>pair<__xcodeml_template_type_0_0 const&,__xcodeml_template_type_0_0 const&>{return((__comp(__b,__a))?__xcodeml_identity<pair<__xcodeml_template_type_0_0 const&,__xcodeml_template_type_0_0 const&> >::t(__b,__a):__xcodeml_identity<pair<__xcodeml_template_type_0_0 const&,__xcodeml_template_type_0_0 const&> >::t(__a,__b));
}
template<typename __xcodeml_template_type_0_0>pair<__xcodeml_template_type_0_0 const&,__xcodeml_template_type_0_0 const&>{return(std::__1::(__a,__b,__xcodeml_identity<__less<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0>{typedef typename initializer_list<__xcodeml_template_type_0_0>::const_iterator _Iter;
typename initializer_list<__xcodeml_template_type_0_0>::const_iterator __first=(__t.begin());
typename initializer_list<__xcodeml_template_type_0_0>::const_iterator __last=(__t.end());
pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0> =(*__first)(*__first);
(++__first);
if((((__t.size())%2),0)){{if((__comp((*__first),__result.first))){(__result.first=(*__first));}else{(__result.second=(*__first));};
(++__first);
};};
while((__first,__last)){{__xcodeml_template_type_0_0 __prev=(*(__first++));
if((__comp((*__first),__prev))){{if((__comp((*__first),__result.first))){(__result.first=(*__first));};
if((!(__comp(__prev,__result.second)))){(__result.second=__prev);};
};}else{{if((__comp(__prev,__result.first))){(__result.first=__prev);};
if((!(__comp((*__first),__result.second)))){(__result.second=(*__first));};
};};
(__first++);
};};
return __result;
}
template<typename __xcodeml_template_type_0_0>pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0>{return(std::__1::(__t,__xcodeml_identity<__less<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0> >::t()));
}
template<unsigned long long _Xp,unsigned long _Rp>class __log2_imp{public:static unsigned long const value=((_Xp&(((unsigned long long)1)<<_Rp))?_Rp:__log2_imp<expression,expression>::value);
}
;
;
template<unsigned long long _Xp>class __log2_imp<expression,0>{public:static unsigned long const value=0;
}
;
template<unsigned long _Rp>class __log2_imp<0,expression>{public:static unsigned long const value=(_Rp+1);
}
;
template<typename __xcodeml_template_type_0_0,__xcodeml_template_type_0_0 _Xp>class __log2{public:static unsigned long const value=__log2_imp<expression,expression>::value;
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __independent_bits_engine{public:
public:typedef __xcodeml_template_type_0_1 result_type;
private:
private:typedef typename __xcodeml_template_type_0_0::result_type _Engine_result_type;
private:typedef typename conditional<expression,__xcodeml_template_type_0_1,typename __xcodeml_template_type_0_0::result_type>::type _Working_result_type;
private:__xcodeml_template_type_0_0&__e_;
private:unsigned long __w_;
private:unsigned long __w0_;
private:unsigned long __n_;
private:unsigned long __n0_;
private:typename conditional<expression,__xcodeml_template_type_0_1,typename __xcodeml_template_type_0_0::result_type>::type __y0_;
private:typename conditional<expression,__xcodeml_template_type_0_1,typename __xcodeml_template_type_0_0::result_type>::type __y1_;
private:typename __xcodeml_template_type_0_0::result_type __mask0_;
private:typename __xcodeml_template_type_0_0::result_type __mask1_;
private:constexpr static typename conditional<expression,__xcodeml_template_type_0_1,typename __xcodeml_template_type_0_0::result_type>::type const _Rp=(((__xcodeml_template_type_0_0::max()),(__xcodeml_template_type_0_0::min())),__xcodeml_identity<typename conditional<expression,__xcodeml_template_type_0_1,typename __xcodeml_template_type_0_0::result_type>::type>::t(1));
private:constexpr static unsigned long const __m=__log2<typename conditional<expression,__xcodeml_template_type_0_1,typename __xcodeml_template_type_0_0::result_type>::type,expression>::value;
private:constexpr static unsigned long const _WDt=numeric_limits<typename conditional<expression,__xcodeml_template_type_0_1,typename __xcodeml_template_type_0_0::result_type>::type>::digits;
private:constexpr static unsigned long const _EDt=numeric_limits<typename __xcodeml_template_type_0_0::result_type>::digits;
public:
public:__independent_bits_engine(__xcodeml_template_type_0_0&__e,unsigned long __w);
public:__xcodeml_template_type_0_1 operator()(){return((__xcodeml_identity<integral_constant<bool,expression> >::t()));
}
private:
private:__xcodeml_template_type_0_1 __eval(class::std::__1::integral_constant<bool,0>);
private:__xcodeml_template_type_0_1 __eval(class::std::__1::integral_constant<bool,1>);
}
;
;
__independent_bits_engine::__independent_bits_engine(__xcodeml_template_type_0_0&__e,unsigned long __w):__e_(__e),__w_(__w){(this->__n_=((this->__w_/__m),((this->__w_%__m),0)));
(this->__w0_=(this->__w_/this->__n_));
if((_Rp,0)){(this->__y0_=_Rp);}else{if((this->__w0_,_WDt)){(this->__y0_=((_Rp>>this->__w0_),this->__w0_));}else{(this->__y0_=0);};};
if(((_Rp,this->__y0_),(this->__y0_/this->__n_))){{(++this->__n_);
(this->__w0_=(this->__w_/this->__n_));
if((this->__w0_,_WDt)){(this->__y0_=((_Rp>>this->__w0_),this->__w0_));}else{(this->__y0_=0);};
};};
(this->__n0_=(this->__n_,(this->__w_%this->__n_)));
if((this->__w0_,(_WDt-1))){(this->__y1_=((_Rp>>(this->__w0_,1)),(this->__w0_,1)));}else{(this->__y1_=0);};
(this->__mask0_=((this->__w0_,0)?(__xcodeml_identity<typename __xcodeml_template_type_0_0::result_type>::t((~0))>>(_EDt,this->__w0_)):__xcodeml_identity<typename __xcodeml_template_type_0_0::result_type>::t(0)));
(this->__mask1_=((this->__w0_,(_EDt-1))?(__xcodeml_identity<typename __xcodeml_template_type_0_0::result_type>::t((~0))>>(_EDt,(this->__w0_,1))):__xcodeml_identity<typename __xcodeml_template_type_0_0::result_type>::t((~0))));
}
__xcodeml_template_type_0_1 __independent_bits_engine::__eval(class::std::__1::integral_constant<bool,0>){return static_cast<__xcodeml_template_type_0_1>(((this->__e_())&this->__mask0_));
}
__xcodeml_template_type_0_1 __independent_bits_engine::__eval(class::std::__1::integral_constant<bool,1>){unsigned long const _WRt=numeric_limits<__xcodeml_template_type_0_1>::.digits;
__xcodeml_template_type_0_1 _Sp=0;
{unsigned long __k=0;for(;(__k,this->__n0_);(++__k)){{typename __xcodeml_template_type_0_0::result_type __u;
do{{(__u=((this->__e_()),(__xcodeml_template_type_0_0::.min())));
};}while((__u,this->__y0_));
if((this->__w0_,_WRt)){(_Sp<<=this->__w0_);}else{(_Sp=0);};
(_Sp+=(__u&this->__mask0_));
};}};
{unsigned long __k=this->__n0_;for(;(__k,this->__n_);(++__k)){{typename __xcodeml_template_type_0_0::result_type __u;
do{{(__u=((this->__e_()),(__xcodeml_template_type_0_0::.min())));
};}while((__u,this->__y1_));
if((this->__w0_,(_WRt-1))){(_Sp<<=(this->__w0_,1));}else{(_Sp=0);};
(_Sp+=(__u&this->__mask1_));
};}};
return _Sp;
}
template<typename __xcodeml_template_type_0_0>class uniform_int_distribution{public:
public:typedef __xcodeml_template_type_0_0 result_type;
public:class param_type{private:__xcodeml_template_type_0_0 __a_;
private:__xcodeml_template_type_0_0 __b_;
public:
public:typedef class uniform_int_distribution distribution_type;
public:param_type(__xcodeml_template_type_0_0 __a,__xcodeml_template_type_0_0 __b):__a_(__a),__b_(__b){}
public:__xcodeml_template_type_0_0 a()const{return this->__a_;
}
public:__xcodeml_template_type_0_0 b()const{return this->__b_;
}
public:friend bool operator==(class param_type const&__x,class param_type const&__y){return((__x.__a_,__y.__a_)&&(__x.__b_,__y.__b_));
};
public:friend bool operator!=(class param_type const&__x,class param_type const&__y){return(!(__x,__y));
};
}
;
private:
private:class::std::__1::uniform_int_distribution::param_type __p_;
public:
public:uniform_int_distribution(__xcodeml_template_type_0_0 __a,__xcodeml_template_type_0_0 __b):__p_(__xcodeml_identity<class::std::__1::uniform_int_distribution::param_type>::t(__a,__b)){}
public:uniform_int_distribution(class param_type const&__p):__p_(__p){}
public:void reset(){}
public:template<typename __xcodeml_template_type_1_0>__xcodeml_template_type_0_0 operator()(__xcodeml_template_type_1_0&__g){return((*this)(__g,this->__p_));
}
public:template<typename __xcodeml_template_type_1_0>__xcodeml_template_type_0_0 operator()(__xcodeml_template_type_1_0&__g,class param_type const&__p)
public:__xcodeml_template_type_0_0 a()const{return(this->__p_.a());
}
public:__xcodeml_template_type_0_0 b()const{return(this->__p_.b());
}
public:class::std::__1::uniform_int_distribution::param_type param()const{return this->__p_;
}
public:void param(class param_type const&__p){(this->__p_=__p);
}
public:__xcodeml_template_type_0_0 min()const{return(this->a());
}
public:__xcodeml_template_type_0_0 max()const{return(this->b());
}
public:friend bool operator==(class uniform_int_distribution const&__x,class uniform_int_distribution const&__y){return(__x.__p_,__y.__p_);
};
public:friend bool operator!=(class uniform_int_distribution const&__x,class uniform_int_distribution const&__y){return(!(__x,__y));
};
}
;
template<>class uniform_int_distribution<long>{public:
public:typedef long result_type;
public:class param_type{private:long __a_;
private:long __b_;
public:
public:typedef class::std::__1::uniform_int_distribution<long>distribution_type;
public:param_type(long __a,long __b);
public:long a()const;
public:long b()const;
public:friend bool operator==(class param_type const&__x,class param_type const&__y);
public:friend bool operator!=(class param_type const&__x,class param_type const&__y);
}
;
private:
private:class::std::__1::uniform_int_distribution<long>::param_type __p_;
public:
public:uniform_int_distribution(long __a,long __b);
public:uniform_int_distribution(class param_type const&__p);
public:void reset();
public:template<typename __xcodeml_template_type_0_0>long operator()(__xcodeml_template_type_0_0&__g)
public:template<typename __xcodeml_template_type_0_0>long operator()(__xcodeml_template_type_0_0&__g,class param_type const&__p)
template <>long operator()(class::std::__1::__rs_default&__g,class param_type const&__p)
public:long a()const;
public:long b()const;
public:class::std::__1::uniform_int_distribution<long>::param_type param()const;
public:void param(class param_type const&__p);
public:long min()const;
public:long max()const;
public:friend bool operator==(class uniform_int_distribution const&__x,class uniform_int_distribution const&__y);
public:friend bool operator!=(class uniform_int_distribution const&__x,class uniform_int_distribution const&__y);
}
;
template<typename __xcodeml_template_type_1_0>__xcodeml_template_type_0_0 uniform_int_distribution::operator()(__xcodeml_template_type_1_0&__g,class param_type const&__p){typedef typename conditional<expression,unsigned int,unsigned long>::type _UIntType;
typename conditional<expression,unsigned int,unsigned long>::type const _Rp=((__xcodeml_identity<typename conditional<expression,unsigned int,unsigned long>::type>::t((__p.b())),__xcodeml_identity<typename conditional<expression,unsigned int,unsigned long>::type>::t((__p.a()))),__xcodeml_identity<typename conditional<expression,unsigned int,unsigned long>::type>::t(1));
if((_Rp,1)){return(__p.a());};
unsigned long const _Dt=numeric_limits<typename conditional<expression,unsigned int,unsigned long>::type>::.digits;
typedef __independent_bits_engine<__xcodeml_template_type_1_0,typename conditional<expression,unsigned int,unsigned long>::type>;
if((_Rp,0)){return static_cast<__xcodeml_template_type_0_0>((__xcodeml_identity<__independent_bits_engine<__xcodeml_template_type_1_0,typename conditional<expression,unsigned int,unsigned long>::type> >::t(__g,_Dt)()));};
unsigned long __w=((_Dt,((_Rp))),1);
if(((_Rp&((std::numeric_limits<typename conditional<expression,unsigned int,unsigned long>::type>::.max())>>(_Dt-__w))),0)){(++__w);};
__independent_bits_engine<__xcodeml_template_type_1_0,typename conditional<expression,unsigned int,unsigned long>::type> =__g __w;
typename conditional<expression,unsigned int,unsigned long>::type __u;
do{{(__u=(__e()));
};}while((__u,_Rp));
return static_cast<__xcodeml_template_type_0_0>((__u,(__p.a())));
}
class __rs_default;
class::std::__1::__rs_default __rs_get();
class __rs_default{private:static unsigned int __c_;
private:__rs_default();
public:
public:typedef unsigned int result_type;
public:static unsigned int const _Min=0;
public:static unsigned int const _Max=0xFFFFFFFF;
public:__rs_default(class __rs_default const&);
public:~__rs_default();
public:unsigned int operator()();
public:static unsigned int min(){return _Min;
}
public:static unsigned int max(){return _Max;
}
public:friend class::std::__1::__rs_default __rs_get();
}
;
class::std::__1::__rs_default __rs_get();
template<typename __xcodeml_template_type_0_0>void random_shuffle(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last){typedef typename iterator_traits<__xcodeml_template_type_0_0>::difference_type difference_type;
typedef class::std::__1::uniform_int_distribution<long>_Dp;
typedef class::std::__1::uniform_int_distribution<long>::param_type _Pp;
typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __d=(__last,__first);
if((__d,1)){{class::std::__1::uniform_int_distribution<long>__uid(0,(numeric_limits::max()));
class::std::__1::__rs_default __g=(__rs_get());
{((--__last),((void)(--__d)));for(;(__first,__last);((++__first),((void)(--__d)))){{typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __i=__uid.operator()(__g,__xcodeml_identity<class::std::__1::uniform_int_distribution<long>::param_type>::t(0,__d));
if((__i,__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_0>::difference_type>::t(0))){(((*__first),(*(__first,__i))));};
};}};
};};
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void random_shuffle(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1(*__rand)){typedef typename iterator_traits<__xcodeml_template_type_0_0>::difference_type difference_type;
typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __d=(__last,__first);
if((__d,1)){{{(--__last);for(;(__first,__last);((++__first),((void)(--__d)))){{typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __i=(__rand(__d));
if((__i,__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_0>::difference_type>::t(0))){(((*__first),(*(__first,__i))));};
};}};
};};
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>__xcodeml_template_type_0_1 __sample(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __output_iter,__xcodeml_template_type_0_2 __n,__xcodeml_template_type_0_3&__g,class::std::__1::input_iterator_tag){__xcodeml_template_type_0_2 __k=0;
{;for(;((__first,__last)&&(__k,__n));((++__first),((void)(++__k)))){((__output_iter)[__k]=(*__first));}};
__xcodeml_template_type_0_2 __sz=__k;
{;for(;(__first,__last);((++__first),((void)(++__k)))){{__xcodeml_template_type_0_2 __r=(__xcodeml_identity<uniform_int_distribution<__xcodeml_template_type_0_2> >::t(0,__k)(__g));
if((__r,__sz)){((__output_iter)[__r]=(*__first));};
};}};
return(__output_iter,(std::__1::(__n,__k)));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>__xcodeml_template_type_0_1 __sample(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __output_iter,__xcodeml_template_type_0_2 __n,__xcodeml_template_type_0_3&__g,class::std::__1::forward_iterator_tag){__xcodeml_template_type_0_2 __unsampled_sz=(std::__1::(__first,__last));
{(__n=(std::__1::(__n,__unsampled_sz)));for(;(__n,0);(++__first)){{__xcodeml_template_type_0_2 __r=(__xcodeml_identity<uniform_int_distribution<__xcodeml_template_type_0_2> >::t(0,(--__unsampled_sz))(__g));
if((__r,__n)){{((*(__output_iter++))=(*__first));
(--__n);
};};
};}};
return __output_iter;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>__xcodeml_template_type_0_1 __sample(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __output_iter,__xcodeml_template_type_0_2 __n,__xcodeml_template_type_0_3&__g){typedef typename iterator_traits<__xcodeml_template_type_0_0>::iterator_category _PopCategory;
typedef typename iterator_traits<__xcodeml_template_type_0_0>::difference_type _Difference;
(__is_forward_iterator<__xcodeml_template_type_0_0>::value||__is_random_access_iterator<__xcodeml_template_type_0_1>::value)"SampleIterator must meet the requirements of RandomAccessIterator";
typedef typename common_type<...>::type _CommonType;
((void)0);
return(std::__1::(__first,__last,__output_iter,__xcodeml_identity<typename common_type<...>::type>::t(__n),__g,__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_0>::iterator_category>::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void shuffle(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1(*__g)){typedef typename iterator_traits<__xcodeml_template_type_0_0>::difference_type difference_type;
typedef class::std::__1::uniform_int_distribution<long>_Dp;
typedef class::std::__1::uniform_int_distribution<long>::param_type _Pp;
typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __d=(__last,__first);
if((__d,1)){{class::std::__1::uniform_int_distribution<long>__uid(0,(numeric_limits::max()));
{((--__last),(--__d));for(;(__first,__last);((++__first),(--__d))){{typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __i=(__uid(__g,__xcodeml_identity<class::std::__1::uniform_int_distribution<long>::param_type>::t(0,__d)));
if((__i,__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_0>::difference_type>::t(0))){(((*__first),(*(__first,__i))));};
};}};
};};
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool is_partitioned(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __pred){{;for(;(__first,__last);(++__first)){if((!(__pred((*__first))))){break;};}};
if((__first,__last)){return true;};
(++__first);
{;for(;(__first,__last);(++__first)){if((__pred((*__first)))){return false;};}};
return true;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_1 __partition(__xcodeml_template_type_0_1 __first,__xcodeml_template_type_0_1 __last,__xcodeml_template_type_0_0 __pred,class::std::__1::forward_iterator_tag){while(true){{if((__first,__last)){return __first;};
if((!(__pred((*__first))))){break;};
(++__first);
};};
{__xcodeml_template_type_0_1 __p=__first;for(;((++__p),__last);){{if((__pred((*__p)))){{(((*__first),(*__p)));
(++__first);
};};
};}};
return __first;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_1 __partition(__xcodeml_template_type_0_1 __first,__xcodeml_template_type_0_1 __last,__xcodeml_template_type_0_0 __pred,class::std::__1::bidirectional_iterator_tag){while(true){{while(true){{if((__first,__last)){return __first;};
if((!(__pred((*__first))))){break;};
(++__first);
};};
do{{if((__first,(--__last))){return __first;};
};}while((!(__pred((*__last)))));
(((*__first),(*__last)));
(++__first);
};};
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0 partition(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __pred){return(std::__1::typename add_lvalue_reference<__xcodeml_template_type_0_1>::type(__first,__last,__pred,__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_0>::iterator_category>::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>pair<__xcodeml_template_type_0_1,__xcodeml_template_type_0_2>{{;for(;(__first,__last);(++__first)){{if((__pred((*__first)))){{((*__out_true)=(*__first));
(++__out_true);
};}else{{((*__out_false)=(*__first));
(++__out_false);
};};
};}};
return __xcodeml_identity<pair<__xcodeml_template_type_0_1,__xcodeml_template_type_0_2> >::t(__out_true,__out_false);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0 partition_point(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __pred){typedef typename iterator_traits<__xcodeml_template_type_0_0>::difference_type difference_type;
typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __len=(std::__1::(__first,__last));
while((__len,0)){{typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __l2=(std::__1::(__len));
__xcodeml_template_type_0_0 __m=__first;
(std::__1::(__m,__l2));
if((__pred((*__m)))){{(__first=(++__m));
(__len-=(__l2,1));
};}else{(__len=__l2);};
};};
return __first;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>__xcodeml_template_type_0_1 __stable_partition(__xcodeml_template_type_0_1 __first,__xcodeml_template_type_0_1 __last,__xcodeml_template_type_0_0 __pred,__xcodeml_template_type_0_2 __len,__xcodeml_template_type_0_3 __p,class::std::__1::forward_iterator_tag __fit){if((__len,1)){return __first;};
if((__len,2)){{__xcodeml_template_type_0_1 __m=__first;
if((__pred((*(++__m))))){{(((*__first),(*__m)));
return __m;
};};
return __first;
};};
if((__len,__p.second)){{typedef typename iterator_traits<__xcodeml_template_type_0_1>::value_type value_type;
class::std::__1::__destruct_n __d(0);
unique_ptr<typename iterator_traits<__xcodeml_template_type_0_1>::value_type,class::std::__1::__destruct_n&> =__p.first __d;
typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*__t)=__p.first;
::new(__t)__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_1>::value_type>::t((std::__1::((*__first))));
(__d(((typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*))0)));
(++__t);
__xcodeml_template_type_0_1 __i=__first;
while(((++__i),__last)){{if((__pred((*__i)))){{((*__first)=(std::__1::((*__i))));
(++__first);
};}else{{::new(__t)__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_1>::value_type>::t((std::__1::((*__i))));
(__d(((typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*))0)));
(++__t);
};};
};};
(__i=__first);
{typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*__t2)=__p.first;for(;(__t2,__t);((++__t2),(++__i))){((*__i)=(std::__1::((*__t2))));}};
return __first;
};};
__xcodeml_template_type_0_1 __m=__first;
__xcodeml_template_type_0_2 __len2=(__len/2);
(std::__1::(__m,__len2));
typedef typename add_lvalue_reference<__xcodeml_template_type_0_0>::type _PredRef;
__xcodeml_template_type_0_1 __first_false=(typename add_lvalue_reference<__xcodeml_template_type_0_0>::type(__first,__m,__pred,__len2,__p,__fit));
__xcodeml_template_type_0_1 __m1=__m;
__xcodeml_template_type_0_1 __second_false=__last;
__xcodeml_template_type_0_2 __len_half=(__len,__len2);
while((__pred((*__m1)))){{if(((++__m1),__last)){goto __second_half_done;};
(--__len_half);
};};
(__second_false=(typename add_lvalue_reference<__xcodeml_template_type_0_0>::type(__m1,__last,__pred,__len_half,__p,__fit)));
__second_half_done:return(std::__1::(__first_false,__m,__second_false));
}
class __return_temporary_buffer{public:template<typename __xcodeml_template_type_0_0>void operator()(__xcodeml_template_type_0_0(*__p))const{(std::__1::(__p));
}
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_1 __stable_partition(__xcodeml_template_type_0_1 __first,__xcodeml_template_type_0_1 __last,__xcodeml_template_type_0_0 __pred,class::std::__1::forward_iterator_tag){unsigned int const __alloc_limit=3;
while(true){{if((__first,__last)){return __first;};
if((!(__pred((*__first))))){break;};
(++__first);
};};
typedef typename iterator_traits<__xcodeml_template_type_0_1>::difference_type difference_type;
typedef typename iterator_traits<__xcodeml_template_type_0_1>::value_type value_type;
typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __len=(std::__1::(__first,__last));
pair<typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*),long> =0 0;
unique_ptr<typename iterator_traits<__xcodeml_template_type_0_1>::value_type,class::std::__1::__return_temporary_buffer>;
if((__len,__alloc_limit)){{(__p=(std::__1::typename iterator_traits<__xcodeml_template_type_0_1>::value_type(__len)));
(__h.reset(__p.first));
};};
return(typename add_lvalue_reference<__xcodeml_template_type_0_0>::type(__first,__last,__pred,__len,__p,__xcodeml_identity<class::std::__1::forward_iterator_tag>::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>__xcodeml_template_type_0_1 __stable_partition(__xcodeml_template_type_0_1 __first,__xcodeml_template_type_0_1 __last,__xcodeml_template_type_0_0 __pred,__xcodeml_template_type_0_2 __len,__xcodeml_template_type_0_3 __p,class::std::__1::bidirectional_iterator_tag __bit){if((__len,2)){{(((*__first),(*__last)));
return __last;
};};
if((__len,3)){{__xcodeml_template_type_0_1 __m=__first;
if((__pred((*(++__m))))){{(((*__first),(*__m)));
(((*__m),(*__last)));
return __last;
};};
(((*__m),(*__last)));
(((*__first),(*__m)));
return __m;
};};
if((__len,__p.second)){{typedef typename iterator_traits<__xcodeml_template_type_0_1>::value_type value_type;
class::std::__1::__destruct_n __d(0);
unique_ptr<typename iterator_traits<__xcodeml_template_type_0_1>::value_type,class::std::__1::__destruct_n&> =__p.first __d;
typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*__t)=__p.first;
::new(__t)__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_1>::value_type>::t((std::__1::((*__first))));
(__d(((typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*))0)));
(++__t);
__xcodeml_template_type_0_1 __i=__first;
while(((++__i),__last)){{if((__pred((*__i)))){{((*__first)=(std::__1::((*__i))));
(++__first);
};}else{{::new(__t)__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_1>::value_type>::t((std::__1::((*__i))));
(__d(((typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*))0)));
(++__t);
};};
};};
((*__first)=(std::__1::((*__i))));
(__i=(++__first));
{typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*__t2)=__p.first;for(;(__t2,__t);((++__t2),(++__i))){((*__i)=(std::__1::((*__t2))));}};
return __first;
};};
__xcodeml_template_type_0_1 __m=__first;
__xcodeml_template_type_0_2 __len2=(__len/2);
(std::__1::(__m,__len2));
__xcodeml_template_type_0_1 __m1=__m;
__xcodeml_template_type_0_1 __first_false=__first;
__xcodeml_template_type_0_2 __len_half=__len2;
while((!(__pred((*(--__m1)))))){{if((__m1,__first)){goto __first_half_done;};
(--__len_half);
};};
typedef typename add_lvalue_reference<__xcodeml_template_type_0_0>::type _PredRef;
(__first_false=(typename add_lvalue_reference<__xcodeml_template_type_0_0>::type(__first,__m1,__pred,__len_half,__p,__bit)));
__first_half_done:(__m1=__m);
__xcodeml_template_type_0_1 __second_false=__last;
(++__second_false);
(__len_half=(__len,__len2));
while((__pred((*__m1)))){{if(((++__m1),__last)){goto __second_half_done;};
(--__len_half);
};};
(__second_false=(typename add_lvalue_reference<__xcodeml_template_type_0_0>::type(__m1,__last,__pred,__len_half,__p,__bit)));
__second_half_done:return(std::__1::(__first_false,__m,__second_false));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_1 __stable_partition(__xcodeml_template_type_0_1 __first,__xcodeml_template_type_0_1 __last,__xcodeml_template_type_0_0 __pred,class::std::__1::bidirectional_iterator_tag){typedef typename iterator_traits<__xcodeml_template_type_0_1>::difference_type difference_type;
typedef typename iterator_traits<__xcodeml_template_type_0_1>::value_type value_type;
typename iterator_traits<__xcodeml_template_type_0_1>::difference_type const __alloc_limit=4;
while(true){{if((__first,__last)){return __first;};
if((!(__pred((*__first))))){break;};
(++__first);
};};
do{{if((__first,(--__last))){return __first;};
};}while((!(__pred((*__last)))));
typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __len=((std::__1::(__first,__last)),1);
pair<typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*),long> =0 0;
unique_ptr<typename iterator_traits<__xcodeml_template_type_0_1>::value_type,class::std::__1::__return_temporary_buffer>;
if((__len,__alloc_limit)){{(__p=(std::__1::typename iterator_traits<__xcodeml_template_type_0_1>::value_type(__len)));
(__h.reset(__p.first));
};};
return(typename add_lvalue_reference<__xcodeml_template_type_0_0>::type(__first,__last,__pred,__len,__p,__xcodeml_identity<class::std::__1::bidirectional_iterator_tag>::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0 stable_partition(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __pred){return(typename add_lvalue_reference<__xcodeml_template_type_0_1>::type(__first,__last,__pred,__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_0>::iterator_category>::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0 is_sorted_until(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __comp){if((__first,__last)){{__xcodeml_template_type_0_0 __i=__first;
while(((++__i),__last)){{if((__comp((*__i),(*__first)))){return __i;};
(__first=__i);
};};
};};
return __last;
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 is_sorted_until(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last){return(std::__1::(__first,__last,__xcodeml_identity<__less<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_0>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool is_sorted(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __comp){return((std::__1::(__first,__last,__comp)),__last);
}
template<typename __xcodeml_template_type_0_0>bool is_sorted(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last){return(std::__1::(__first,__last,__xcodeml_identity<__less<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_0>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>unsigned int __sort3(__xcodeml_template_type_0_1 __x,__xcodeml_template_type_0_1 __y,__xcodeml_template_type_0_1 __z,__xcodeml_template_type_0_0 __c){unsigned int __r=0;
if((!(__c((*__y),(*__x))))){{if((!(__c((*__z),(*__y))))){return __r;};
(((*__y),(*__z)));
(__r=1);
if((__c((*__y),(*__x)))){{(((*__x),(*__y)));
(__r=2);
};};
return __r;
};};
if((__c((*__z),(*__y)))){{(((*__x),(*__z)));
(__r=1);
return __r;
};};
(((*__x),(*__y)));
(__r=1);
if((__c((*__z),(*__y)))){{(((*__y),(*__z)));
(__r=2);
};};
return __r;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>unsigned int __sort4(__xcodeml_template_type_0_1 __x1,__xcodeml_template_type_0_1 __x2,__xcodeml_template_type_0_1 __x3,__xcodeml_template_type_0_1 __x4,__xcodeml_template_type_0_0 __c){unsigned int __r=(__xcodeml_template_type_0_0(__x1,__x2,__x3,__c));
if((__c((*__x4),(*__x3)))){{(((*__x3),(*__x4)));
(++__r);
if((__c((*__x3),(*__x2)))){{(((*__x2),(*__x3)));
(++__r);
if((__c((*__x2),(*__x1)))){{(((*__x1),(*__x2)));
(++__r);
};};
};};
};};
return __r;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>unsigned int __sort5(__xcodeml_template_type_0_1 __x1,__xcodeml_template_type_0_1 __x2,__xcodeml_template_type_0_1 __x3,__xcodeml_template_type_0_1 __x4,__xcodeml_template_type_0_1 __x5,__xcodeml_template_type_0_0 __c){unsigned int __r=(__xcodeml_template_type_0_0(__x1,__x2,__x3,__x4,__c));
if((__c((*__x5),(*__x4)))){{(((*__x4),(*__x5)));
(++__r);
if((__c((*__x4),(*__x3)))){{(((*__x3),(*__x4)));
(++__r);
if((__c((*__x3),(*__x2)))){{(((*__x2),(*__x3)));
(++__r);
if((__c((*__x2),(*__x1)))){{(((*__x1),(*__x2)));
(++__r);
};};
};};
};};
};};
return __r;
}
template <>unsigned int __sort5(long double(*__x1),long double(*__x2),long double(*__x3),long double(*__x4),long double(*__x5),class::std::__1::__less<long double,long double>&__c)
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void __selection_sort(__xcodeml_template_type_0_1 __first,__xcodeml_template_type_0_1 __last,__xcodeml_template_type_0_0 __comp){__xcodeml_template_type_0_1 __lm1=__last;
{(--__lm1);for(;(__first,__lm1);(++__first)){{__xcodeml_template_type_0_1 __i=(std::__1::__xcodeml_template_type_0_1 typename add_lvalue_reference<__xcodeml_template_type_0_0>::type(__first,__last,__comp));
if((__i,__first)){(((*__first),(*__i)));};
};}};
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void __insertion_sort(__xcodeml_template_type_0_1 __first,__xcodeml_template_type_0_1 __last,__xcodeml_template_type_0_0 __comp){typedef typename iterator_traits<__xcodeml_template_type_0_1>::value_type value_type;
if((__first,__last)){{__xcodeml_template_type_0_1 __i=__first;
{(++__i);for(;(__i,__last);(++__i)){{__xcodeml_template_type_0_1 __j=__i;
typename iterator_traits<__xcodeml_template_type_0_1>::value_type __t=(std::__1::((*__j)));
{__xcodeml_template_type_0_1 __k=__i;for(;((__k,__first)&&(__comp(__t,(*(--__k)))));(--__j)){((*__j)=(std::__1::((*__k))));}};
((*__j)=(std::__1::(__t)));
};}};
};};
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void __insertion_sort_3(__xcodeml_template_type_0_1 __first,__xcodeml_template_type_0_1 __last,__xcodeml_template_type_0_0 __comp){typedef typename iterator_traits<__xcodeml_template_type_0_1>::value_type value_type;
__xcodeml_template_type_0_1 __j=(__first,2);
(__xcodeml_template_type_0_0(__first,(__first,1),__j,__comp));
{__xcodeml_template_type_0_1 __i=(__j,1);for(;(__i,__last);(++__i)){{if((__comp((*__i),(*__j)))){{typename iterator_traits<__xcodeml_template_type_0_1>::value_type __t=(std::__1::((*__i)));
__xcodeml_template_type_0_1 __k=__j;
(__j=__i);
do{{((*__j)=(std::__1::((*__k))));
(__j=__k);
};}while(((__j,__first)&&(__comp(__t,(*(--__k))))));
((*__j)=(std::__1::(__t)));
};};
(__j=__i);
};}};
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool __insertion_sort_incomplete(__xcodeml_template_type_0_1 __first,__xcodeml_template_type_0_1 __last,__xcodeml_template_type_0_0 __comp){switch((__last,__first)){case 0:case 1:return true;
case 2:if((__comp((*(--__last)),(*__first)))){(((*__first),(*__last)));};
return true;
case 3:(std::__1::__xcodeml_template_type_0_0(__first,(__first,1),(--__last),__comp));
return true;
case 4:(std::__1::__xcodeml_template_type_0_0(__first,(__first,1),(__first,2),(--__last),__comp));
return true;
case 5:(std::__1::__xcodeml_template_type_0_0(__first,(__first,1),(__first,2),(__first,3),(--__last),__comp));
return true;
};
typedef typename iterator_traits<__xcodeml_template_type_0_1>::value_type value_type;
__xcodeml_template_type_0_1 __j=(__first,2);
(__xcodeml_template_type_0_0(__first,(__first,1),__j,__comp));
unsigned int const __limit=8;
unsigned int __count=0;
{__xcodeml_template_type_0_1 __i=(__j,1);for(;(__i,__last);(++__i)){{if((__comp((*__i),(*__j)))){{typename iterator_traits<__xcodeml_template_type_0_1>::value_type __t=(std::__1::((*__i)));
__xcodeml_template_type_0_1 __k=__j;
(__j=__i);
do{{((*__j)=(std::__1::((*__k))));
(__j=__k);
};}while(((__j,__first)&&(__comp(__t,(*(--__k))))));
((*__j)=(std::__1::(__t)));
if(((++__count)==__limit)){return((++__i),__last);};
};};
(__j=__i);
};}};
return true;
}
template <>bool __insertion_sort_incomplete(char(*__first),char(*__last),class::std::__1::__less<char,char>&__comp)
template <>bool __insertion_sort_incomplete(wchar_t(*__first),wchar_t(*__last),class::std::__1::__less<wchar_t,wchar_t>&__comp)
template <>bool __insertion_sort_incomplete(signed char(*__first),signed char(*__last),class::std::__1::__less<signed char,signed char>&__comp)
template <>bool __insertion_sort_incomplete(unsigned char(*__first),unsigned char(*__last),class::std::__1::__less<unsigned char,unsigned char>&__comp)
template <>bool __insertion_sort_incomplete(short(*__first),short(*__last),class::std::__1::__less<short,short>&__comp)
template <>bool __insertion_sort_incomplete(unsigned short(*__first),unsigned short(*__last),class::std::__1::__less<unsigned short,unsigned short>&__comp)
template <>bool __insertion_sort_incomplete(int(*__first),int(*__last),class::std::__1::__less<int,int>&__comp)
template <>bool __insertion_sort_incomplete(unsigned int(*__first),unsigned int(*__last),class::std::__1::__less<unsigned int,unsigned int>&__comp)
template <>bool __insertion_sort_incomplete(long(*__first),long(*__last),class::std::__1::__less<long,long>&__comp)
template <>bool __insertion_sort_incomplete(unsigned long(*__first),unsigned long(*__last),class::std::__1::__less<unsigned long,unsigned long>&__comp)
template <>bool __insertion_sort_incomplete(long long(*__first),long long(*__last),class::std::__1::__less<long long,long long>&__comp)
template <>bool __insertion_sort_incomplete(unsigned long long(*__first),unsigned long long(*__last),class::std::__1::__less<unsigned long long,unsigned long long>&__comp)
template <>bool __insertion_sort_incomplete(float(*__first),float(*__last),class::std::__1::__less<float,float>&__comp)
template <>bool __insertion_sort_incomplete(double(*__first),double(*__last),class::std::__1::__less<double,double>&__comp)
template <>bool __insertion_sort_incomplete(long double(*__first),long double(*__last),class::std::__1::__less<long double,long double>&__comp)
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void __insertion_sort_move(__xcodeml_template_type_0_1 __first1,__xcodeml_template_type_0_1 __last1,typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*__first2),__xcodeml_template_type_0_0 __comp){typedef typename iterator_traits<__xcodeml_template_type_0_1>::value_type value_type;
if((__first1,__last1)){{class::std::__1::__destruct_n __d(0);
unique_ptr<typename iterator_traits<__xcodeml_template_type_0_1>::value_type,class::std::__1::__destruct_n&> =__first2 __d;
typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*__last2)=__first2;
::new(__last2)__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_1>::value_type>::t((std::__1::((*__first1))));
(__d(((typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*))0)));
{(++__last2);for(;((++__first1),__last1);(++__last2)){{typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*__j2)=__last2;
typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*__i2)=__j2;
if((__comp((*__first1),(*(--__i2))))){{::new(__j2)__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_1>::value_type>::t((std::__1::((*__i2))));
(__d(((typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*))0)));
{(--__j2);for(;((__i2,__first2)&&(__comp((*__first1),(*(--__i2)))));(--__j2)){((*__j2)=(std::__1::((*__i2))));}};
((*__j2)=(std::__1::((*__first1))));
};}else{{::new(__j2)__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_1>::value_type>::t((std::__1::((*__first1))));
(__d(((typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*))0)));
};};
};}};
(__h.release());
};};
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void __sort(__xcodeml_template_type_0_1 __first,__xcodeml_template_type_0_1 __last,__xcodeml_template_type_0_0 __comp){typedef typename iterator_traits<__xcodeml_template_type_0_1>::difference_type difference_type;
typedef typename iterator_traits<__xcodeml_template_type_0_1>::value_type value_type;
typename iterator_traits<__xcodeml_template_type_0_1>::difference_type const __limit=((is_trivially_copy_constructible<typename iterator_traits<__xcodeml_template_type_0_1>::value_type>::value&&is_trivially_copy_assignable<typename iterator_traits<__xcodeml_template_type_0_1>::value_type>::value)?30:6);
while(true){{__restart:typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __len=(__last,__first);
switch(__len){case 0:case 1:return;
case 2:if((__comp((*(--__last)),(*__first)))){(((*__first),(*__last)));};
return;
case 3:(std::__1::__xcodeml_template_type_0_0(__first,(__first,1),(--__last),__comp));
return;
case 4:(std::__1::__xcodeml_template_type_0_0(__first,(__first,1),(__first,2),(--__last),__comp));
return;
case 5:(std::__1::__xcodeml_template_type_0_0(__first,(__first,1),(__first,2),(__first,3),(--__last),__comp));
return;
};
if((__len,__limit)){{(std::__1::__xcodeml_template_type_0_0(__first,__last,__comp));
return;
};};
__xcodeml_template_type_0_1 __m=__first;
__xcodeml_template_type_0_1 __lm1=__last;
(--__lm1);
unsigned int __n_swaps;
{typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __delta;
if((__len,1000)){{(__delta=(__len/2));
(__m+=__delta);
(__delta/=2);
(__n_swaps=(std::__1::__xcodeml_template_type_0_0(__first,(__first,__delta),__m,(__m,__delta),__lm1,__comp)));
};}else{{(__delta=(__len/2));
(__m+=__delta);
(__n_swaps=(std::__1::__xcodeml_template_type_0_0(__first,__m,__lm1,__comp)));
};};
};
__xcodeml_template_type_0_1 __i=__first;
__xcodeml_template_type_0_1 __j=__lm1;
if((!(__comp((*__i),(*__m))))){{while(true){{if((__i,(--__j))){{(++__i);
(__j=__last);
if((!(__comp((*__first),(*(--__j)))))){{while(true){{if((__i,__j)){return;};
if((__comp((*__first),(*__i)))){{(((*__i),(*__j)));
(++__n_swaps);
(++__i);
break;
};};
(++__i);
};};
};};
if((__i,__j)){return;};
while(true){{while((!(__comp((*__first),(*__i))))){(++__i);};
while((__comp((*__first),(*(--__j))))){;};
if((__i,__j)){break;};
(((*__i),(*__j)));
(++__n_swaps);
(++__i);
};};
(__first=__i);
goto __restart;
};};
if((__comp((*__j),(*__m)))){{(((*__i),(*__j)));
(++__n_swaps);
break;
};};
};};
};};
(++__i);
if((__i,__j)){{while(true){{while((__comp((*__i),(*__m)))){(++__i);};
while((!(__comp((*(--__j)),(*__m))))){;};
if((__i,__j)){break;};
(((*__i),(*__j)));
(++__n_swaps);
if((__m,__i)){(__m=__j);};
(++__i);
};};
};};
if(((__i,__m)&&(__comp((*__m),(*__i))))){{(((*__i),(*__m)));
(++__n_swaps);
};};
if((__n_swaps==0)){{bool __fs=(std::__1::__xcodeml_template_type_0_0(__first,__i,__comp));
if((std::__1::__xcodeml_template_type_0_0((__i,1),__last,__comp))){{if(__fs){return;};
(__last=__i);
continue;
};}else{{if(__fs){{(__first=(++__i));
continue;
};};
};};
};};
if(((__i,__first),(__last,__i))){{(std::__1::__xcodeml_template_type_0_0(__first,__i,__comp));
(__first=(++__i));
};}else{{(std::__1::__xcodeml_template_type_0_0((__i,1),__last,__comp));
(__last=__i);
};};
};};
}
template <>void __sort(char(*__first),char(*__last),class::std::__1::__less<char,char>&__comp)
template <>void __sort(wchar_t(*__first),wchar_t(*__last),class::std::__1::__less<wchar_t,wchar_t>&__comp)
template <>void __sort(signed char(*__first),signed char(*__last),class::std::__1::__less<signed char,signed char>&__comp)
template <>void __sort(unsigned char(*__first),unsigned char(*__last),class::std::__1::__less<unsigned char,unsigned char>&__comp)
template <>void __sort(short(*__first),short(*__last),class::std::__1::__less<short,short>&__comp)
template <>void __sort(unsigned short(*__first),unsigned short(*__last),class::std::__1::__less<unsigned short,unsigned short>&__comp)
template <>void __sort(int(*__first),int(*__last),class::std::__1::__less<int,int>&__comp)
template <>void __sort(unsigned int(*__first),unsigned int(*__last),class::std::__1::__less<unsigned int,unsigned int>&__comp)
template <>void __sort(long(*__first),long(*__last),class::std::__1::__less<long,long>&__comp)
template <>void __sort(unsigned long(*__first),unsigned long(*__last),class::std::__1::__less<unsigned long,unsigned long>&__comp)
template <>void __sort(long long(*__first),long long(*__last),class::std::__1::__less<long long,long long>&__comp)
template <>void __sort(unsigned long long(*__first),unsigned long long(*__last),class::std::__1::__less<unsigned long long,unsigned long long>&__comp)
template <>void __sort(float(*__first),float(*__last),class::std::__1::__less<float,float>&__comp)
template <>void __sort(double(*__first),double(*__last),class::std::__1::__less<double,double>&__comp)
template <>void __sort(long double(*__first),long double(*__last),class::std::__1::__less<long double,long double>&__comp)
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void sort(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __comp){typedef typename __comp_ref_type<__xcodeml_template_type_0_1>::type _Comp_ref;
(std::__1::typename __comp_ref_type<__xcodeml_template_type_0_1>::type(__first,__last,__xcodeml_identity<typename __comp_ref_type<__xcodeml_template_type_0_1>::type>::t(__comp)));
}
template <>void sort(unsigned long(*__first),unsigned long(*__last),class::std::__1::__less<unsigned long,unsigned long>__comp)
template<typename __xcodeml_template_type_0_0>void sort(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last){(std::__1::(__first,__last,__xcodeml_identity<__less<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_0>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0>void sort(__xcodeml_template_type_0_0(*(*__first)),__xcodeml_template_type_0_0(*(*__last))){(std::__1::sort(((unsigned long(*))__first),((unsigned long(*))__last),__xcodeml_identity<class::std::__1::__less<unsigned long,unsigned long> >::t()));
}
template<typename __xcodeml_template_type_0_0>void sort(__wrap_iter<__xcodeml_template_type_0_0(*)>,__wrap_iter<__xcodeml_template_type_0_0(*)>){(std::__1::((__first.base()),(__last.base())));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void sort(__wrap_iter<__xcodeml_template_type_0_0(*)>,__wrap_iter<__xcodeml_template_type_0_0(*)>,__xcodeml_template_type_0_1 __comp){typedef typename add_lvalue_reference<__xcodeml_template_type_0_1>::type _Comp_ref;
(std::__1::__xcodeml_template_type_0_0(*)typename add_lvalue_reference<__xcodeml_template_type_0_1>::type((__first.base()),(__last.base()),__comp));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__xcodeml_template_type_0_1 __lower_bound(__xcodeml_template_type_0_1 __first,__xcodeml_template_type_0_1 __last,__xcodeml_template_type_0_2 const&__value_,__xcodeml_template_type_0_0 __comp){typedef typename iterator_traits<__xcodeml_template_type_0_1>::difference_type difference_type;
typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __len=(std::__1::(__first,__last));
while((__len,0)){{typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __l2=(std::__1::(__len));
__xcodeml_template_type_0_1 __m=__first;
(std::__1::(__m,__l2));
if((__comp((*__m),__value_))){{(__first=(++__m));
(__len-=(__l2,1));
};}else{(__len=__l2);};
};};
return __first;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__xcodeml_template_type_0_0 lower_bound(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 const&__value_,__xcodeml_template_type_0_2 __comp){typedef typename add_lvalue_reference<__xcodeml_template_type_0_2>::type _Comp_ref;
return(typename add_lvalue_reference<__xcodeml_template_type_0_2>::type(__first,__last,__value_,__comp));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0 lower_bound(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 const&__value_){return(std::__1::(__first,__last,__value_,__xcodeml_identity<__less<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,__xcodeml_template_type_0_1> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__xcodeml_template_type_0_1 __upper_bound(__xcodeml_template_type_0_1 __first,__xcodeml_template_type_0_1 __last,__xcodeml_template_type_0_2 const&__value_,__xcodeml_template_type_0_0 __comp){typedef typename iterator_traits<__xcodeml_template_type_0_1>::difference_type difference_type;
typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __len=(std::__1::(__first,__last));
while((__len,0)){{typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __l2=(std::__1::(__len));
__xcodeml_template_type_0_1 __m=__first;
(std::__1::(__m,__l2));
if((__comp(__value_,(*__m)))){(__len=__l2);}else{{(__first=(++__m));
(__len-=(__l2,1));
};};
};};
return __first;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__xcodeml_template_type_0_0 upper_bound(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 const&__value_,__xcodeml_template_type_0_2 __comp){typedef typename add_lvalue_reference<__xcodeml_template_type_0_2>::type _Comp_ref;
return(typename add_lvalue_reference<__xcodeml_template_type_0_2>::type(__first,__last,__value_,__comp));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0 upper_bound(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 const&__value_){return(std::__1::(__first,__last,__value_,__xcodeml_identity<__less<__xcodeml_template_type_0_1,typename iterator_traits<__xcodeml_template_type_0_0>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>pair<__xcodeml_template_type_0_1,__xcodeml_template_type_0_1>{typedef typename iterator_traits<__xcodeml_template_type_0_1>::difference_type difference_type;
typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __len=(std::__1::(__first,__last));
while((__len,0)){{typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __l2=(std::__1::(__len));
__xcodeml_template_type_0_1 __m=__first;
(std::__1::(__m,__l2));
if((__comp((*__m),__value_))){{(__first=(++__m));
(__len-=(__l2,1));
};}else{if((__comp(__value_,(*__m)))){{(__last=__m);
(__len=__l2);
};}else{{__xcodeml_template_type_0_1 __mp1=__m;
return __xcodeml_identity<pair<__xcodeml_template_type_0_1,__xcodeml_template_type_0_1> >::t((__xcodeml_template_type_0_0(__first,__m,__value_,__comp)),(__xcodeml_template_type_0_0((++__mp1),__last,__value_,__comp)));
};};};
};};
return __xcodeml_identity<pair<__xcodeml_template_type_0_1,__xcodeml_template_type_0_1> >::t(__first,__first);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0>{typedef typename __comp_ref_type<__xcodeml_template_type_0_2>::type _Comp_ref;
return(typename __comp_ref_type<__xcodeml_template_type_0_2>::type(__first,__last,__value_,__comp));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>pair<__xcodeml_template_type_0_0,__xcodeml_template_type_0_0>{return(std::__1::(__first,__last,__value_,__xcodeml_identity<__less<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,__xcodeml_template_type_0_1> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>bool __binary_search(__xcodeml_template_type_0_1 __first,__xcodeml_template_type_0_1 __last,__xcodeml_template_type_0_2 const&__value_,__xcodeml_template_type_0_0 __comp){(__first=(__xcodeml_template_type_0_0(__first,__last,__value_,__comp)));
return((__first,__last)&&(!(__comp(__value_,(*__first)))));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>bool binary_search(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 const&__value_,__xcodeml_template_type_0_2 __comp){typedef typename __comp_ref_type<__xcodeml_template_type_0_2>::type _Comp_ref;
return(typename __comp_ref_type<__xcodeml_template_type_0_2>::type(__first,__last,__value_,__comp));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool binary_search(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 const&__value_){return(std::__1::(__first,__last,__value_,__xcodeml_identity<__less<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,__xcodeml_template_type_0_1> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>__xcodeml_template_type_0_3 __merge(__xcodeml_template_type_0_1 __first1,__xcodeml_template_type_0_1 __last1,__xcodeml_template_type_0_2 __first2,__xcodeml_template_type_0_2 __last2,__xcodeml_template_type_0_3 __result,__xcodeml_template_type_0_0 __comp){{;for(;(__first1,__last1);(++__result)){{if((__first2,__last2)){return(std::__1::(__first1,__last1,__result));};
if((__comp((*__first2),(*__first1)))){{((*__result)=(*__first2));
(++__first2);
};}else{{((*__result)=(*__first1));
(++__first1);
};};
};}};
return(std::__1::(__first2,__last2,__result));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>__xcodeml_template_type_0_2 merge(__xcodeml_template_type_0_0 __first1,__xcodeml_template_type_0_0 __last1,__xcodeml_template_type_0_1 __first2,__xcodeml_template_type_0_1 __last2,__xcodeml_template_type_0_2 __result,__xcodeml_template_type_0_3 __comp){typedef typename __comp_ref_type<__xcodeml_template_type_0_3>::type _Comp_ref;
return(std::__1::typename __comp_ref_type<__xcodeml_template_type_0_3>::type(__first1,__last1,__first2,__last2,__result,__comp));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__xcodeml_template_type_0_2 merge(__xcodeml_template_type_0_0 __first1,__xcodeml_template_type_0_0 __last1,__xcodeml_template_type_0_1 __first2,__xcodeml_template_type_0_1 __last2,__xcodeml_template_type_0_2 __result){typedef typename iterator_traits<__xcodeml_template_type_0_0>::value_type __v1;
typedef typename iterator_traits<__xcodeml_template_type_0_1>::value_type __v2;
return((__first1,__last1,__first2,__last2,__result,__xcodeml_identity<__less<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_1>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>void __half_inplace_merge(__xcodeml_template_type_0_1 __first1,__xcodeml_template_type_0_1 __last1,__xcodeml_template_type_0_2 __first2,__xcodeml_template_type_0_2 __last2,__xcodeml_template_type_0_3 __result,__xcodeml_template_type_0_0 __comp){{;for(;(__first1,__last1);(++__result)){{if((__first2,__last2)){{(std::__1::(__first1,__last1,__result));
return;
};};
if((__comp((*__first2),(*__first1)))){{((*__result)=(std::__1::((*__first2))));
(++__first2);
};}else{{((*__result)=(std::__1::((*__first1))));
(++__first1);
};};
};}};
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void __buffered_inplace_merge(__xcodeml_template_type_0_1 __first,__xcodeml_template_type_0_1 __middle,__xcodeml_template_type_0_1 __last,__xcodeml_template_type_0_0 __comp,typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __len1,typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __len2,typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*__buff)){typedef typename iterator_traits<__xcodeml_template_type_0_1>::value_type value_type;
class::std::__1::__destruct_n __d(0);
unique_ptr<typename iterator_traits<__xcodeml_template_type_0_1>::value_type,class::std::__1::__destruct_n&> =__buff __d;
if((__len1,__len2)){{typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*__p)=__buff;
{__xcodeml_template_type_0_1 __i=__first;for(;(__i,__middle);(((__d(((typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*))0))),((void)(++__i))),(++__p))){::new(__p)__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_1>::value_type>::t((std::__1::((*__i))));}};
((__buff,__p,__middle,__last,__first,__comp));
};}else{{typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*__p)=__buff;
{__xcodeml_template_type_0_1 __i=__middle;for(;(__i,__last);(((__d(((typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*))0))),((void)(++__i))),(++__p))){::new(__p)__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_1>::value_type>::t((std::__1::((*__i))));}};
typedef reverse_iterator<__xcodeml_template_type_0_1>;
typedef reverse_iterator<typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*)>;
((__xcodeml_identity<reverse_iterator<typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*)> >::t(__p),__xcodeml_identity<reverse_iterator<typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*)> >::t(__buff),__xcodeml_identity<reverse_iterator<__xcodeml_template_type_0_1> >::t(__middle),__xcodeml_identity<reverse_iterator<__xcodeml_template_type_0_1> >::t(__first),__xcodeml_identity<reverse_iterator<__xcodeml_template_type_0_1> >::t(__last),__xcodeml_identity<__invert<__xcodeml_template_type_0_0> >::t(__comp)));
};};
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void __inplace_merge(__xcodeml_template_type_0_1 __first,__xcodeml_template_type_0_1 __middle,__xcodeml_template_type_0_1 __last,__xcodeml_template_type_0_0 __comp,typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __len1,typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __len2,typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*__buff),long __buff_size){typedef typename iterator_traits<__xcodeml_template_type_0_1>::difference_type difference_type;
while(true){{if((__len2,0)){return;};
if(((__len1,__buff_size)||(__len2,__buff_size))){return(__xcodeml_template_type_0_0(__first,__middle,__last,__comp,__len1,__len2,__buff));};
{;for(;true;((++__first),((void)(--__len1)))){{if((__len1,0)){return;};
if((__comp((*__middle),(*__first)))){break;};
};}};
__xcodeml_template_type_0_1 __m1;
__xcodeml_template_type_0_1 __m2;
typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __len11;
typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __len21;
if((__len1,__len2)){{(__len21=(__len2/2));
(__m2=__middle);
(std::__1::(__m2,__len21));
(__m1=(__xcodeml_template_type_0_0(__first,__middle,(*__m2),__comp)));
(__len11=(std::__1::(__first,__m1)));
};}else{{if((__len1,1)){{(((*__first),(*__middle)));
return;
};};
(__len11=(__len1/2));
(__m1=__first);
(std::__1::(__m1,__len11));
(__m2=(__xcodeml_template_type_0_0(__middle,__last,(*__m1),__comp)));
(__len21=(std::__1::(__middle,__m2)));
};};
typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __len12=(__len1,__len11);
typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __len22=(__len2,__len21);
(__middle=(std::__1::(__m1,__middle,__m2)));
if(((__len11,__len21),(__len12,__len22))){{(__xcodeml_template_type_0_0(__first,__m1,__middle,__comp,__len11,__len21,__buff,__buff_size));
(__first=__middle);
(__middle=__m2);
(__len1=__len12);
(__len2=__len22);
};}else{{(__xcodeml_template_type_0_0(__middle,__m2,__last,__comp,__len12,__len22,__buff,__buff_size));
(__last=__middle);
(__middle=__m1);
(__len1=__len11);
(__len2=__len21);
};};
};};
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void inplace_merge(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __middle,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __comp){typedef typename iterator_traits<__xcodeml_template_type_0_0>::value_type value_type;
typedef typename iterator_traits<__xcodeml_template_type_0_0>::difference_type difference_type;
typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __len1=(std::__1::(__first,__middle));
typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __len2=(std::__1::(__middle,__last));
typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __buf_size=(std::__1::(__len1,__len2));
pair<typename iterator_traits<__xcodeml_template_type_0_0>::value_type(*),long> =(std::__1::typename iterator_traits<__xcodeml_template_type_0_0>::value_type(__buf_size));
unique_ptr<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,class::std::__1::__return_temporary_buffer> =__buf.first;
typedef typename __comp_ref_type<__xcodeml_template_type_0_1>::type _Comp_ref;
return(std::__1::typename __comp_ref_type<__xcodeml_template_type_0_1>::type(__first,__middle,__last,__comp,__len1,__len2,__buf.first,__buf.second));
}
template<typename __xcodeml_template_type_0_0>void inplace_merge(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __middle,__xcodeml_template_type_0_0 __last){(std::__1::(__first,__middle,__last,__xcodeml_identity<__less<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_0>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>void __merge_move_construct(__xcodeml_template_type_0_1 __first1,__xcodeml_template_type_0_1 __last1,__xcodeml_template_type_0_2 __first2,__xcodeml_template_type_0_2 __last2,typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*__result),__xcodeml_template_type_0_0 __comp){typedef typename iterator_traits<__xcodeml_template_type_0_1>::value_type value_type;
class::std::__1::__destruct_n __d(0);
unique_ptr<typename iterator_traits<__xcodeml_template_type_0_1>::value_type,class::std::__1::__destruct_n&> =__result __d;
{;for(;true;(++__result)){{if((__first1,__last1)){{{;for(;(__first2,__last2);(((++__first2),(++__result)),(__d(((typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*))0))))){::new(__result)__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_1>::value_type>::t((std::__1::((*__first2))));}};
(__h.release());
return;
};};
if((__first2,__last2)){{{;for(;(__first1,__last1);(((++__first1),(++__result)),(__d(((typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*))0))))){::new(__result)__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_1>::value_type>::t((std::__1::((*__first1))));}};
(__h.release());
return;
};};
if((__comp((*__first2),(*__first1)))){{::new(__result)__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_1>::value_type>::t((std::__1::((*__first2))));
(__d(((typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*))0)));
(++__first2);
};}else{{::new(__result)__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_1>::value_type>::t((std::__1::((*__first1))));
(__d(((typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*))0)));
(++__first1);
};};
};}};
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>void __merge_move_assign(__xcodeml_template_type_0_1 __first1,__xcodeml_template_type_0_1 __last1,__xcodeml_template_type_0_2 __first2,__xcodeml_template_type_0_2 __last2,__xcodeml_template_type_0_3 __result,__xcodeml_template_type_0_0 __comp){{;for(;(__first1,__last1);(++__result)){{if((__first2,__last2)){{{;for(;(__first1,__last1);((++__first1),(++__result))){((*__result)=(std::__1::((*__first1))));}};
return;
};};
if((__comp((*__first2),(*__first1)))){{((*__result)=(std::__1::((*__first2))));
(++__first2);
};}else{{((*__result)=(std::__1::((*__first1))));
(++__first1);
};};
};}};
{;for(;(__first2,__last2);((++__first2),(++__result))){((*__result)=(std::__1::((*__first2))));}};
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void __stable_sort(__xcodeml_template_type_0_1 __first,__xcodeml_template_type_0_1 __last,__xcodeml_template_type_0_0 __comp,typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __len,typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*__buff),long __buff_size)
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void __stable_sort_move(__xcodeml_template_type_0_1 __first1,__xcodeml_template_type_0_1 __last1,__xcodeml_template_type_0_0 __comp,typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __len,typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*__first2)){typedef typename iterator_traits<__xcodeml_template_type_0_1>::value_type value_type;
switch(__len){case 0:return;
case 1: ::new(__first2)__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_1>::value_type>::t((std::__1::((*__first1))));
return;
case 2:class::std::__1::__destruct_n __d(0);
unique_ptr<typename iterator_traits<__xcodeml_template_type_0_1>::value_type,class::std::__1::__destruct_n&> =__first2 __d;
if((__comp((*(--__last1)),(*__first1)))){{::new(__first2)__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_1>::value_type>::t((std::__1::((*__last1))));
(__d(((typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*))0)));
(++__first2);
::new(__first2)__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_1>::value_type>::t((std::__1::((*__first1))));
};}else{{::new(__first2)__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_1>::value_type>::t((std::__1::((*__first1))));
(__d(((typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*))0)));
(++__first2);
::new(__first2)__xcodeml_identity<typename iterator_traits<__xcodeml_template_type_0_1>::value_type>::t((std::__1::((*__last1))));
};};
(__h2.release());
return;
};
if((__len,8)){{(__xcodeml_template_type_0_0(__first1,__last1,__first2,__comp));
return;
};};
typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __l2=(__len/2);
__xcodeml_template_type_0_1 __m=(__first1,__l2);
(__xcodeml_template_type_0_0(__first1,__m,__comp,__l2,__first2,__l2));
(__xcodeml_template_type_0_0(__m,__last1,__comp,(__len,__l2),(__first2,__l2),(__len,__l2)));
(__xcodeml_template_type_0_0(__first1,__m,__m,__last1,__first2,__comp));
}
template<typename __xcodeml_template_type_0_0>class __stable_sort_switch{public:static unsigned int const value=(128*is_trivially_copy_assignable<__xcodeml_template_type_0_0>::value);
}
;
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void __stable_sort(__xcodeml_template_type_0_1 __first,__xcodeml_template_type_0_1 __last,__xcodeml_template_type_0_0 __comp,typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __len,typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*__buff),long __buff_size){typedef typename iterator_traits<__xcodeml_template_type_0_1>::value_type value_type;
typedef typename iterator_traits<__xcodeml_template_type_0_1>::difference_type difference_type;
switch(__len){case 0:case 1:return;
case 2:if((__comp((*(--__last)),(*__first)))){(((*__first),(*__last)));};
return;
};
if((__len,static_cast<typename iterator_traits<__xcodeml_template_type_0_1>::difference_type>(__stable_sort_switch<typename iterator_traits<__xcodeml_template_type_0_1>::value_type>::value))){{(__xcodeml_template_type_0_0(__first,__last,__comp));
return;
};};
typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __l2=(__len/2);
__xcodeml_template_type_0_1 __m=(__first,__l2);
if((__len,__buff_size)){{class::std::__1::__destruct_n __d(0);
unique_ptr<typename iterator_traits<__xcodeml_template_type_0_1>::value_type,class::std::__1::__destruct_n&> =__buff __d;
(__xcodeml_template_type_0_0(__first,__m,__comp,__l2,__buff));
(__d(__l2,((typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*))0)));
(__xcodeml_template_type_0_0(__m,__last,__comp,(__len,__l2),(__buff,__l2)));
(__d(__len,((typename iterator_traits<__xcodeml_template_type_0_1>::value_type(*))0)));
(__xcodeml_template_type_0_0(__buff,(__buff,__l2),(__buff,__l2),(__buff,__len),__first,__comp));
return;
};};
(__xcodeml_template_type_0_0(__first,__m,__comp,__l2,__buff,__buff_size));
(__xcodeml_template_type_0_0(__m,__last,__comp,(__len,__l2),__buff,__buff_size));
(__xcodeml_template_type_0_0(__first,__m,__last,__comp,__l2,(__len,__l2),__buff,__buff_size));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void stable_sort(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __comp){typedef typename iterator_traits<__xcodeml_template_type_0_0>::value_type value_type;
typedef typename iterator_traits<__xcodeml_template_type_0_0>::difference_type difference_type;
typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __len=(__last,__first);
pair<typename iterator_traits<__xcodeml_template_type_0_0>::value_type(*),long> =0 0;
unique_ptr<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,class::std::__1::__return_temporary_buffer>;
if((__len,static_cast<typename iterator_traits<__xcodeml_template_type_0_0>::difference_type>(__stable_sort_switch<typename iterator_traits<__xcodeml_template_type_0_0>::value_type>::value))){{(__buf=(std::__1::typename iterator_traits<__xcodeml_template_type_0_0>::value_type(__len)));
(__h.reset(__buf.first));
};};
typedef typename __comp_ref_type<__xcodeml_template_type_0_1>::type _Comp_ref;
(typename __comp_ref_type<__xcodeml_template_type_0_1>::type(__first,__last,__comp,__len,__buf.first,__buf.second));
}
template<typename __xcodeml_template_type_0_0>void stable_sort(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last){(std::__1::(__first,__last,__xcodeml_identity<__less<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_0>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_0 is_heap_until(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __comp){typedef typename iterator_traits<__xcodeml_template_type_0_0>::difference_type difference_type;
typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __len=(__last,__first);
typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __p=0;
typename iterator_traits<__xcodeml_template_type_0_0>::difference_type __c=1;
__xcodeml_template_type_0_0 __pp=__first;
while((__c,__len)){{__xcodeml_template_type_0_0 __cp=(__first,__c);
if((__comp((*__pp),(*__cp)))){return __cp;};
(++__c);
(++__cp);
if((__c,__len)){return __last;};
if((__comp((*__pp),(*__cp)))){return __cp;};
(++__p);
(++__pp);
(__c=((2*__p),1));
};};
return __last;
}
template<typename __xcodeml_template_type_0_0>__xcodeml_template_type_0_0 is_heap_until(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last){return(std::__1::(__first,__last,__xcodeml_identity<__less<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_0>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool is_heap(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __comp){return((std::__1::(__first,__last,__comp)),__last);
}
template<typename __xcodeml_template_type_0_0>bool is_heap(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last){return(std::__1::(__first,__last,__xcodeml_identity<__less<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_0>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void __sift_up(__xcodeml_template_type_0_1 __first,__xcodeml_template_type_0_1 __last,__xcodeml_template_type_0_0 __comp,typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __len){typedef typename iterator_traits<__xcodeml_template_type_0_1>::value_type value_type;
if((__len,1)){{(__len=((__len,2)/2));
__xcodeml_template_type_0_1 __ptr=(__first,__len);
if((__comp((*__ptr),(*(--__last))))){{typename iterator_traits<__xcodeml_template_type_0_1>::value_type __t=(std::__1::((*__last)));
do{{((*__last)=(std::__1::((*__ptr))));
(__last=__ptr);
if((__len,0)){break;};
(__len=((__len,1)/2));
(__ptr=(__first,__len));
};}while((__comp((*__ptr),__t)));
((*__last)=(std::__1::(__t)));
};};
};};
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void push_heap(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __comp){typedef typename __comp_ref_type<__xcodeml_template_type_0_1>::type _Comp_ref;
(typename __comp_ref_type<__xcodeml_template_type_0_1>::type(__first,__last,__comp,(__last,__first)));
}
template<typename __xcodeml_template_type_0_0>void push_heap(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last){(std::__1::(__first,__last,__xcodeml_identity<__less<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_0>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void __sift_down(__xcodeml_template_type_0_1 __first,__xcodeml_template_type_0_1,__xcodeml_template_type_0_0 __comp,typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __len,__xcodeml_template_type_0_1 __start){typedef typename iterator_traits<__xcodeml_template_type_0_1>::difference_type difference_type;
typedef typename iterator_traits<__xcodeml_template_type_0_1>::value_type value_type;
typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __child=(__start,__first);
if(((__len,2)||(((__len,2)/2),__child))){return;};
(__child=((2*__child),1));
__xcodeml_template_type_0_1 __child_i=(__first,__child);
if((((__child,1),__len)&&(__comp((*__child_i),(*(__child_i,1)))))){{(++__child_i);
(++__child);
};};
if((__comp((*__child_i),(*__start)))){return;};
typename iterator_traits<__xcodeml_template_type_0_1>::value_type __top=(std::__1::((*__start)));
do{{((*__start)=(std::__1::((*__child_i))));
(__start=__child_i);
if((((__len,2)/2),__child)){break;};
(__child=((2*__child),1));
(__child_i=(__first,__child));
if((((__child,1),__len)&&(__comp((*__child_i),(*(__child_i,1)))))){{(++__child_i);
(++__child);
};};
};}while((!(__comp((*__child_i),__top))));
((*__start)=(std::__1::(__top)));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void __pop_heap(__xcodeml_template_type_0_1 __first,__xcodeml_template_type_0_1 __last,__xcodeml_template_type_0_0 __comp,typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __len){if((__len,1)){{(((*__first),(*(--__last))));
(__xcodeml_template_type_0_0(__first,__last,__comp,(__len,1),__first));
};};
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void pop_heap(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __comp){typedef typename __comp_ref_type<__xcodeml_template_type_0_1>::type _Comp_ref;
(typename __comp_ref_type<__xcodeml_template_type_0_1>::type(__first,__last,__comp,(__last,__first)));
}
template<typename __xcodeml_template_type_0_0>void pop_heap(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last){(std::__1::(__first,__last,__xcodeml_identity<__less<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_0>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void __make_heap(__xcodeml_template_type_0_1 __first,__xcodeml_template_type_0_1 __last,__xcodeml_template_type_0_0 __comp){typedef typename iterator_traits<__xcodeml_template_type_0_1>::difference_type difference_type;
typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __n=(__last,__first);
if((__n,1)){{{typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __start=((__n,2)/2);for(;(__start,0);(--__start)){{(__xcodeml_template_type_0_0(__first,__last,__comp,__n,(__first,__start)));
};}};
};};
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void make_heap(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __comp){typedef typename __comp_ref_type<__xcodeml_template_type_0_1>::type _Comp_ref;
(typename __comp_ref_type<__xcodeml_template_type_0_1>::type(__first,__last,__comp));
}
template<typename __xcodeml_template_type_0_0>void make_heap(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last){(std::__1::(__first,__last,__xcodeml_identity<__less<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_0>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void __sort_heap(__xcodeml_template_type_0_1 __first,__xcodeml_template_type_0_1 __last,__xcodeml_template_type_0_0 __comp){typedef typename iterator_traits<__xcodeml_template_type_0_1>::difference_type difference_type;
{typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __n=(__last,__first);for(;(__n,1);((--__last),(--__n))){(__xcodeml_template_type_0_0(__first,__last,__comp,__n));}};
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void sort_heap(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __comp){typedef typename __comp_ref_type<__xcodeml_template_type_0_1>::type _Comp_ref;
(typename __comp_ref_type<__xcodeml_template_type_0_1>::type(__first,__last,__comp));
}
template<typename __xcodeml_template_type_0_0>void sort_heap(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last){(std::__1::(__first,__last,__xcodeml_identity<__less<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_0>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void __partial_sort(__xcodeml_template_type_0_1 __first,__xcodeml_template_type_0_1 __middle,__xcodeml_template_type_0_1 __last,__xcodeml_template_type_0_0 __comp){(__xcodeml_template_type_0_0(__first,__middle,__comp));
typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __len=(__middle,__first);
{__xcodeml_template_type_0_1 __i=__middle;for(;(__i,__last);(++__i)){{if((__comp((*__i),(*__first)))){{(((*__i),(*__first)));
(__xcodeml_template_type_0_0(__first,__middle,__comp,__len,__first));
};};
};}};
(__xcodeml_template_type_0_0(__first,__middle,__comp));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void partial_sort(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __middle,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __comp){typedef typename __comp_ref_type<__xcodeml_template_type_0_1>::type _Comp_ref;
(typename __comp_ref_type<__xcodeml_template_type_0_1>::type(__first,__middle,__last,__comp));
}
template<typename __xcodeml_template_type_0_0>void partial_sort(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __middle,__xcodeml_template_type_0_0 __last){(std::__1::(__first,__middle,__last,__xcodeml_identity<__less<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_0>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__xcodeml_template_type_0_2 __partial_sort_copy(__xcodeml_template_type_0_1 __first,__xcodeml_template_type_0_1 __last,__xcodeml_template_type_0_2 __result_first,__xcodeml_template_type_0_2 __result_last,__xcodeml_template_type_0_0 __comp){__xcodeml_template_type_0_2 __r=__result_first;
if((__r,__result_last)){{{;for(;((__first,__last)&&(__r,__result_last));(((void)(++__first)),(++__r))){((*__r)=(*__first));}};
(__xcodeml_template_type_0_0(__result_first,__r,__comp));
typename iterator_traits<__xcodeml_template_type_0_2>::difference_type __len=(__r,__result_first);
{;for(;(__first,__last);(++__first)){if((__comp((*__first),(*__result_first)))){{((*__result_first)=(*__first));
(__xcodeml_template_type_0_0(__result_first,__r,__comp,__len,__result_first));
};};}};
(__xcodeml_template_type_0_0(__result_first,__r,__comp));
};};
return __r;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__xcodeml_template_type_0_1 partial_sort_copy(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __result_first,__xcodeml_template_type_0_1 __result_last,__xcodeml_template_type_0_2 __comp){typedef typename __comp_ref_type<__xcodeml_template_type_0_2>::type _Comp_ref;
return(typename __comp_ref_type<__xcodeml_template_type_0_2>::type(__first,__last,__result_first,__result_last,__comp));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__xcodeml_template_type_0_1 partial_sort_copy(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __result_first,__xcodeml_template_type_0_1 __result_last){return(std::__1::(__first,__last,__result_first,__result_last,__xcodeml_identity<__less<typename iterator_traits<__xcodeml_template_type_0_1>::value_type,typename iterator_traits<__xcodeml_template_type_0_1>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void __nth_element(__xcodeml_template_type_0_1 __first,__xcodeml_template_type_0_1 __nth,__xcodeml_template_type_0_1 __last,__xcodeml_template_type_0_0 __comp){typedef typename iterator_traits<__xcodeml_template_type_0_1>::difference_type difference_type;
typename iterator_traits<__xcodeml_template_type_0_1>::difference_type const __limit=7;
while(true){{__restart:if((__nth,__last)){return;};
typename iterator_traits<__xcodeml_template_type_0_1>::difference_type __len=(__last,__first);
switch(__len){case 0:case 1:return;
case 2:if((__comp((*(--__last)),(*__first)))){(((*__first),(*__last)));};
return;
case 3:{__xcodeml_template_type_0_1 __m=__first;
(std::__1::__xcodeml_template_type_0_0(__first,(++__m),(--__last),__comp));
return;
};
};
if((__len,__limit)){{(__xcodeml_template_type_0_0(__first,__last,__comp));
return;
};};
__xcodeml_template_type_0_1 __m=(__first,(__len/2));
__xcodeml_template_type_0_1 __lm1=__last;
unsigned int __n_swaps=(std::__1::__xcodeml_template_type_0_0(__first,__m,(--__lm1),__comp));
__xcodeml_template_type_0_1 __i=__first;
__xcodeml_template_type_0_1 __j=__lm1;
if((!(__comp((*__i),(*__m))))){{while(true){{if((__i,(--__j))){{(++__i);
(__j=__last);
if((!(__comp((*__first),(*(--__j)))))){{while(true){{if((__i,__j)){return;};
if((__comp((*__first),(*__i)))){{(((*__i),(*__j)));
(++__n_swaps);
(++__i);
break;
};};
(++__i);
};};
};};
if((__i,__j)){return;};
while(true){{while((!(__comp((*__first),(*__i))))){(++__i);};
while((__comp((*__first),(*(--__j))))){;};
if((__i,__j)){break;};
(((*__i),(*__j)));
(++__n_swaps);
(++__i);
};};
if((__nth,__i)){return;};
(__first=__i);
goto __restart;
};};
if((__comp((*__j),(*__m)))){{(((*__i),(*__j)));
(++__n_swaps);
break;
};};
};};
};};
(++__i);
if((__i,__j)){{while(true){{while((__comp((*__i),(*__m)))){(++__i);};
while((!(__comp((*(--__j)),(*__m))))){;};
if((__i,__j)){break;};
(((*__i),(*__j)));
(++__n_swaps);
if((__m,__i)){(__m=__j);};
(++__i);
};};
};};
if(((__i,__m)&&(__comp((*__m),(*__i))))){{(((*__i),(*__m)));
(++__n_swaps);
};};
if((__nth,__i)){return;};
if((__n_swaps==0)){{if((__nth,__i)){{(__j=(__m=__first));
while(((++__j),__i)){{if((__comp((*__j),(*__m)))){goto not_sorted;};
(__m=__j);
};};
return;
};}else{{(__j=(__m=__i));
while(((++__j),__last)){{if((__comp((*__j),(*__m)))){goto not_sorted;};
(__m=__j);
};};
return;
};};
};};
not_sorted:if((__nth,__i)){{(__last=__i);
};}else{{(__first=(++__i));
};};
};};
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void nth_element(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __nth,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __comp){typedef typename __comp_ref_type<__xcodeml_template_type_0_1>::type _Comp_ref;
(typename __comp_ref_type<__xcodeml_template_type_0_1>::type(__first,__nth,__last,__comp));
}
template<typename __xcodeml_template_type_0_0>void nth_element(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __nth,__xcodeml_template_type_0_0 __last){(std::__1::(__first,__nth,__last,__xcodeml_identity<__less<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_0>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>bool __includes(__xcodeml_template_type_0_1 __first1,__xcodeml_template_type_0_1 __last1,__xcodeml_template_type_0_2 __first2,__xcodeml_template_type_0_2 __last2,__xcodeml_template_type_0_0 __comp){{;for(;(__first2,__last2);(++__first1)){{if(((__first1,__last1)||(__comp((*__first2),(*__first1))))){return false;};
if((!(__comp((*__first1),(*__first2))))){(++__first2);};
};}};
return true;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>bool includes(__xcodeml_template_type_0_0 __first1,__xcodeml_template_type_0_0 __last1,__xcodeml_template_type_0_1 __first2,__xcodeml_template_type_0_1 __last2,__xcodeml_template_type_0_2 __comp){typedef typename __comp_ref_type<__xcodeml_template_type_0_2>::type _Comp_ref;
return(typename __comp_ref_type<__xcodeml_template_type_0_2>::type(__first1,__last1,__first2,__last2,__comp));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool includes(__xcodeml_template_type_0_0 __first1,__xcodeml_template_type_0_0 __last1,__xcodeml_template_type_0_1 __first2,__xcodeml_template_type_0_1 __last2){return(std::__1::(__first1,__last1,__first2,__last2,__xcodeml_identity<__less<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_1>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>__xcodeml_template_type_0_3 __set_union(__xcodeml_template_type_0_1 __first1,__xcodeml_template_type_0_1 __last1,__xcodeml_template_type_0_2 __first2,__xcodeml_template_type_0_2 __last2,__xcodeml_template_type_0_3 __result,__xcodeml_template_type_0_0 __comp){{;for(;(__first1,__last1);(++__result)){{if((__first2,__last2)){return(std::__1::(__first1,__last1,__result));};
if((__comp((*__first2),(*__first1)))){{((*__result)=(*__first2));
(++__first2);
};}else{{if((!(__comp((*__first1),(*__first2))))){(++__first2);};
((*__result)=(*__first1));
(++__first1);
};};
};}};
return(std::__1::(__first2,__last2,__result));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>__xcodeml_template_type_0_2 set_union(__xcodeml_template_type_0_0 __first1,__xcodeml_template_type_0_0 __last1,__xcodeml_template_type_0_1 __first2,__xcodeml_template_type_0_1 __last2,__xcodeml_template_type_0_2 __result,__xcodeml_template_type_0_3 __comp){typedef typename __comp_ref_type<__xcodeml_template_type_0_3>::type _Comp_ref;
return(typename __comp_ref_type<__xcodeml_template_type_0_3>::type(__first1,__last1,__first2,__last2,__result,__comp));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__xcodeml_template_type_0_2 set_union(__xcodeml_template_type_0_0 __first1,__xcodeml_template_type_0_0 __last1,__xcodeml_template_type_0_1 __first2,__xcodeml_template_type_0_1 __last2,__xcodeml_template_type_0_2 __result){return(std::__1::(__first1,__last1,__first2,__last2,__result,__xcodeml_identity<__less<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_1>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>__xcodeml_template_type_0_3 __set_intersection(__xcodeml_template_type_0_1 __first1,__xcodeml_template_type_0_1 __last1,__xcodeml_template_type_0_2 __first2,__xcodeml_template_type_0_2 __last2,__xcodeml_template_type_0_3 __result,__xcodeml_template_type_0_0 __comp){while(((__first1,__last1)&&(__first2,__last2))){{if((__comp((*__first1),(*__first2)))){(++__first1);}else{{if((!(__comp((*__first2),(*__first1))))){{((*__result)=(*__first1));
(++__result);
(++__first1);
};};
(++__first2);
};};
};};
return __result;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>__xcodeml_template_type_0_2 set_intersection(__xcodeml_template_type_0_0 __first1,__xcodeml_template_type_0_0 __last1,__xcodeml_template_type_0_1 __first2,__xcodeml_template_type_0_1 __last2,__xcodeml_template_type_0_2 __result,__xcodeml_template_type_0_3 __comp){typedef typename __comp_ref_type<__xcodeml_template_type_0_3>::type _Comp_ref;
return(typename __comp_ref_type<__xcodeml_template_type_0_3>::type(__first1,__last1,__first2,__last2,__result,__comp));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__xcodeml_template_type_0_2 set_intersection(__xcodeml_template_type_0_0 __first1,__xcodeml_template_type_0_0 __last1,__xcodeml_template_type_0_1 __first2,__xcodeml_template_type_0_1 __last2,__xcodeml_template_type_0_2 __result){return(std::__1::(__first1,__last1,__first2,__last2,__result,__xcodeml_identity<__less<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_1>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>__xcodeml_template_type_0_3 __set_difference(__xcodeml_template_type_0_1 __first1,__xcodeml_template_type_0_1 __last1,__xcodeml_template_type_0_2 __first2,__xcodeml_template_type_0_2 __last2,__xcodeml_template_type_0_3 __result,__xcodeml_template_type_0_0 __comp){while((__first1,__last1)){{if((__first2,__last2)){return(std::__1::(__first1,__last1,__result));};
if((__comp((*__first1),(*__first2)))){{((*__result)=(*__first1));
(++__result);
(++__first1);
};}else{{if((!(__comp((*__first2),(*__first1))))){(++__first1);};
(++__first2);
};};
};};
return __result;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>__xcodeml_template_type_0_2 set_difference(__xcodeml_template_type_0_0 __first1,__xcodeml_template_type_0_0 __last1,__xcodeml_template_type_0_1 __first2,__xcodeml_template_type_0_1 __last2,__xcodeml_template_type_0_2 __result,__xcodeml_template_type_0_3 __comp){typedef typename __comp_ref_type<__xcodeml_template_type_0_3>::type _Comp_ref;
return(typename __comp_ref_type<__xcodeml_template_type_0_3>::type(__first1,__last1,__first2,__last2,__result,__comp));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__xcodeml_template_type_0_2 set_difference(__xcodeml_template_type_0_0 __first1,__xcodeml_template_type_0_0 __last1,__xcodeml_template_type_0_1 __first2,__xcodeml_template_type_0_1 __last2,__xcodeml_template_type_0_2 __result){return(std::__1::(__first1,__last1,__first2,__last2,__result,__xcodeml_identity<__less<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_1>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>__xcodeml_template_type_0_3 __set_symmetric_difference(__xcodeml_template_type_0_1 __first1,__xcodeml_template_type_0_1 __last1,__xcodeml_template_type_0_2 __first2,__xcodeml_template_type_0_2 __last2,__xcodeml_template_type_0_3 __result,__xcodeml_template_type_0_0 __comp){while((__first1,__last1)){{if((__first2,__last2)){return(std::__1::(__first1,__last1,__result));};
if((__comp((*__first1),(*__first2)))){{((*__result)=(*__first1));
(++__result);
(++__first1);
};}else{{if((__comp((*__first2),(*__first1)))){{((*__result)=(*__first2));
(++__result);
};}else{(++__first1);};
(++__first2);
};};
};};
return(std::__1::(__first2,__last2,__result));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2,typename __xcodeml_template_type_0_3>__xcodeml_template_type_0_2 set_symmetric_difference(__xcodeml_template_type_0_0 __first1,__xcodeml_template_type_0_0 __last1,__xcodeml_template_type_0_1 __first2,__xcodeml_template_type_0_1 __last2,__xcodeml_template_type_0_2 __result,__xcodeml_template_type_0_3 __comp){typedef typename __comp_ref_type<__xcodeml_template_type_0_3>::type _Comp_ref;
return(typename __comp_ref_type<__xcodeml_template_type_0_3>::type(__first1,__last1,__first2,__last2,__result,__comp));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>__xcodeml_template_type_0_2 set_symmetric_difference(__xcodeml_template_type_0_0 __first1,__xcodeml_template_type_0_0 __last1,__xcodeml_template_type_0_1 __first2,__xcodeml_template_type_0_1 __last2,__xcodeml_template_type_0_2 __result){return(std::__1::(__first1,__last1,__first2,__last2,__result,__xcodeml_identity<__less<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_1>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>bool __lexicographical_compare(__xcodeml_template_type_0_1 __first1,__xcodeml_template_type_0_1 __last1,__xcodeml_template_type_0_2 __first2,__xcodeml_template_type_0_2 __last2,__xcodeml_template_type_0_0 __comp){{;for(;(__first2,__last2);((++__first1),((void)(++__first2)))){{if(((__first1,__last1)||(__comp((*__first1),(*__first2))))){return true;};
if((__comp((*__first2),(*__first1)))){return false;};
};}};
return false;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1,typename __xcodeml_template_type_0_2>bool lexicographical_compare(__xcodeml_template_type_0_0 __first1,__xcodeml_template_type_0_0 __last1,__xcodeml_template_type_0_1 __first2,__xcodeml_template_type_0_1 __last2,__xcodeml_template_type_0_2 __comp){typedef typename __comp_ref_type<__xcodeml_template_type_0_2>::type _Comp_ref;
return(typename __comp_ref_type<__xcodeml_template_type_0_2>::type(__first1,__last1,__first2,__last2,__comp));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool lexicographical_compare(__xcodeml_template_type_0_0 __first1,__xcodeml_template_type_0_0 __last1,__xcodeml_template_type_0_1 __first2,__xcodeml_template_type_0_1 __last2){return(std::__1::(__first1,__last1,__first2,__last2,__xcodeml_identity<__less<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_1>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool __next_permutation(__xcodeml_template_type_0_1 __first,__xcodeml_template_type_0_1 __last,__xcodeml_template_type_0_0 __comp){__xcodeml_template_type_0_1 __i=__last;
if(((__first,__last)||(__first,(--__i)))){return false;};
while(true){{__xcodeml_template_type_0_1 __ip1=__i;
if((__comp((*(--__i)),(*__ip1)))){{__xcodeml_template_type_0_1 __j=__last;
while((!(__comp((*__i),(*(--__j)))))){;};
(((*__i),(*__j)));
(std::__1::(__ip1,__last));
return true;
};};
if((__i,__first)){{(std::__1::(__first,__last));
return false;
};};
};};
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool next_permutation(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __comp){typedef typename __comp_ref_type<__xcodeml_template_type_0_1>::type _Comp_ref;
return(typename __comp_ref_type<__xcodeml_template_type_0_1>::type(__first,__last,__comp));
}
template<typename __xcodeml_template_type_0_0>bool next_permutation(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last){return(std::__1::(__first,__last,__xcodeml_identity<__less<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_0>::value_type> >::t()));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool __prev_permutation(__xcodeml_template_type_0_1 __first,__xcodeml_template_type_0_1 __last,__xcodeml_template_type_0_0 __comp){__xcodeml_template_type_0_1 __i=__last;
if(((__first,__last)||(__first,(--__i)))){return false;};
while(true){{__xcodeml_template_type_0_1 __ip1=__i;
if((__comp((*__ip1),(*(--__i))))){{__xcodeml_template_type_0_1 __j=__last;
while((!(__comp((*(--__j)),(*__i))))){;};
(((*__i),(*__j)));
(std::__1::(__ip1,__last));
return true;
};};
if((__i,__first)){{(std::__1::(__first,__last));
return false;
};};
};};
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool prev_permutation(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last,__xcodeml_template_type_0_1 __comp){typedef typename __comp_ref_type<__xcodeml_template_type_0_1>::type _Comp_ref;
return(typename __comp_ref_type<__xcodeml_template_type_0_1>::type(__first,__last,__comp));
}
template<typename __xcodeml_template_type_0_0>bool prev_permutation(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last){return(std::__1::(__first,__last,__xcodeml_identity<__less<typename iterator_traits<__xcodeml_template_type_0_0>::value_type,typename iterator_traits<__xcodeml_template_type_0_0>::value_type> >::t()));
}
}
}
namespace std{namespace __1{template<typename __xcodeml_template_type_0_0,bool _IsConst,typename __xcodeml_template_type_0_0::__storage_type=0>class __bit_iterator;
;
template<typename __xcodeml_template_type_0_0>class __bit_const_reference;
;
template<typename __xcodeml_template_type_0_0>class __has_storage_type{public:static bool const value=false;
}
;
;
template<typename __xcodeml_template_type_0_0,bool=__has_storage_type<__xcodeml_template_type_0_0>::value>class __bit_reference{private:typedef typename __xcodeml_template_type_0_0::__storage_type __storage_type;
private:typedef typename __xcodeml_template_type_0_0::__storage_pointer __storage_pointer;
private:typename __xcodeml_template_type_0_0::__storage_pointer __seg_;
private:typename __xcodeml_template_type_0_0::__storage_type __mask_;
public:friend typename __xcodeml_template_type_0_0::__self;
public:friend __bit_const_reference<__xcodeml_template_type_0_0>;
public:friend __bit_iterator<__xcodeml_template_type_0_0,0,expression>;
public:
public:operator bool()const{return static_cast<bool>(((*this->__seg_)&this->__mask_));
}
public:bool operator~()const{return(!static_cast<bool>((*this)));
}
public:class __bit_reference&operator=(bool __x){if(__x){((*this->__seg_)|=this->__mask_);}else{((*this->__seg_)&=(~this->__mask_));};
return(*this);
}
public:class __bit_reference&operator=(class __bit_reference const&__x){return((static_cast<bool>(__x)));
}
public:void flip(){((*this->__seg_)^=this->__mask_);
}
public:__bit_iterator<__xcodeml_template_type_0_0,0,expression>{return __xcodeml_identity<__bit_iterator<__xcodeml_template_type_0_0,0,expression> >::t(this->__seg_,static_cast<unsigned int>(((this->__mask_))));
}
private:
private:__bit_reference(typename __xcodeml_template_type_0_0::__storage_pointer __s,typename __xcodeml_template_type_0_0::__storage_type __m):__seg_(__s),__mask_(__m){}
}
;
;
template<typename __xcodeml_template_type_0_0>class __bit_reference<__xcodeml_template_type_0_0,0>{}
;
template<typename __xcodeml_template_type_0_0>void swap(__bit_reference<__xcodeml_template_type_0_0,expression>,__bit_reference<__xcodeml_template_type_0_0,expression>){bool __t=__x;
(__x=__y);
(__y=__t);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void swap(__bit_reference<__xcodeml_template_type_0_0,expression>,__bit_reference<__xcodeml_template_type_0_1,expression>){bool __t=__x;
(__x=__y);
(__y=__t);
}
template<typename __xcodeml_template_type_0_0>void swap(__bit_reference<__xcodeml_template_type_0_0,expression>,bool&__y){bool __t=__x;
(__x=__y);
(__y=__t);
}
template<typename __xcodeml_template_type_0_0>void swap(bool&__x,__bit_reference<__xcodeml_template_type_0_0,expression>){bool __t=__x;
(__x=__y);
(__y=__t);
}
template<typename __xcodeml_template_type_0_0>class __bit_const_reference{private:typedef typename __xcodeml_template_type_0_0::__storage_type __storage_type;
private:typedef typename __xcodeml_template_type_0_0::__const_storage_pointer __storage_pointer;
private:typename __xcodeml_template_type_0_0::__const_storage_pointer __seg_;
private:typename __xcodeml_template_type_0_0::__storage_type __mask_;
public:friend typename __xcodeml_template_type_0_0::__self;
public:friend __bit_iterator<__xcodeml_template_type_0_0,1,expression>;
public:
public:__bit_const_reference(__bit_reference<__xcodeml_template_type_0_0,expression>):__seg_(__x.__seg_),__mask_(__x.__mask_){}
public:operator bool()const{return static_cast<bool>(((*this->__seg_)&this->__mask_));
}
public:__bit_iterator<__xcodeml_template_type_0_0,1,expression>{return __xcodeml_identity<__bit_iterator<__xcodeml_template_type_0_0,1,expression> >::t(this->__seg_,static_cast<unsigned int>(((this->__mask_))));
}
private:
private:__bit_const_reference(typename __xcodeml_template_type_0_0::__const_storage_pointer __s,typename __xcodeml_template_type_0_0::__storage_type __m):__seg_(__s),__mask_(__m){}
private:class __bit_const_reference&operator=(class __bit_const_reference const&__x);
}
;
;
template<typename __xcodeml_template_type_0_0,bool _IsConst>__bit_iterator<__xcodeml_template_type_0_0,expression,expression>{typedef __bit_iterator<__xcodeml_template_type_0_0,expression,expression>;
typedef typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __storage_type;
static int const __bits_per_word=__bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__bits_per_word;
if((__first.__ctz_,0)){{typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __clz_f=static_cast<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>((__bits_per_word,__first.__ctz_));
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __dn=(std::__1::(__clz_f,__n));
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __m=(((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0)),__first.__ctz_)&((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0))>>(__clz_f,__dn)));
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __b=((*__first.__seg_)&__m);
if(__b){return __xcodeml_identity<__bit_iterator<__xcodeml_template_type_0_0,expression,expression> >::t(__first.__seg_,static_cast<unsigned int>((std::__1::(__b))));};
if((__n,__dn)){return(__first,__n);};
(__n-=__dn);
(++__first.__seg_);
};};
{;for(;(__n,__bits_per_word);((++__first.__seg_),(__n-=__bits_per_word))){if((*__first.__seg_)){return __xcodeml_identity<__bit_iterator<__xcodeml_template_type_0_0,expression,expression> >::t(__first.__seg_,static_cast<unsigned int>((std::__1::((*__first.__seg_)))));};}};
if((__n,0)){{typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __m=((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0))>>(__bits_per_word,__n));
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __b=((*__first.__seg_)&__m);
if(__b){return __xcodeml_identity<__bit_iterator<__xcodeml_template_type_0_0,expression,expression> >::t(__first.__seg_,static_cast<unsigned int>((std::__1::(__b))));};
};};
return __xcodeml_identity<__bit_iterator<__xcodeml_template_type_0_0,expression,expression> >::t(__first.__seg_,static_cast<unsigned int>(__n));
}
template<typename __xcodeml_template_type_0_0,bool _IsConst>__bit_iterator<__xcodeml_template_type_0_0,expression,expression>{typedef __bit_iterator<__xcodeml_template_type_0_0,expression,expression>;
typedef typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __storage_type;
int const __bits_per_word=__bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__bits_per_word;
if((__first.__ctz_,0)){{typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __clz_f=static_cast<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>((__bits_per_word,__first.__ctz_));
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __dn=(std::__1::(__clz_f,__n));
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __m=(((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0)),__first.__ctz_)&((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0))>>(__clz_f,__dn)));
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __b=((~(*__first.__seg_))&__m);
if(__b){return __xcodeml_identity<__bit_iterator<__xcodeml_template_type_0_0,expression,expression> >::t(__first.__seg_,static_cast<unsigned int>((std::__1::(__b))));};
if((__n,__dn)){return(__first,__n);};
(__n-=__dn);
(++__first.__seg_);
};};
{;for(;(__n,__bits_per_word);((++__first.__seg_),(__n-=__bits_per_word))){{typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __b=(~(*__first.__seg_));
if(__b){return __xcodeml_identity<__bit_iterator<__xcodeml_template_type_0_0,expression,expression> >::t(__first.__seg_,static_cast<unsigned int>((std::__1::(__b))));};
};}};
if((__n,0)){{typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __m=((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0))>>(__bits_per_word,__n));
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __b=((~(*__first.__seg_))&__m);
if(__b){return __xcodeml_identity<__bit_iterator<__xcodeml_template_type_0_0,expression,expression> >::t(__first.__seg_,static_cast<unsigned int>((std::__1::(__b))));};
};};
return __xcodeml_identity<__bit_iterator<__xcodeml_template_type_0_0,expression,expression> >::t(__first.__seg_,static_cast<unsigned int>(__n));
}
template<typename __xcodeml_template_type_0_0,bool _IsConst,typename __xcodeml_template_type_0_2>__bit_iterator<__xcodeml_template_type_0_0,expression,expression>{if(static_cast<bool>(__value_)){return((__first,static_cast<typename __xcodeml_template_type_0_0::size_type>((__last,__first))));};
return((__first,static_cast<typename __xcodeml_template_type_0_0::size_type>((__last,__first))));
}
template<typename __xcodeml_template_type_0_0,bool _IsConst>typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type __count_bool_true(__bit_iterator<__xcodeml_template_type_0_0,expression,expression>,typename __xcodeml_template_type_0_0::size_type __n){typedef __bit_iterator<__xcodeml_template_type_0_0,expression,expression>;
typedef typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __storage_type;
typedef typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type difference_type;
int const __bits_per_word=__bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__bits_per_word;
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type __r=0;
if((__first.__ctz_,0)){{typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __clz_f=static_cast<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>((__bits_per_word,__first.__ctz_));
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __dn=(std::__1::(__clz_f,__n));
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __m=(((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0)),__first.__ctz_)&((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0))>>(__clz_f,__dn)));
(__r=(std::__1::(((*__first.__seg_)&__m))));
(__n-=__dn);
(++__first.__seg_);
};};
{;for(;(__n,__bits_per_word);((++__first.__seg_),(__n-=__bits_per_word))){(__r+=(std::__1::((*__first.__seg_))));}};
if((__n,0)){{typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __m=((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0))>>(__bits_per_word,__n));
(__r+=(std::__1::(((*__first.__seg_)&__m))));
};};
return __r;
}
template<typename __xcodeml_template_type_0_0,bool _IsConst>typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type __count_bool_false(__bit_iterator<__xcodeml_template_type_0_0,expression,expression>,typename __xcodeml_template_type_0_0::size_type __n){typedef __bit_iterator<__xcodeml_template_type_0_0,expression,expression>;
typedef typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __storage_type;
typedef typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type difference_type;
int const __bits_per_word=__bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__bits_per_word;
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type __r=0;
if((__first.__ctz_,0)){{typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __clz_f=static_cast<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>((__bits_per_word,__first.__ctz_));
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __dn=(std::__1::(__clz_f,__n));
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __m=(((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0)),__first.__ctz_)&((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0))>>(__clz_f,__dn)));
(__r=(std::__1::(((~(*__first.__seg_))&__m))));
(__n-=__dn);
(++__first.__seg_);
};};
{;for(;(__n,__bits_per_word);((++__first.__seg_),(__n-=__bits_per_word))){(__r+=(std::__1::((~(*__first.__seg_)))));}};
if((__n,0)){{typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __m=((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0))>>(__bits_per_word,__n));
(__r+=(std::__1::(((~(*__first.__seg_))&__m))));
};};
return __r;
}
template<typename __xcodeml_template_type_0_0,bool _IsConst,typename __xcodeml_template_type_0_2>typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type count(__bit_iterator<__xcodeml_template_type_0_0,expression,expression>,__bit_iterator<__xcodeml_template_type_0_0,expression,expression>,__xcodeml_template_type_0_2 const&__value_){if(static_cast<bool>(__value_)){return((__first,static_cast<typename __xcodeml_template_type_0_0::size_type>((__last,__first))));};
return((__first,static_cast<typename __xcodeml_template_type_0_0::size_type>((__last,__first))));
}
template<typename __xcodeml_template_type_0_0>void __fill_n_false(__bit_iterator<__xcodeml_template_type_0_0,0,expression>,typename __xcodeml_template_type_0_0::size_type __n){typedef __bit_iterator<__xcodeml_template_type_0_0,0,expression>;
typedef typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type __storage_type;
int const __bits_per_word=__bit_iterator<__xcodeml_template_type_0_0,0,expression>::__bits_per_word;
if((__first.__ctz_,0)){{typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type __clz_f=static_cast<typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type>((__bits_per_word,__first.__ctz_));
typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type __dn=(std::__1::(__clz_f,__n));
typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type __m=(((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type>::t(0)),__first.__ctz_)&((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type>::t(0))>>(__clz_f,__dn)));
((*__first.__seg_)&=(~__m));
(__n-=__dn);
(++__first.__seg_);
};};
typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type __nw=(__n/__bits_per_word);
(std::__1::memset((std::__1::(__first.__seg_)),0,(__nw*(sizeof(typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type)))));
(__n-=(__nw*__bits_per_word));
if((__n,0)){{(__first.__seg_+=__nw);
typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type __m=((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type>::t(0))>>(__bits_per_word,__n));
((*__first.__seg_)&=(~__m));
};};
}
template<typename __xcodeml_template_type_0_0>void __fill_n_true(__bit_iterator<__xcodeml_template_type_0_0,0,expression>,typename __xcodeml_template_type_0_0::size_type __n){typedef __bit_iterator<__xcodeml_template_type_0_0,0,expression>;
typedef typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type __storage_type;
int const __bits_per_word=__bit_iterator<__xcodeml_template_type_0_0,0,expression>::__bits_per_word;
if((__first.__ctz_,0)){{typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type __clz_f=static_cast<typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type>((__bits_per_word,__first.__ctz_));
typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type __dn=(std::__1::(__clz_f,__n));
typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type __m=(((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type>::t(0)),__first.__ctz_)&((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type>::t(0))>>(__clz_f,__dn)));
((*__first.__seg_)|=__m);
(__n-=__dn);
(++__first.__seg_);
};};
typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type __nw=(__n/__bits_per_word);
(std::__1::memset((std::__1::(__first.__seg_)),(-1),(__nw*(sizeof(typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type)))));
(__n-=(__nw*__bits_per_word));
if((__n,0)){{(__first.__seg_+=__nw);
typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type __m=((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type>::t(0))>>(__bits_per_word,__n));
((*__first.__seg_)|=__m);
};};
}
template<typename __xcodeml_template_type_0_0>void fill_n(__bit_iterator<__xcodeml_template_type_0_0,0,expression>,typename __xcodeml_template_type_0_0::size_type __n,bool __value_){if((__n,0)){{if(__value_){((__first,__n));}else{((__first,__n));};
};};
}
template<typename __xcodeml_template_type_0_0>void fill(__bit_iterator<__xcodeml_template_type_0_0,0,expression>,__bit_iterator<__xcodeml_template_type_0_0,0,expression>,bool __value_){(std::__1::(__first,static_cast<typename __xcodeml_template_type_0_0::size_type>((__last,__first)),__value_));
}
template<typename __xcodeml_template_type_0_0,bool _IsConst>__bit_iterator<__xcodeml_template_type_0_0,0,expression>{typedef __bit_iterator<__xcodeml_template_type_0_0,expression,expression>;
typedef typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type difference_type;
typedef typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __storage_type;
int const __bits_per_word=__bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__bits_per_word;
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type __n=(__last,__first);
if((__n,0)){{if((__first.__ctz_,0)){{unsigned int __clz=(__bits_per_word,__first.__ctz_);
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type __dn=(std::__1::(static_cast<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type>(__clz),__n));
(__n-=__dn);
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __m=(((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0)),__first.__ctz_)&((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0))>>(__clz,__dn)));
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __b=((*__first.__seg_)&__m);
((*__result.__seg_)&=(~__m));
((*__result.__seg_)|=__b);
(__result.__seg_+=((__dn,__result.__ctz_)/__bits_per_word));
(__result.__ctz_=static_cast<unsigned int>(((__dn,__result.__ctz_)%__bits_per_word)));
(++__first.__seg_);
};};
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __nw=(__n/__bits_per_word);
(std::__1::memmove((std::__1::(__result.__seg_)),(std::__1::(__first.__seg_)),(__nw*(sizeof(typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type)))));
(__n-=(__nw*__bits_per_word));
(__result.__seg_+=__nw);
if((__n,0)){{(__first.__seg_+=__nw);
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __m=((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0))>>(__bits_per_word,__n));
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __b=((*__first.__seg_)&__m);
((*__result.__seg_)&=(~__m));
((*__result.__seg_)|=__b);
(__result.__ctz_=static_cast<unsigned int>(__n));
};};
};};
return __result;
}
template<typename __xcodeml_template_type_0_0,bool _IsConst>__bit_iterator<__xcodeml_template_type_0_0,0,expression>{typedef __bit_iterator<__xcodeml_template_type_0_0,expression,expression>;
typedef typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type difference_type;
typedef typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __storage_type;
static int const __bits_per_word=__bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__bits_per_word;
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type __n=(__last,__first);
if((__n,0)){{if((__first.__ctz_,0)){{unsigned int __clz_f=(__bits_per_word,__first.__ctz_);
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type __dn=(std::__1::(static_cast<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type>(__clz_f),__n));
(__n-=__dn);
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __m=(((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0)),__first.__ctz_)&((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0))>>(__clz_f,__dn)));
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __b=((*__first.__seg_)&__m);
unsigned int __clz_r=(__bits_per_word,__result.__ctz_);
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __ddn=(std::__1::typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type(__dn,__clz_r));
(__m=(((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0)),__result.__ctz_)&((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0))>>(__clz_r,__ddn))));
((*__result.__seg_)&=(~__m));
if((__result.__ctz_,__first.__ctz_)){((*__result.__seg_)|=(__b,(__result.__ctz_,__first.__ctz_)));}else{((*__result.__seg_)|=(__b>>(__first.__ctz_,__result.__ctz_)));};
(__result.__seg_+=((__ddn,__result.__ctz_)/__bits_per_word));
(__result.__ctz_=static_cast<unsigned int>(((__ddn,__result.__ctz_)%__bits_per_word)));
(__dn-=__ddn);
if((__dn,0)){{(__m=((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0))>>(__bits_per_word,__dn)));
((*__result.__seg_)&=(~__m));
((*__result.__seg_)|=(__b>>(__first.__ctz_,__ddn)));
(__result.__ctz_=static_cast<unsigned int>(__dn));
};};
(++__first.__seg_);
};};
unsigned int __clz_r=(__bits_per_word,__result.__ctz_);
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __m=((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0)),__result.__ctz_);
{;for(;(__n,__bits_per_word);((__n-=__bits_per_word),(++__first.__seg_))){{typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __b=(*__first.__seg_);
((*__result.__seg_)&=(~__m));
((*__result.__seg_)|=(__b,__result.__ctz_));
(++__result.__seg_);
((*__result.__seg_)&=__m);
((*__result.__seg_)|=(__b>>__clz_r));
};}};
if((__n,0)){{(__m=((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0))>>(__bits_per_word,__n)));
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __b=((*__first.__seg_)&__m);
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __dn=(std::__1::(__n,static_cast<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type>(__clz_r)));
(__m=(((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0)),__result.__ctz_)&((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0))>>(__clz_r,__dn))));
((*__result.__seg_)&=(~__m));
((*__result.__seg_)|=(__b,__result.__ctz_));
(__result.__seg_+=((__dn,__result.__ctz_)/__bits_per_word));
(__result.__ctz_=static_cast<unsigned int>(((__dn,__result.__ctz_)%__bits_per_word)));
(__n-=__dn);
if((__n,0)){{(__m=((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0))>>(__bits_per_word,__n)));
((*__result.__seg_)&=(~__m));
((*__result.__seg_)|=(__b>>__dn));
(__result.__ctz_=static_cast<unsigned int>(__n));
};};
};};
};};
return __result;
}
template<typename __xcodeml_template_type_0_0,bool _IsConst>__bit_iterator<__xcodeml_template_type_0_0,0,expression>{if((__first.__ctz_,__result.__ctz_)){return((__first,__last,__result));};
return((__first,__last,__result));
}
template<typename __xcodeml_template_type_0_0,bool _IsConst>__bit_iterator<__xcodeml_template_type_0_0,0,expression>{typedef __bit_iterator<__xcodeml_template_type_0_0,expression,expression>;
typedef typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type difference_type;
typedef typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __storage_type;
int const __bits_per_word=__bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__bits_per_word;
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type __n=(__last,__first);
if((__n,0)){{if((__last.__ctz_,0)){{typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type __dn=(std::__1::(static_cast<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type>(__last.__ctz_),__n));
(__n-=__dn);
unsigned int __clz=(__bits_per_word,__last.__ctz_);
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __m=(((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0)),(__last.__ctz_,__dn))&((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0))>>__clz));
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __b=((*__last.__seg_)&__m);
((*__result.__seg_)&=(~__m));
((*__result.__seg_)|=__b);
(__result.__ctz_=static_cast<unsigned int>(((((__dn)&(__bits_per_word-1)),__result.__ctz_)%__bits_per_word)));
};};
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __nw=(__n/__bits_per_word);
(__result.__seg_-=__nw);
(__last.__seg_-=__nw);
(std::__1::memmove((std::__1::(__result.__seg_)),(std::__1::(__last.__seg_)),(__nw*(sizeof(typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type)))));
(__n-=(__nw*__bits_per_word));
if((__n,0)){{typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __m=((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0)),(__bits_per_word,__n));
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __b=((*(--__last.__seg_))&__m);
((*(--__result.__seg_))&=(~__m));
((*__result.__seg_)|=__b);
(__result.__ctz_=static_cast<unsigned int>(((__n)&(__bits_per_word-1))));
};};
};};
return __result;
}
template<typename __xcodeml_template_type_0_0,bool _IsConst>__bit_iterator<__xcodeml_template_type_0_0,0,expression>{typedef __bit_iterator<__xcodeml_template_type_0_0,expression,expression>;
typedef typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type difference_type;
typedef typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __storage_type;
int const __bits_per_word=__bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__bits_per_word;
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type __n=(__last,__first);
if((__n,0)){{if((__last.__ctz_,0)){{typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type __dn=(std::__1::(static_cast<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type>(__last.__ctz_),__n));
(__n-=__dn);
unsigned int __clz_l=(__bits_per_word,__last.__ctz_);
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __m=(((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0)),(__last.__ctz_,__dn))&((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0))>>__clz_l));
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __b=((*__last.__seg_)&__m);
unsigned int __clz_r=(__bits_per_word,__result.__ctz_);
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __ddn=(std::__1::(__dn,static_cast<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type>(__result.__ctz_)));
if((__ddn,0)){{(__m=(((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0)),(__result.__ctz_,__ddn))&((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0))>>__clz_r)));
((*__result.__seg_)&=(~__m));
if((__result.__ctz_,__last.__ctz_)){((*__result.__seg_)|=(__b,(__result.__ctz_,__last.__ctz_)));}else{((*__result.__seg_)|=(__b>>(__last.__ctz_,__result.__ctz_)));};
(__result.__ctz_=static_cast<unsigned int>(((((__ddn)&(__bits_per_word-1)),__result.__ctz_)%__bits_per_word)));
(__dn-=__ddn);
};};
if((__dn,0)){{(--__result.__seg_);
(__result.__ctz_=static_cast<unsigned int>(((__dn)&(__bits_per_word-1))));
(__m=((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0)),__result.__ctz_));
((*__result.__seg_)&=(~__m));
(__last.__ctz_-=(__dn,__ddn));
((*__result.__seg_)|=(__b,(__result.__ctz_,__last.__ctz_)));
};};
};};
unsigned int __clz_r=(__bits_per_word,__result.__ctz_);
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __m=((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0))>>__clz_r);
{;for(;(__n,__bits_per_word);(__n-=__bits_per_word)){{typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __b=(*(--__last.__seg_));
((*__result.__seg_)&=(~__m));
((*__result.__seg_)|=(__b>>__clz_r));
((*(--__result.__seg_))&=__m);
((*__result.__seg_)|=(__b,__result.__ctz_));
};}};
if((__n,0)){{(__m=((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0)),(__bits_per_word,__n)));
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __b=((*(--__last.__seg_))&__m);
(__clz_r=(__bits_per_word,__result.__ctz_));
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __dn=(std::__1::(__n,static_cast<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type>(__result.__ctz_)));
(__m=(((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0)),(__result.__ctz_,__dn))&((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0))>>__clz_r)));
((*__result.__seg_)&=(~__m));
((*__result.__seg_)|=(__b>>(__bits_per_word,__result.__ctz_)));
(__result.__ctz_=static_cast<unsigned int>(((((__dn)&(__bits_per_word-1)),__result.__ctz_)%__bits_per_word)));
(__n-=__dn);
if((__n,0)){{(--__result.__seg_);
(__result.__ctz_=static_cast<unsigned int>(((__n)&(__bits_per_word-1))));
(__m=((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0)),__result.__ctz_));
((*__result.__seg_)&=(~__m));
((*__result.__seg_)|=(__b,(__result.__ctz_,((__bits_per_word,__n),__dn))));
};};
};};
};};
return __result;
}
template<typename __xcodeml_template_type_0_0,bool _IsConst>__bit_iterator<__xcodeml_template_type_0_0,0,expression>{if((__last.__ctz_,__result.__ctz_)){return((__first,__last,__result));};
return((__first,__last,__result));
}
template<typename __xcodeml_template_type_0_0,bool _IsConst>__bit_iterator<__xcodeml_template_type_0_0,0,expression>{return(std::__1::(__first,__last,__result));
}
template<typename __xcodeml_template_type_0_0,bool _IsConst>__bit_iterator<__xcodeml_template_type_0_0,0,expression>{return(std::__1::(__first,__last,__result));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__bit_iterator<__xcodeml_template_type_0_1,0,expression>{typedef __bit_iterator<__xcodeml_template_type_0_0,0,expression>;
typedef typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::difference_type difference_type;
typedef typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type __storage_type;
int const __bits_per_word=__bit_iterator<__xcodeml_template_type_0_0,0,expression>::__bits_per_word;
typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::difference_type __n=(__last,__first);
if((__n,0)){{if((__first.__ctz_,0)){{unsigned int __clz=(__bits_per_word,__first.__ctz_);
typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::difference_type __dn=(std::__1::(static_cast<typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::difference_type>(__clz),__n));
(__n-=__dn);
typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type __m=(((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type>::t(0)),__first.__ctz_)&((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type>::t(0))>>(__clz,__dn)));
typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type __b1=((*__first.__seg_)&__m);
((*__first.__seg_)&=(~__m));
typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type __b2=((*__result.__seg_)&__m);
((*__result.__seg_)&=(~__m));
((*__result.__seg_)|=__b1);
((*__first.__seg_)|=__b2);
(__result.__seg_+=((__dn,__result.__ctz_)/__bits_per_word));
(__result.__ctz_=static_cast<unsigned int>(((__dn,__result.__ctz_)%__bits_per_word)));
(++__first.__seg_);
};};
{;for(;(__n,__bits_per_word);(((__n-=__bits_per_word),(++__first.__seg_)),(++__result.__seg_))){(((*__first.__seg_),(*__result.__seg_)));}};
if((__n,0)){{typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type __m=((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type>::t(0))>>(__bits_per_word,__n));
typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type __b1=((*__first.__seg_)&__m);
((*__first.__seg_)&=(~__m));
typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type __b2=((*__result.__seg_)&__m);
((*__result.__seg_)&=(~__m));
((*__result.__seg_)|=__b1);
((*__first.__seg_)|=__b2);
(__result.__ctz_=static_cast<unsigned int>(__n));
};};
};};
return __result;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__bit_iterator<__xcodeml_template_type_0_1,0,expression>{typedef __bit_iterator<__xcodeml_template_type_0_0,0,expression>;
typedef typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::difference_type difference_type;
typedef typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type __storage_type;
int const __bits_per_word=__bit_iterator<__xcodeml_template_type_0_0,0,expression>::__bits_per_word;
typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::difference_type __n=(__last,__first);
if((__n,0)){{if((__first.__ctz_,0)){{unsigned int __clz_f=(__bits_per_word,__first.__ctz_);
typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::difference_type __dn=(std::__1::(static_cast<typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::difference_type>(__clz_f),__n));
(__n-=__dn);
typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type __m=(((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type>::t(0)),__first.__ctz_)&((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type>::t(0))>>(__clz_f,__dn)));
typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type __b1=((*__first.__seg_)&__m);
((*__first.__seg_)&=(~__m));
unsigned int __clz_r=(__bits_per_word,__result.__ctz_);
typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type __ddn=(std::__1::typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type(__dn,__clz_r));
(__m=(((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type>::t(0)),__result.__ctz_)&((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type>::t(0))>>(__clz_r,__ddn))));
typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type __b2=((*__result.__seg_)&__m);
((*__result.__seg_)&=(~__m));
if((__result.__ctz_,__first.__ctz_)){{unsigned int __s=(__result.__ctz_,__first.__ctz_);
((*__result.__seg_)|=(__b1,__s));
((*__first.__seg_)|=(__b2>>__s));
};}else{{unsigned int __s=(__first.__ctz_,__result.__ctz_);
((*__result.__seg_)|=(__b1>>__s));
((*__first.__seg_)|=(__b2,__s));
};};
(__result.__seg_+=((__ddn,__result.__ctz_)/__bits_per_word));
(__result.__ctz_=static_cast<unsigned int>(((__ddn,__result.__ctz_)%__bits_per_word)));
(__dn-=__ddn);
if((__dn,0)){{(__m=((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type>::t(0))>>(__bits_per_word,__dn)));
(__b2=((*__result.__seg_)&__m));
((*__result.__seg_)&=(~__m));
unsigned int __s=(__first.__ctz_,__ddn);
((*__result.__seg_)|=(__b1>>__s));
((*__first.__seg_)|=(__b2,__s));
(__result.__ctz_=static_cast<unsigned int>(__dn));
};};
(++__first.__seg_);
};};
typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type __m=((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type>::t(0)),__result.__ctz_);
unsigned int __clz_r=(__bits_per_word,__result.__ctz_);
{;for(;(__n,__bits_per_word);((__n-=__bits_per_word),(++__first.__seg_))){{typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type __b1=(*__first.__seg_);
typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type __b2=((*__result.__seg_)&__m);
((*__result.__seg_)&=(~__m));
((*__result.__seg_)|=(__b1,__result.__ctz_));
((*__first.__seg_)=(__b2>>__result.__ctz_));
(++__result.__seg_);
(__b2=((*__result.__seg_)&(~__m)));
((*__result.__seg_)&=__m);
((*__result.__seg_)|=(__b1>>__clz_r));
((*__first.__seg_)|=(__b2,__clz_r));
};}};
if((__n,0)){{(__m=((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type>::t(0))>>(__bits_per_word,__n)));
typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type __b1=((*__first.__seg_)&__m);
((*__first.__seg_)&=(~__m));
typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type __dn=(std::__1::typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type(__n,__clz_r));
(__m=(((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type>::t(0)),__result.__ctz_)&((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type>::t(0))>>(__clz_r,__dn))));
typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type __b2=((*__result.__seg_)&__m);
((*__result.__seg_)&=(~__m));
((*__result.__seg_)|=(__b1,__result.__ctz_));
((*__first.__seg_)|=(__b2>>__result.__ctz_));
(__result.__seg_+=((__dn,__result.__ctz_)/__bits_per_word));
(__result.__ctz_=static_cast<unsigned int>(((__dn,__result.__ctz_)%__bits_per_word)));
(__n-=__dn);
if((__n,0)){{(__m=((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::__storage_type>::t(0))>>(__bits_per_word,__n)));
(__b2=((*__result.__seg_)&__m));
((*__result.__seg_)&=(~__m));
((*__result.__seg_)|=(__b1>>__dn));
((*__first.__seg_)|=(__b2,__dn));
(__result.__ctz_=static_cast<unsigned int>(__n));
};};
};};
};};
return __result;
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>__bit_iterator<__xcodeml_template_type_0_1,0,expression>{if((__first1.__ctz_,__first2.__ctz_)){return((__first1,__last1,__first2));};
return((__first1,__last1,__first2));
}
template<typename __xcodeml_template_type_0_0>class __bit_array{public:typedef typename __xcodeml_template_type_0_0::difference_type difference_type;
public:typedef typename __xcodeml_template_type_0_0::__storage_type __storage_type;
public:typedef typename __xcodeml_template_type_0_0::__storage_pointer __storage_pointer;
public:typedef typename __xcodeml_template_type_0_0::iterator iterator;
public:static unsigned int const __bits_per_word=__xcodeml_template_type_0_0::__bits_per_word;
public:static unsigned int const _Np=4;
public:typename __xcodeml_template_type_0_0::difference_type __size_;
public:typename __xcodeml_template_type_0_0::__storage_type __word_[_Np];
public:static typename __xcodeml_template_type_0_0::difference_type capacity(){return static_cast<typename __xcodeml_template_type_0_0::difference_type>((_Np*__bits_per_word));
}
public:__bit_array(typename __xcodeml_template_type_0_0::difference_type __s):__size_(__s){}
public:typename __xcodeml_template_type_0_0::iterator begin(){return __xcodeml_identity<typename __xcodeml_template_type_0_0::iterator>::t((pointer_traits<typename __xcodeml_template_type_0_0::__storage_pointer>::.pointer_to((this->__word_)[0])),0);
}
public:typename __xcodeml_template_type_0_0::iterator end(){return __xcodeml_identity<typename __xcodeml_template_type_0_0::iterator>::t(((pointer_traits<typename __xcodeml_template_type_0_0::__storage_pointer>::.pointer_to((this->__word_)[0])),(this->__size_/__bits_per_word)),static_cast<unsigned int>((this->__size_%__bits_per_word)));
}
}
;
;
template<typename __xcodeml_template_type_0_0>__bit_iterator<__xcodeml_template_type_0_0,0,expression>{typedef __bit_iterator<__xcodeml_template_type_0_0,0,expression>;
typedef typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::difference_type difference_type;
typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::difference_type __d1=(__middle,__first);
typename __bit_iterator<__xcodeml_template_type_0_0,0,expression>::difference_type __d2=(__last,__middle);
__bit_iterator<__xcodeml_template_type_0_0,0,expression> =(__first,__d2);
while(((__d1,0)&&(__d2,0))){{if((__d1,__d2)){{if((__d1,(__bit_array<__xcodeml_template_type_0_0>::capacity()))){{__bit_array<__xcodeml_template_type_0_0> =__d1;
(std::__1::(__first,__middle,(__b.begin())));
(std::__1::((__b.begin()),(__b.end()),(std::__1::(__middle,__last,__first))));
break;
};}else{{__bit_iterator<__xcodeml_template_type_0_0,0,expression> =(std::__1::(__first,__middle,__middle));
(__first=__middle);
(__middle=__mp);
(__d2-=__d1);
};};
};}else{{if((__d2,(__bit_array<__xcodeml_template_type_0_0>::capacity()))){{__bit_array<__xcodeml_template_type_0_0> =__d2;
(std::__1::(__middle,__last,(__b.begin())));
(std::__1::((__b.begin()),(__b.end()),(std::__1::(__first,__middle,__last))));
break;
};}else{{__bit_iterator<__xcodeml_template_type_0_0,0,expression> =(__first,__d2);
(std::__1::(__first,__mp,__middle));
(__first=__mp);
(__d1-=__d2);
};};
};};
};};
return __r;
}
template<typename __xcodeml_template_type_0_0,bool _IC1,bool _IC2>bool __equal_unaligned(__bit_iterator<__xcodeml_template_type_0_0,expression,expression>,__bit_iterator<__xcodeml_template_type_0_0,expression,expression>,__bit_iterator<__xcodeml_template_type_0_0,expression,expression>){typedef __bit_iterator<__xcodeml_template_type_0_0,expression,expression>;
typedef typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type difference_type;
typedef typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __storage_type;
static int const __bits_per_word=__bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__bits_per_word;
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type __n=(__last1,__first1);
if((__n,0)){{if((__first1.__ctz_,0)){{unsigned int __clz_f=(__bits_per_word,__first1.__ctz_);
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type __dn=(std::__1::(static_cast<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type>(__clz_f),__n));
(__n-=__dn);
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __m=(((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0)),__first1.__ctz_)&((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0))>>(__clz_f,__dn)));
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __b=((*__first1.__seg_)&__m);
unsigned int __clz_r=(__bits_per_word,__first2.__ctz_);
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __ddn=(std::__1::typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type(__dn,__clz_r));
(__m=(((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0)),__first2.__ctz_)&((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0))>>(__clz_r,__ddn))));
if((__first2.__ctz_,__first1.__ctz_)){{if((((*__first2.__seg_)&__m),(__b,(__first2.__ctz_,__first1.__ctz_)))){return false;};
};}else{{if((((*__first2.__seg_)&__m),(__b>>(__first1.__ctz_,__first2.__ctz_)))){return false;};
};};
(__first2.__seg_+=((__ddn,__first2.__ctz_)/__bits_per_word));
(__first2.__ctz_=static_cast<unsigned int>(((__ddn,__first2.__ctz_)%__bits_per_word)));
(__dn-=__ddn);
if((__dn,0)){{(__m=((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0))>>(__bits_per_word,__dn)));
if((((*__first2.__seg_)&__m),(__b>>(__first1.__ctz_,__ddn)))){return false;};
(__first2.__ctz_=static_cast<unsigned int>(__dn));
};};
(++__first1.__seg_);
};};
unsigned int __clz_r=(__bits_per_word,__first2.__ctz_);
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __m=((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0)),__first2.__ctz_);
{;for(;(__n,__bits_per_word);((__n-=__bits_per_word),(++__first1.__seg_))){{typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __b=(*__first1.__seg_);
if((((*__first2.__seg_)&__m),(__b,__first2.__ctz_))){return false;};
(++__first2.__seg_);
if((((*__first2.__seg_)&(~__m)),(__b>>__clz_r))){return false;};
};}};
if((__n,0)){{(__m=((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0))>>(__bits_per_word,__n)));
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __b=((*__first1.__seg_)&__m);
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __dn=(std::__1::(__n,static_cast<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type>(__clz_r)));
(__m=(((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0)),__first2.__ctz_)&((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0))>>(__clz_r,__dn))));
if((((*__first2.__seg_)&__m),(__b,__first2.__ctz_))){return false;};
(__first2.__seg_+=((__dn,__first2.__ctz_)/__bits_per_word));
(__first2.__ctz_=static_cast<unsigned int>(((__dn,__first2.__ctz_)%__bits_per_word)));
(__n-=__dn);
if((__n,0)){{(__m=((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0))>>(__bits_per_word,__n)));
if((((*__first2.__seg_)&__m),(__b>>__dn))){return false;};
};};
};};
};};
return true;
}
template<typename __xcodeml_template_type_0_0,bool _IC1,bool _IC2>bool __equal_aligned(__bit_iterator<__xcodeml_template_type_0_0,expression,expression>,__bit_iterator<__xcodeml_template_type_0_0,expression,expression>,__bit_iterator<__xcodeml_template_type_0_0,expression,expression>){typedef __bit_iterator<__xcodeml_template_type_0_0,expression,expression>;
typedef typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type difference_type;
typedef typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __storage_type;
static int const __bits_per_word=__bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__bits_per_word;
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type __n=(__last1,__first1);
if((__n,0)){{if((__first1.__ctz_,0)){{unsigned int __clz=(__bits_per_word,__first1.__ctz_);
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type __dn=(std::__1::(static_cast<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::difference_type>(__clz),__n));
(__n-=__dn);
typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __m=(((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0)),__first1.__ctz_)&((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0))>>(__clz,__dn)));
if((((*__first2.__seg_)&__m),((*__first1.__seg_)&__m))){return false;};
(++__first2.__seg_);
(++__first1.__seg_);
};};
{;for(;(__n,__bits_per_word);(((__n-=__bits_per_word),(++__first1.__seg_)),(++__first2.__seg_))){if(((*__first2.__seg_),(*__first1.__seg_))){return false;};}};
if((__n,0)){{typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type __m=((~__xcodeml_identity<typename __bit_iterator<__xcodeml_template_type_0_0,expression,expression>::__storage_type>::t(0))>>(__bits_per_word,__n));
if((((*__first2.__seg_)&__m),((*__first1.__seg_)&__m))){return false;};
};};
};};
return true;
}
template<typename __xcodeml_template_type_0_0,bool _IC1,bool _IC2>bool equal(__bit_iterator<__xcodeml_template_type_0_0,expression,expression>,__bit_iterator<__xcodeml_template_type_0_0,expression,expression>,__bit_iterator<__xcodeml_template_type_0_0,expression,expression>){if((__first1.__ctz_,__first2.__ctz_)){return((__first1,__last1,__first2));};
return((__first1,__last1,__first2));
}
template<typename __xcodeml_template_type_0_0,bool _IsConst,typename __xcodeml_template_type_0_0::__storage_type>class __bit_iterator{public:
public:typedef typename __xcodeml_template_type_0_0::difference_type difference_type;
public:typedef bool value_type;
public:typedef class __bit_iterator pointer;
public:typedef typename conditional<expression,__bit_const_reference<__xcodeml_template_type_0_0>,__bit_reference<__xcodeml_template_type_0_0,expression> >::type reference;
public:typedef class::std::__1::random_access_iterator_tag iterator_category;
private:
private:typedef typename __xcodeml_template_type_0_0::__storage_type __storage_type;
private:typedef typename conditional<expression,typename __xcodeml_template_type_0_0::__const_storage_pointer,typename __xcodeml_template_type_0_0::__storage_pointer>::type __storage_pointer;
private:static unsigned int const __bits_per_word=__xcodeml_template_type_0_0::__bits_per_word;
private:typename conditional<expression,typename __xcodeml_template_type_0_0::__const_storage_pointer,typename __xcodeml_template_type_0_0::__storage_pointer>::type __seg_;
private:unsigned int __ctz_;
public:
public:__bit_iterator():__seg_(nullptr),__ctz_(0){}

/* Ignored a member with no access specifier class __private_nat;*/

public:using __type_for_copy_to_const=void/**/;
public:__bit_iterator(void/*const&__it*/):__seg_(__it.__seg_),__ctz_(__it.__ctz_){}
public:typename conditional<expression,__bit_const_reference<__xcodeml_template_type_0_0>,__bit_reference<__xcodeml_template_type_0_0,expression> >::type operator*()const{return __xcodeml_identity<typename conditional<expression,__bit_const_reference<__xcodeml_template_type_0_0>,__bit_reference<__xcodeml_template_type_0_0,expression> >::type>::t(this->__seg_,(__xcodeml_identity<typename __xcodeml_template_type_0_0::__storage_type>::t(1),this->__ctz_));
}
public:class __bit_iterator&operator++(){if((this->__ctz_,(__bits_per_word-1))){(++this->__ctz_);}else{{(this->__ctz_=0);
(++this->__seg_);
};};
return(*this);
}
public:class __bit_iterator operator++(int){class __bit_iterator __tmp=(*this);
(++(*this));
return __tmp;
}
public:class __bit_iterator&operator--(){if((this->__ctz_,0)){(--this->__ctz_);}else{{(this->__ctz_=(__bits_per_word-1));
(--this->__seg_);
};};
return(*this);
}
public:class __bit_iterator operator--(int){class __bit_iterator __tmp=(*this);
(--(*this));
return __tmp;
}
public:class __bit_iterator&operator+=(typename __xcodeml_template_type_0_0::difference_type __n){if((__n,0)){(this->__seg_+=((__n,this->__ctz_)/__bits_per_word));}else{(this->__seg_+=(static_cast<typename __xcodeml_template_type_0_0::difference_type>((((__n,__bits_per_word),this->__ctz_),1))/static_cast<typename __xcodeml_template_type_0_0::difference_type>(__bits_per_word)));};
(__n&=(__bits_per_word-1));
(this->__ctz_=static_cast<unsigned int>(((__n,this->__ctz_)%__bits_per_word)));
return(*this);
}
public:class __bit_iterator&operator-=(typename __xcodeml_template_type_0_0::difference_type __n){return((*this)+=(__n));
}
public:class __bit_iterator operator+(typename __xcodeml_template_type_0_0::difference_type __n)const{class __bit_iterator __t=(*this);
(__t+=__n);
return __t;
}
public:class __bit_iterator operator-(typename __xcodeml_template_type_0_0::difference_type __n)const{class __bit_iterator __t=(*this);
(__t-=__n);
return __t;
}
public:friend class __bit_iterator operator+(typename __xcodeml_template_type_0_0::difference_type __n,class __bit_iterator const&__it){return(__it,__n);
};
public:friend typename __xcodeml_template_type_0_0::difference_type operator-(class __bit_iterator const&__x,class __bit_iterator const&__y){return((((__x.__seg_,__y.__seg_)*__bits_per_word),__x.__ctz_),__y.__ctz_);
};
public:typename conditional<expression,__bit_const_reference<__xcodeml_template_type_0_0>,__bit_reference<__xcodeml_template_type_0_0,expression> >::type operator[](typename __xcodeml_template_type_0_0::difference_type __n)const{return(*((*this),__n));
}
public:friend bool operator==(class __bit_iterator const&__x,class __bit_iterator const&__y){return((__x.__seg_,__y.__seg_)&&(__x.__ctz_,__y.__ctz_));
};
public:friend bool operator!=(class __bit_iterator const&__x,class __bit_iterator const&__y){return(!(__x,__y));
};
public:friend bool operator<(class __bit_iterator const&__x,class __bit_iterator const&__y){return((__x.__seg_,__y.__seg_)||((__x.__seg_,__y.__seg_)&&(__x.__ctz_,__y.__ctz_)));
};
public:friend bool operator>(class __bit_iterator const&__x,class __bit_iterator const&__y){return(__y,__x);
};
public:friend bool operator<=(class __bit_iterator const&__x,class __bit_iterator const&__y){return(!(__y,__x));
};
public:friend bool operator>=(class __bit_iterator const&__x,class __bit_iterator const&__y){return(!(__x,__y));
};
private:
private:__bit_iterator(typename conditional<expression,typename __xcodeml_template_type_0_0::__const_storage_pointer,typename __xcodeml_template_type_0_0::__storage_pointer>::type __s,unsigned int __ctz):__seg_(__s),__ctz_(__ctz){}
public:friend typename __xcodeml_template_type_0_0::__self;
public:friend __bit_reference<__xcodeml_template_type_0_0,expression>;
public:friend __bit_const_reference<__xcodeml_template_type_0_0>;
public:friend __bit_iterator<__xcodeml_template_type_0_0,1,expression>;
public:friend template<typename __xcodeml_template_type_1_0>class __bit_array;
;
public:friend template<typename __xcodeml_template_type_1_0>void __fill_n_false(__bit_iterator<__xcodeml_template_type_1_0,0,expression>,typename __xcodeml_template_type_1_0::size_type __n);
public:friend template<typename __xcodeml_template_type_1_0>void __fill_n_true(__bit_iterator<__xcodeml_template_type_1_0,0,expression>,typename __xcodeml_template_type_1_0::size_type __n);
public:friend template<typename __xcodeml_template_type_1_0,bool _IC>__bit_iterator<__xcodeml_template_type_1_0,0,expression>;
public:friend template<typename __xcodeml_template_type_1_0,bool _IC>__bit_iterator<__xcodeml_template_type_1_0,0,expression>;
public:friend template<typename __xcodeml_template_type_1_0,bool _IC>__bit_iterator<__xcodeml_template_type_1_0,0,expression>;
public:friend template<typename __xcodeml_template_type_1_0,bool _IC>__bit_iterator<__xcodeml_template_type_1_0,0,expression>;
public:friend template<typename __xcodeml_template_type_1_0,bool _IC>__bit_iterator<__xcodeml_template_type_1_0,0,expression>;
public:friend template<typename __xcodeml_template_type_1_0,bool _IC>__bit_iterator<__xcodeml_template_type_1_0,0,expression>;
public:friend template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>__bit_iterator<__xcodeml_template_type_1_1,0,expression>;
public:friend template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>__bit_iterator<__xcodeml_template_type_1_1,0,expression>;
public:friend template<typename __xcodeml_template_type_1_0,typename __xcodeml_template_type_1_1>__bit_iterator<__xcodeml_template_type_1_1,0,expression>;
public:friend template<typename __xcodeml_template_type_1_0>__bit_iterator<__xcodeml_template_type_1_0,0,expression>;
public:friend template<typename __xcodeml_template_type_1_0,bool _IC1,bool _IC2>bool __equal_aligned(__bit_iterator<__xcodeml_template_type_1_0,expression,expression>,__bit_iterator<__xcodeml_template_type_1_0,expression,expression>,__bit_iterator<__xcodeml_template_type_1_0,expression,expression>);
public:friend template<typename __xcodeml_template_type_1_0,bool _IC1,bool _IC2>bool __equal_unaligned(__bit_iterator<__xcodeml_template_type_1_0,expression,expression>,__bit_iterator<__xcodeml_template_type_1_0,expression,expression>,__bit_iterator<__xcodeml_template_type_1_0,expression,expression>);
public:friend template<typename __xcodeml_template_type_1_0,bool _IC1,bool _IC2>bool equal(__bit_iterator<__xcodeml_template_type_1_0,expression,expression>,__bit_iterator<__xcodeml_template_type_1_0,expression,expression>,__bit_iterator<__xcodeml_template_type_1_0,expression,expression>);
public:friend template<typename __xcodeml_template_type_1_0,bool _IC>__bit_iterator<__xcodeml_template_type_1_0,expression,expression>;
public:friend template<typename __xcodeml_template_type_1_0,bool _IC>__bit_iterator<__xcodeml_template_type_1_0,expression,expression>;
public:friend template<typename __xcodeml_template_type_1_0,bool _IC>typename __bit_iterator<__xcodeml_template_type_1_0,expression,expression>::difference_type __count_bool_true(__bit_iterator<__xcodeml_template_type_1_0,expression,expression>,typename __xcodeml_template_type_1_0::size_type);
public:friend template<typename __xcodeml_template_type_1_0,bool _IC>typename __bit_iterator<__xcodeml_template_type_1_0,expression,expression>::difference_type __count_bool_false(__bit_iterator<__xcodeml_template_type_1_0,expression,expression>,typename __xcodeml_template_type_1_0::size_type);
}
;
;
}
}
namespace std{namespace __1{template<bool>class __split_buffer_common{protected:
protected:void __throw_length_error()const;
protected:void __throw_out_of_range()const;
}
;
template<>class __split_buffer_common<1>{protected:
protected:void __throw_length_error()const;
protected:void __throw_out_of_range()const;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __split_buffer:private __split_buffer_common<1>{private:
private:__split_buffer(class __split_buffer const&);
private:class __split_buffer&operator=(class __split_buffer const&);
public:
public:typedef __xcodeml_template_type_0_0 value_type;
public:typedef __xcodeml_template_type_0_1 allocator_type;
public:typedef typename remove_reference<__xcodeml_template_type_0_1>::type __alloc_rr;
public:typedef allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>;
public:typedef __xcodeml_template_type_0_0&reference;
public:typedef __xcodeml_template_type_0_0 const&const_reference;
public:typedef typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::size_type size_type;
public:typedef typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::difference_type difference_type;
public:typedef typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer pointer;
public:typedef typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::const_pointer const_pointer;
public:typedef typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer iterator;
public:typedef typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::const_pointer const_iterator;
public:typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer __first_;
public:typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer __begin_;
public:typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer __end_;
public:__compressed_pair<typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer,__xcodeml_template_type_0_1>;
public:typedef typename add_lvalue_reference<__xcodeml_template_type_0_1>::type __alloc_ref;
public:typedef typename add_lvalue_reference<__xcodeml_template_type_0_1>::type __alloc_const_ref;
public:typename remove_reference<__xcodeml_template_type_0_1>::type&__alloc(){return(this->__end_cap_.second());
}
public:typename remove_reference<__xcodeml_template_type_0_1>::type const&__alloc()const{return(this->__end_cap_.second());
}
public:typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer&__end_cap(){return(this->__end_cap_.first());
}
public:typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer const&__end_cap()const{return(this->__end_cap_.first());
}
public:__split_buffer();
public:__split_buffer(typename remove_reference<__xcodeml_template_type_0_1>::type&__a);
public:__split_buffer(typename remove_reference<__xcodeml_template_type_0_1>::type const&__a);
public:__split_buffer(typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::size_type __cap,typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::size_type __start,typename remove_reference<__xcodeml_template_type_0_1>::type&__a);
public:~__split_buffer();
public:__split_buffer(class __split_buffer(*__c));
public:__split_buffer(class __split_buffer(*__c),typename remove_reference<__xcodeml_template_type_0_1>::type const&__a);
public:class __split_buffer&operator=(class __split_buffer(*__c));
public:typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer begin(){return this->__begin_;
}
public:typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::const_pointer begin()const{return this->__begin_;
}
public:typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer end(){return this->__end_;
}
public:typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::const_pointer end()const{return this->__end_;
}
public:void clear(){((this->__begin_));
}
public:typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::size_type size()const{return static_cast<typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::size_type>((this->__end_,this->__begin_));
}
public:bool empty()const{return(this->__end_,this->__begin_);
}
public:typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::size_type capacity()const{return static_cast<typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::size_type>(((()),this->__first_));
}
public:typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::size_type __front_spare()const{return static_cast<typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::size_type>((this->__begin_,this->__first_));
}
public:typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::size_type __back_spare()const{return static_cast<typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::size_type>(((()),this->__end_));
}
public:__xcodeml_template_type_0_0&front(){return(*this->__begin_);
}
public:__xcodeml_template_type_0_0 const&front()const{return(*this->__begin_);
}
public:__xcodeml_template_type_0_0&back(){return(*(this->__end_,1));
}
public:__xcodeml_template_type_0_0 const&back()const{return(*(this->__end_,1));
}
public:void reserve(typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::size_type __n);
public:void shrink_to_fit();
public:void push_front(__xcodeml_template_type_0_0 const&__x);
public:void push_back(__xcodeml_template_type_0_0 const&__x);
public:void push_front(__xcodeml_template_type_0_0(*__x));
public:void push_back(__xcodeml_template_type_0_0(*__x));
public:template<typename __xcodeml_template_type_1_0>void emplace_back(void/*__args*/)
public:void pop_front(){(((this->__begin_,1)));
}
public:void pop_back(){(((this->__end_,1)));
}
public:void __construct_at_end(typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::size_type __n);
public:void __construct_at_end(typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::size_type __n,__xcodeml_template_type_0_0 const&__x);
public:template<typename __xcodeml_template_type_1_0>typename enable_if<expression,void>::type __construct_at_end(__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last)
public:template<typename __xcodeml_template_type_1_0>typename enable_if<expression,void>::type __construct_at_end(__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last)
public:void __destruct_at_begin(typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer __new_begin){((__new_begin,__xcodeml_identity<is_trivially_destructible<__xcodeml_template_type_0_0> >::t()));
}
public:void __destruct_at_begin(typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer __new_begin,class::std::__1::integral_constant<bool,0>);
public:void __destruct_at_begin(typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer __new_begin,class::std::__1::integral_constant<bool,1>);
public:void __destruct_at_end(typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer __new_last){((__new_last,__xcodeml_identity<class::std::__1::integral_constant<bool,0> >::t()));
}
public:void __destruct_at_end(typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer __new_last,class::std::__1::integral_constant<bool,0>);
public:void __destruct_at_end(typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer __new_last,class::std::__1::integral_constant<bool,1>);
public:void swap(class __split_buffer&__x);
public:bool __invariants()const;
private:
private:void __move_assign_alloc(class __split_buffer&__c,class::std::__1::integral_constant<bool,1>){((())=(std::__1::((__c.__alloc()))));
}
private:void __move_assign_alloc(class __split_buffer&,class::std::__1::integral_constant<bool,0>){}
}
;
template<>class __split_buffer<int,class::std::__1::allocator<int>&>:private __split_buffer_common<1>{private:
private:__split_buffer(class __split_buffer const&);
private:class::std::__1::__split_buffer<int,class::std::__1::allocator<int>&>&operator=(class __split_buffer const&);
public:
public:typedef int value_type;
public:typedef class::std::__1::allocator<int>&allocator_type;
public:typedef class::std::__1::allocator<int>__alloc_rr;
public:typedef class::std::__1::allocator_traits<class::std::__1::allocator<int> >__alloc_traits;
public:typedef int&reference;
public:typedef int const&const_reference;
public:typedef unsigned long size_type;
public:typedef long difference_type;
public:typedef int(*pointer);
public:typedef int const(*const_pointer);
public:typedef int(*iterator);
public:typedef int const(*const_iterator);
public:int(*__first_);
public:int(*__begin_);
public:int(*__end_);
public:class::std::__1::__compressed_pair<int(*),class::std::__1::allocator<int>&>__end_cap_;
public:typedef class::std::__1::allocator<int>&__alloc_ref;
public:typedef class::std::__1::allocator<int>&__alloc_const_ref;
public:class::std::__1::allocator<int>&__alloc(){return(this->__end_cap_.second());
}
public:class allocator const&__alloc()const;
public:int(*&__end_cap()){return(this->__end_cap_.first());
}
public:int(*const&__end_cap()const){return(this->__end_cap_.first());
}
public:__split_buffer();
public:__split_buffer(class::std::__1::allocator<int>&__a);
public:__split_buffer(class allocator const&__a);
public:__split_buffer(unsigned long __cap,unsigned long __start,class::std::__1::allocator<int>&__a):__split_buffer_common(),__end_cap_(nullptr){(this->__first_=((__cap!=0)?(allocator_traits::allocate((this->__alloc()),__cap)):nullptr));
(this->__begin_=(this->__end_=(this->__first_+__start)));
((this->__end_cap())=(this->__first_+__cap));
}
public:~__split_buffer(){(this->clear());
if(this->__first_){(allocator_traits::deallocate((this->__alloc()),this->__first_,(this->capacity())));};
}
public:__split_buffer(class::std::__1::__split_buffer<int,class::std::__1::allocator<int>&>(*__c));
public:__split_buffer(class::std::__1::__split_buffer<int,class::std::__1::allocator<int>&>(*__c),class allocator const&__a);
public:class::std::__1::__split_buffer<int,class::std::__1::allocator<int>&>&operator=(class::std::__1::__split_buffer<int,class::std::__1::allocator<int>&>(*__c));
public:int(*begin());
public:int const(*begin()const);
public:int(*end());
public:int const(*end()const);
public:void clear(){(this->__destruct_at_end(this->__begin_));
}
public:unsigned long size()const;
public:bool empty()const;
public:unsigned long capacity()const{return static_cast<unsigned long>(((this->__end_cap())-this->__first_));
}
public:unsigned long __front_spare()const;
public:unsigned long __back_spare()const;
public:int&front();
public:int const&front()const;
public:int&back();
public:int const&back()const;
public:void reserve(unsigned long __n);
public:void shrink_to_fit();
public:void push_front(int const&__x);
public:void push_back(int const&__x);
public:void push_front(int(*__x));
public:void push_back(int(*__x));
public:template<typename __xcodeml_template_type_0_0>void emplace_back(void/*__args*/)
public:void pop_front();
public:void pop_back();
public:void __construct_at_end(unsigned long __n);
public:void __construct_at_end(unsigned long __n,int const&__x);
public:template<typename __xcodeml_template_type_0_0>typename enable_if<expression,void>::type __construct_at_end(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last)
public:template<typename __xcodeml_template_type_0_0>typename enable_if<expression,void>::type __construct_at_end(__xcodeml_template_type_0_0 __first,__xcodeml_template_type_0_0 __last)
public:void __destruct_at_begin(int(*__new_begin));
public:void __destruct_at_begin(int(*__new_begin),class::std::__1::integral_constant<bool,0>);
public:void __destruct_at_begin(int(*__new_begin),class::std::__1::integral_constant<bool,1>);
public:void __destruct_at_end(int(*__new_last)){(this->__destruct_at_end(__new_last,__xcodeml_identity<class::std::__1::integral_constant<bool,0> >::t()));
}
public:void __destruct_at_end(int(*__new_last),class::std::__1::integral_constant<bool,0>){while((__new_last!=this->__end_)){(allocator_traits::destroy((this->__alloc()),(__to_raw_pointer((--this->__end_)))));};
}
public:void __destruct_at_end(int(*__new_last),class::std::__1::integral_constant<bool,1>);
public:void swap(class::std::__1::__split_buffer<int,class::std::__1::allocator<int>&>&__x);
public:bool __invariants()const;
private:
private:void __move_assign_alloc(class::std::__1::__split_buffer<int,class::std::__1::allocator<int>&>&__c,class::std::__1::integral_constant<bool,1>);
private:void __move_assign_alloc(class::std::__1::__split_buffer<int,class::std::__1::allocator<int>&>&,class::std::__1::integral_constant<bool,0>);
}
;
bool __split_buffer::__invariants()const{if((this->__first_,nullptr)){{if((this->__begin_,nullptr)){return false;};
if((this->__end_,nullptr)){return false;};
if(((()),nullptr)){return false;};
};}else{{if((this->__begin_,this->__first_)){return false;};
if((this->__end_,this->__begin_)){return false;};
if(((()),this->__end_)){return false;};
};};
return true;
}
void __split_buffer::__construct_at_end(typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::size_type __n){typename remove_reference<__xcodeml_template_type_0_1>::type&__a=(this.__alloc());
do{{(allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::.construct(__a,(std::__1::(this.__end_))));
(++this.__end_);
(--__n);
};}while((__n,0));
}
void __split_buffer::__construct_at_end(typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::size_type __n,__xcodeml_template_type_0_0 const&__x){typename remove_reference<__xcodeml_template_type_0_1>::type&__a=(this.__alloc());
do{{(allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::.construct(__a,(std::__1::(this.__end_)),__x));
(++this.__end_);
(--__n);
};}while((__n,0));
}
template<typename __xcodeml_template_type_1_0>typename enable_if<expression,void>::type __split_buffer::__construct_at_end(__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last){typename remove_reference<__xcodeml_template_type_0_1>::type&__a=(this.__alloc());
{;for(;(__first,__last);(++__first)){{if((this->__end_,(()))){{typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::size_type __old_cap=((()),this->__first_);
typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::size_type __new_cap=(std::__1::typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::size_type((2*__old_cap),8));
class __split_buffer __buf=__new_cap 0 __a;
{typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer __p=this->__begin_;for(;(__p,this->__end_);((++__p),(++__buf.__end_))){(allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::.construct((__buf.__alloc()),(std::__1::(__buf.__end_)),(std::__1::((*__p)))));}};
(this->swap(__buf));
};};
(allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::.construct(__a,(std::__1::(this.__end_)),(*__first)));
(++this.__end_);
};}};
}
template<typename __xcodeml_template_type_1_0>typename enable_if<expression,void>::type __split_buffer::__construct_at_end(__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last){typename remove_reference<__xcodeml_template_type_0_1>::type&__a=(this.__alloc());
{;for(;(__first,__last);(++__first)){{(allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::.construct(__a,(std::__1::(this.__end_)),(*__first)));
(++this.__end_);
};}};
}
void __split_buffer::__destruct_at_begin(typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer __new_begin,class::std::__1::integral_constant<bool,0>){while((this->__begin_,__new_begin)){(allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::.destroy((()),(((this->__begin_++)))));};
}
void __split_buffer::__destruct_at_begin(typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer __new_begin,class::std::__1::integral_constant<bool,1>){(this->__begin_=__new_begin);
}
void __split_buffer::__destruct_at_end(typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer __new_last,class::std::__1::integral_constant<bool,0>){while((__new_last,this->__end_)){(allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::.destroy((()),(((--this->__end_)))));};
}
void __split_buffer::__destruct_at_end(typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer __new_last,class::std::__1::integral_constant<bool,1>){(this->__end_=__new_last);
}
__split_buffer::__split_buffer(typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::size_type __cap,typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::size_type __start,typename remove_reference<__xcodeml_template_type_0_1>::type&__a):__end_cap_(nullptr __a){(this->__first_=((__cap,0)?(allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::.allocate((()),__cap)):nullptr));
(this->__begin_=(this->__end_=(this->__first_,__start)));
((())=(this->__first_,__cap));
}
__split_buffer::__split_buffer():__first_(nullptr),__begin_(nullptr),__end_(nullptr),__end_cap_(nullptr){}
__split_buffer::__split_buffer(typename remove_reference<__xcodeml_template_type_0_1>::type&__a):__first_(nullptr),__begin_(nullptr),__end_(nullptr),__end_cap_(nullptr __a){}
__split_buffer::__split_buffer(typename remove_reference<__xcodeml_template_type_0_1>::type const&__a):__first_(nullptr),__begin_(nullptr),__end_(nullptr),__end_cap_(nullptr __a){}
__split_buffer::~__split_buffer(){(this->clear());
if(this->__first_){(allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::.deallocate((()),this->__first_,(this->capacity())));};
}
__split_buffer::__split_buffer(class __split_buffer(*__c)):__first_((std::__1::(__c.__first_))),__begin_((std::__1::(__c.__begin_))),__end_((std::__1::(__c.__end_))),__end_cap_((std::__1::(__c.__end_cap_))){(__c.__first_=nullptr);
(__c.__begin_=nullptr);
(__c.__end_=nullptr);
((__c.__end_cap())=nullptr);
}
__split_buffer::__split_buffer(class __split_buffer(*__c),typename remove_reference<__xcodeml_template_type_0_1>::type const&__a):__end_cap_(__xcodeml_identity<class::std::__1::__second_tag>::t()__a){if((__a,(__c.__alloc()))){{(this->__first_=__c.__first_);
(this->__begin_=__c.__begin_);
(this->__end_=__c.__end_);
((())=(__c.__end_cap()));
(__c.__first_=nullptr);
(__c.__begin_=nullptr);
(__c.__end_=nullptr);
((__c.__end_cap())=nullptr);
};}else{{typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::size_type __cap=(__c.size());
(this->__first_=(allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::.allocate((()),__cap)));
(this->__begin_=(this->__end_=this->__first_));
((())=(this->__first_,__cap));
typedef move_iterator<typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer>;
((__xcodeml_identity<move_iterator<typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer> >::t((__c.begin())),__xcodeml_identity<move_iterator<typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer> >::t((__c.end()))));
};};
}
class __split_buffer&__split_buffer::operator=(class __split_buffer(*__c)){(this->clear());
(this->shrink_to_fit());
(this->__first_=__c.__first_);
(this->__begin_=__c.__begin_);
(this->__end_=__c.__end_);
((())=(__c.__end_cap()));
((__c,__xcodeml_identity<integral_constant<bool,expression> >::t()));
(__c.__first_=(__c.__begin_=(__c.__end_=((__c.__end_cap())=nullptr))));
return(*this);
}
void __split_buffer::swap(class __split_buffer&__x){(std::__1::(this->__first_,__x.__first_));
(std::__1::(this->__begin_,__x.__begin_));
(std::__1::(this->__end_,__x.__end_));
(std::__1::((()),(__x.__end_cap())));
(((()),(__x.__alloc())));
}
void __split_buffer::reserve(typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::size_type __n){if((__n,(this->capacity()))){{__split_buffer<__xcodeml_template_type_0_0,typename remove_reference<__xcodeml_template_type_0_1>::type&> =__n 0(());
(__t.__construct_at_end(__xcodeml_identity<move_iterator<typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer> >::t(this->__begin_),__xcodeml_identity<move_iterator<typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer> >::t(this->__end_)));
(std::__1::(this->__first_,__t.__first_));
(std::__1::(this->__begin_,__t.__begin_));
(std::__1::(this->__end_,__t.__end_));
(std::__1::((()),(__t.__end_cap())));
};};
}
void __split_buffer::shrink_to_fit(){if(((this->capacity()),(this->size()))){{try{__split_buffer<__xcodeml_template_type_0_0,typename remove_reference<__xcodeml_template_type_0_1>::type&> =(this->size())0(());
(__t.__construct_at_end(__xcodeml_identity<move_iterator<typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer> >::t(this->__begin_),__xcodeml_identity<move_iterator<typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer> >::t(this->__end_)));
(__t.__end_=(__t.__begin_,(this->__end_,this->__begin_)));
(std::__1::(this->__first_,__t.__first_));
(std::__1::(this->__begin_,__t.__begin_));
(std::__1::(this->__end_,__t.__end_));
(std::__1::((()),(__t.__end_cap())));
}catch(...){}
;
};};
}
void __split_buffer::push_front(__xcodeml_template_type_0_0 const&__x){if((this->__begin_,this->__first_)){{if((this->__end_,(()))){{typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::difference_type __d=((()),this->__end_);
(__d=((__d,1)/2));
(this->__begin_=(std::__1::(this->__begin_,this->__end_,(this->__end_,__d))));
(this->__end_+=__d);
};}else{{typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::size_type __c=(typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::size_type((2*static_cast<unsigned long>(((()),this->__first_))),1));
__split_buffer<__xcodeml_template_type_0_0,typename remove_reference<__xcodeml_template_type_0_1>::type&> =__c((__c,3)/4)(());
(__t.__construct_at_end(__xcodeml_identity<move_iterator<typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer> >::t(this->__begin_),__xcodeml_identity<move_iterator<typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer> >::t(this->__end_)));
(std::__1::(this->__first_,__t.__first_));
(std::__1::(this->__begin_,__t.__begin_));
(std::__1::(this->__end_,__t.__end_));
(std::__1::((()),(__t.__end_cap())));
};};
};};
(allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::.construct((()),(std::__1::((this->__begin_,1))),__x));
(--this->__begin_);
}
void __split_buffer::push_front(__xcodeml_template_type_0_0(*__x)){if((this->__begin_,this->__first_)){{if((this->__end_,(()))){{typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::difference_type __d=((()),this->__end_);
(__d=((__d,1)/2));
(this->__begin_=(std::__1::(this->__begin_,this->__end_,(this->__end_,__d))));
(this->__end_+=__d);
};}else{{typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::size_type __c=(typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::size_type((2*static_cast<unsigned long>(((()),this->__first_))),1));
__split_buffer<__xcodeml_template_type_0_0,typename remove_reference<__xcodeml_template_type_0_1>::type&> =__c((__c,3)/4)(());
(__t.__construct_at_end(__xcodeml_identity<move_iterator<typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer> >::t(this->__begin_),__xcodeml_identity<move_iterator<typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer> >::t(this->__end_)));
(std::__1::(this->__first_,__t.__first_));
(std::__1::(this->__begin_,__t.__begin_));
(std::__1::(this->__end_,__t.__end_));
(std::__1::((()),(__t.__end_cap())));
};};
};};
(allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::.construct((()),(std::__1::((this->__begin_,1))),(std::__1::(__x))));
(--this->__begin_);
}
void __split_buffer::push_back(__xcodeml_template_type_0_0 const&__x){if((this->__end_,(()))){{if((this->__begin_,this->__first_)){{typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::difference_type __d=(this->__begin_,this->__first_);
(__d=((__d,1)/2));
(this->__end_=(std::__1::(this->__begin_,this->__end_,(this->__begin_,__d))));
(this->__begin_-=__d);
};}else{{typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::size_type __c=(typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::size_type((2*static_cast<unsigned long>(((()),this->__first_))),1));
__split_buffer<__xcodeml_template_type_0_0,typename remove_reference<__xcodeml_template_type_0_1>::type&> =__c(__c/4)(());
(__t.__construct_at_end(__xcodeml_identity<move_iterator<typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer> >::t(this->__begin_),__xcodeml_identity<move_iterator<typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer> >::t(this->__end_)));
(std::__1::(this->__first_,__t.__first_));
(std::__1::(this->__begin_,__t.__begin_));
(std::__1::(this->__end_,__t.__end_));
(std::__1::((()),(__t.__end_cap())));
};};
};};
(allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::.construct((()),(std::__1::(this->__end_)),__x));
(++this->__end_);
}
void __split_buffer::push_back(__xcodeml_template_type_0_0(*__x)){if((this->__end_,(()))){{if((this->__begin_,this->__first_)){{typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::difference_type __d=(this->__begin_,this->__first_);
(__d=((__d,1)/2));
(this->__end_=(std::__1::(this->__begin_,this->__end_,(this->__begin_,__d))));
(this->__begin_-=__d);
};}else{{typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::size_type __c=(typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::size_type((2*static_cast<unsigned long>(((()),this->__first_))),1));
__split_buffer<__xcodeml_template_type_0_0,typename remove_reference<__xcodeml_template_type_0_1>::type&> =__c(__c/4)(());
(__t.__construct_at_end(__xcodeml_identity<move_iterator<typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer> >::t(this->__begin_),__xcodeml_identity<move_iterator<typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer> >::t(this->__end_)));
(std::__1::(this->__first_,__t.__first_));
(std::__1::(this->__begin_,__t.__begin_));
(std::__1::(this->__end_,__t.__end_));
(std::__1::((()),(__t.__end_cap())));
};};
};};
(allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::.construct((()),(std::__1::(this->__end_)),(std::__1::(__x))));
(++this->__end_);
}
template<typename __xcodeml_template_type_1_0>void __split_buffer::emplace_back(void/*__args*/){if((this->__end_,(()))){{if((this->__begin_,this->__first_)){{typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::difference_type __d=(this->__begin_,this->__first_);
(__d=((__d,1)/2));
(this->__end_=(std::__1::(this->__begin_,this->__end_,(this->__begin_,__d))));
(this->__begin_-=__d);
};}else{{typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::size_type __c=(typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::size_type((2*static_cast<unsigned long>(((()),this->__first_))),1));
__split_buffer<__xcodeml_template_type_0_0,typename remove_reference<__xcodeml_template_type_0_1>::type&> =__c(__c/4)(());
(__t.__construct_at_end(__xcodeml_identity<move_iterator<typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer> >::t(this->__begin_),__xcodeml_identity<move_iterator<typename allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::pointer> >::t(this->__end_)));
(std::__1::(this->__first_,__t.__first_));
(std::__1::(this->__begin_,__t.__begin_));
(std::__1::(this->__end_,__t.__end_));
(std::__1::((()),(__t.__end_cap())));
};};
};};
(allocator_traits<typename remove_reference<__xcodeml_template_type_0_1>::type>::.construct((()),(std::__1::(this->__end_)),(std::__1::__xcodeml_template_type_1_0(__args))));
(++this->__end_);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void swap(__split_buffer<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,__split_buffer<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>){(__x.swap(__y));
}
}
}
namespace std{namespace __1{template<bool>class __vector_base_common{protected:
protected:__vector_base_common(){}
protected:void __throw_length_error()const;
protected:void __throw_out_of_range()const;
}
;
;
void __vector_base_common::__throw_length_error()const{(std::__1::__throw_length_error("vector"));
}
void __vector_base_common::__throw_out_of_range()const{(std::__1::__throw_out_of_range("vector"));
}
template<>class __vector_base_common<1>{protected:
protected:__vector_base_common(){}
protected:void __throw_length_error()const;
protected:void __throw_out_of_range()const;
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class __vector_base:protected __vector_base_common<1>{public:
public:typedef __xcodeml_template_type_0_1 allocator_type;
public:typedef allocator_traits<__xcodeml_template_type_0_1>;
public:typedef typename allocator_traits<__xcodeml_template_type_0_1>::size_type size_type;
protected:
protected:typedef __xcodeml_template_type_0_0 value_type;
protected:typedef __xcodeml_template_type_0_0&reference;
protected:typedef __xcodeml_template_type_0_0 const&const_reference;
protected:typedef typename allocator_traits<__xcodeml_template_type_0_1>::difference_type difference_type;
protected:typedef typename allocator_traits<__xcodeml_template_type_0_1>::pointer pointer;
protected:typedef typename allocator_traits<__xcodeml_template_type_0_1>::const_pointer const_pointer;
protected:typedef typename allocator_traits<__xcodeml_template_type_0_1>::pointer iterator;
protected:typedef typename allocator_traits<__xcodeml_template_type_0_1>::const_pointer const_iterator;
protected:typename allocator_traits<__xcodeml_template_type_0_1>::pointer __begin_;
protected:typename allocator_traits<__xcodeml_template_type_0_1>::pointer __end_;
protected:__compressed_pair<typename allocator_traits<__xcodeml_template_type_0_1>::pointer,__xcodeml_template_type_0_1>;
protected:__xcodeml_template_type_0_1&__alloc(){return(this->__end_cap_.second());
}
protected:__xcodeml_template_type_0_1 const&__alloc()const{return(this->__end_cap_.second());
}
protected:typename allocator_traits<__xcodeml_template_type_0_1>::pointer&__end_cap(){return(this->__end_cap_.first());
}
protected:typename allocator_traits<__xcodeml_template_type_0_1>::pointer const&__end_cap()const{return(this->__end_cap_.first());
}
protected:__vector_base();
protected:__vector_base(__xcodeml_template_type_0_1 const&__a);
protected:__vector_base(__xcodeml_template_type_0_1(*__a));
protected:~__vector_base();
protected:void clear(){(this->__destruct_at_end(this->__begin_));
}
protected:typename allocator_traits<__xcodeml_template_type_0_1>::size_type capacity()const{return static_cast<typename allocator_traits<__xcodeml_template_type_0_1>::size_type>(((()),this->__begin_));
}
protected:void __destruct_at_end(typename allocator_traits<__xcodeml_template_type_0_1>::pointer __new_last);
protected:void __copy_assign_alloc(class __vector_base const&__c){((__c,__xcodeml_identity<integral_constant<bool,expression> >::t()));
}
protected:void __move_assign_alloc(class __vector_base&__c){((__c,__xcodeml_identity<integral_constant<bool,expression> >::t()));
}
private:
private:void __copy_assign_alloc(class __vector_base const&__c,class::std::__1::integral_constant<bool,1>){if(((()),(__c.__alloc()))){{(this->clear());
(allocator_traits<__xcodeml_template_type_0_1>::.deallocate((()),this->__begin_,(this->capacity())));
(this->__begin_=(this->__end_=((())=nullptr)));
};};
((())=(__c.__alloc()));
}
private:void __copy_assign_alloc(class __vector_base const&,class::std::__1::integral_constant<bool,0>){}
private:void __move_assign_alloc(class __vector_base&__c,class::std::__1::integral_constant<bool,1>){((())=(std::__1::((__c.__alloc()))));
}
private:void __move_assign_alloc(class __vector_base&,class::std::__1::integral_constant<bool,0>){}
}
;
template<>class __vector_base<int,class::std::__1::allocator<int> >:protected __vector_base_common<1>{public:
public:typedef class::std::__1::allocator<int>allocator_type;
public:typedef class::std::__1::allocator_traits<class::std::__1::allocator<int> >__alloc_traits;
public:typedef unsigned long size_type;
protected:
protected:typedef int value_type;
protected:typedef int&reference;
protected:typedef int const&const_reference;
protected:typedef long difference_type;
protected:typedef int(*pointer);
protected:typedef int const(*const_pointer);
protected:typedef int(*iterator);
protected:typedef int const(*const_iterator);
protected:int(*__begin_);
protected:int(*__end_);
protected:class::std::__1::__compressed_pair<int(*),class::std::__1::allocator<int> >__end_cap_;
protected:class::std::__1::allocator<int>&__alloc(){return(this->__end_cap_.second());
}
protected:class allocator const&__alloc()const{return(this->__end_cap_.second());
}
protected:int(*&__end_cap()){return(this->__end_cap_.first());
}
protected:int(*const&__end_cap()const){return(this->__end_cap_.first());
}
protected:__vector_base():__vector_base_common(),__begin_(nullptr),__end_(nullptr),__end_cap_(nullptr){}
protected:__vector_base(class allocator const&__a);
protected:__vector_base(class::std::__1::allocator<int>(*__a));
protected:~__vector_base(){if((this->__begin_!=nullptr)){{(this->clear());
(allocator_traits::deallocate((this->__alloc()),this->__begin_,(this->capacity())));
};};
}
protected:void clear(){(this->__destruct_at_end(this->__begin_));
}
protected:unsigned long capacity()const{return static_cast<unsigned long>(((this->__end_cap())-this->__begin_));
}
protected:void __destruct_at_end(int(*__new_last)){int(*__soon_to_be_end)=this->__end_;
while((__new_last!=__soon_to_be_end)){(allocator_traits::destroy((this->__alloc()),(std::__1::__to_raw_pointer((--__soon_to_be_end)))));};
(this->__end_=__new_last);
}
protected:void __copy_assign_alloc(class __vector_base const&__c);
protected:void __move_assign_alloc(class::std::__1::__vector_base<int,class::std::__1::allocator<int> >&__c);
private:
private:void __copy_assign_alloc(class __vector_base const&__c,class::std::__1::integral_constant<bool,1>);
private:void __copy_assign_alloc(class __vector_base const&,class::std::__1::integral_constant<bool,0>);
private:void __move_assign_alloc(class::std::__1::__vector_base<int,class::std::__1::allocator<int> >&__c,class::std::__1::integral_constant<bool,1>);
private:void __move_assign_alloc(class::std::__1::__vector_base<int,class::std::__1::allocator<int> >&,class::std::__1::integral_constant<bool,0>);
}
;
void __vector_base::__destruct_at_end(typename allocator_traits<__xcodeml_template_type_0_1>::pointer __new_last){typename allocator_traits<__xcodeml_template_type_0_1>::pointer __soon_to_be_end=this->__end_;
while((__new_last,__soon_to_be_end)){(allocator_traits<__xcodeml_template_type_0_1>::.destroy((()),(std::__1::((--__soon_to_be_end)))));};
(this->__end_=__new_last);
}
__vector_base::__vector_base():__begin_(nullptr),__end_(nullptr),__end_cap_(nullptr){}
__vector_base::__vector_base(__xcodeml_template_type_0_1 const&__a):__begin_(nullptr),__end_(nullptr),__end_cap_(nullptr __a){}
__vector_base::__vector_base(__xcodeml_template_type_0_1(*__a)):__begin_(nullptr),__end_(nullptr),__end_cap_(nullptr(std::(__a))){}
__vector_base::~__vector_base(){if((this->__begin_,nullptr)){{(this->clear());
(allocator_traits<__xcodeml_template_type_0_1>::.deallocate((()),this->__begin_,(this->capacity())));
};};
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>class vector:private __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>{private:
private:typedef __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>;
private:typedef allocator<__xcodeml_template_type_0_0>;
public:
public:typedef class vector __self;
public:typedef __xcodeml_template_type_0_0 value_type;
public:typedef __xcodeml_template_type_0_1 allocator_type;
public:typedef typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::__alloc_traits __alloc_traits;
public:typedef typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::reference reference;
public:typedef typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_reference const_reference;
public:typedef typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type size_type;
public:typedef typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::difference_type difference_type;
public:typedef typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer pointer;
public:typedef typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_pointer const_pointer;
public:typedef __wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer>;
public:typedef __wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_pointer>;
public:typedef reverse_iterator<__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer> >;
public:typedef reverse_iterator<__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_pointer> >;

/* Ignored a member with no access specifier is_same<typename __xcodeml_template_type_0_1::value_type,__xcodeml_template_type_0_0>::value"Allocator::value_type must be same type as value_type";*/

public:vector(){}
public:vector(__xcodeml_template_type_0_1 const&__a):(__a){}
public:vector(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n);
public:vector(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n,__xcodeml_template_type_0_1 const&__a);
public:vector(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n,__xcodeml_template_type_0_0 const&__x);
public:vector(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n,__xcodeml_template_type_0_0 const&__x,__xcodeml_template_type_0_1 const&__a);
public:template<typename __xcodeml_template_type_1_0>vector(__xcodeml_template_type_1_0 __first,typename enable_if<expression,__xcodeml_template_type_1_0>::type __last)
public:template<typename __xcodeml_template_type_1_0>vector(__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last,__xcodeml_template_type_0_1 const&__a,typename enable_if<expression,void>::type(*))
public:template<typename __xcodeml_template_type_1_0>vector(__xcodeml_template_type_1_0 __first,typename enable_if<expression,__xcodeml_template_type_1_0>::type __last)
public:template<typename __xcodeml_template_type_1_0>vector(__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last,__xcodeml_template_type_0_1 const&__a,typename enable_if<expression,void>::type(*))
public:~vector(){(this->__annotate_delete());
}
public:vector(class vector const&__x);
public:vector(class vector const&__x,__xcodeml_template_type_0_1 const&__a);
public:class vector&operator=(class vector const&__x);
public:vector(initializer_list<__xcodeml_template_type_0_0>);
public:vector(initializer_list<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_1 const&__a);
public:vector(class vector(*__x));
public:vector(class vector(*__x),__xcodeml_template_type_0_1 const&__a);
public:class vector&operator=(class vector(*__x));
public:class vector&operator=(initializer_list<__xcodeml_template_type_0_0>){(((__il.begin()),(__il.end())));
return(*this);
}
public:template<typename __xcodeml_template_type_1_0>typename enable_if<expression,void>::type assign(__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last)
public:template<typename __xcodeml_template_type_1_0>typename enable_if<expression,void>::type assign(__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last)
public:void assign(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n,typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_reference __u);
public:void assign(initializer_list<__xcodeml_template_type_0_0>){(((__il.begin()),(__il.end())));
}
public:__xcodeml_template_type_0_1 get_allocator()const{return(this.__alloc());
}
public:__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer>;
public:__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_pointer>;
public:__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer>;
public:__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_pointer>;
public:reverse_iterator<__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer> >{return __xcodeml_identity<reverse_iterator<__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer> > >::t((()));
}
public:reverse_iterator<__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_pointer> >{return __xcodeml_identity<reverse_iterator<__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_pointer> > >::t((()));
}
public:reverse_iterator<__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer> >{return __xcodeml_identity<reverse_iterator<__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer> > >::t((()));
}
public:reverse_iterator<__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_pointer> >{return __xcodeml_identity<reverse_iterator<__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_pointer> > >::t((()));
}
public:__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_pointer>{return(());
}
public:__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_pointer>{return(());
}
public:reverse_iterator<__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_pointer> >{return(());
}
public:reverse_iterator<__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_pointer> >{return(());
}
public:typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type size()const{return static_cast<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type>((this.__end_,this.__begin_));
}
public:typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type capacity()const{return(__vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::.capacity());
}
public:bool empty()const{return(this.__begin_,this.__end_);
}
public:typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type max_size()const;
public:void reserve(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n);
public:void shrink_to_fit();
public:typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::reference operator[](typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n);
public:typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_reference operator[](typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n)const;
public:typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::reference at(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n);
public:typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_reference at(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n)const;
public:typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::reference front(){((void)0);
return(*this.__begin_);
}
public:typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_reference front()const{((void)0);
return(*this.__begin_);
}
public:typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::reference back(){((void)0);
return(*(this.__end_,1));
}
public:typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_reference back()const{((void)0);
return(*(this.__end_,1));
}
public:__xcodeml_template_type_0_0(*data()){return(std::__1::(this.__begin_));
}
public:__xcodeml_template_type_0_0 const(*data()const){return(std::__1::(this.__begin_));
}
public:template<typename __xcodeml_template_type_1_0>void __emplace_back(__xcodeml_template_type_1_0(*__arg)){(((std::__1::__xcodeml_template_type_1_0(__arg))));
}
public:void push_back(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_reference __x);
public:void push_back(__xcodeml_template_type_0_0(*__x));
public:template<typename __xcodeml_template_type_1_0>void emplace_back(void/*__args*/)
public:void pop_back();
public:__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer>;
public:__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer>;
public:template<typename __xcodeml_template_type_1_0>__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer>
public:__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer>;
public:template<typename __xcodeml_template_type_1_0>typename enable_if<expression,__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer> >::type insert(__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_pointer>,__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last)
public:template<typename __xcodeml_template_type_1_0>typename enable_if<expression,__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer> >::type insert(__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_pointer>,__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last)
public:__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer>{return((__position,(__il.begin()),(__il.end())));
}
public:__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer>;
public:__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer>;
public:void clear(){typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __old_size=(this->size());
(__vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::.clear());
(this->__annotate_shrink(__old_size));
(this->__invalidate_all_iterators());
}
public:void resize(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __sz);
public:void resize(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __sz,typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_reference __x);
public:void swap(class vector&);
public:bool __invariants()const;
private:
private:void __invalidate_all_iterators();
private:void __invalidate_iterators_past(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer __new_last);
private:void __vallocate(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n);
private:void __vdeallocate();
private:typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __recommend(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __new_size)const;
private:void __construct_at_end(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n);
private:void __construct_at_end(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n,typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_reference __x);
private:template<typename __xcodeml_template_type_1_0>typename enable_if<expression,void>::type __construct_at_end(__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last,typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n)
private:void __append(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n);
private:void __append(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n,typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_reference __x);
private:__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer>;
private:__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_pointer>;
private:void __swap_out_circular_buffer(__split_buffer<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1&>);
private:typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer __swap_out_circular_buffer(__split_buffer<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1&>,typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer __p);
private:void __move_range(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer __from_s,typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer __from_e,typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer __to);
private:void __move_assign(class vector&__c,class::std::__1::integral_constant<bool,1>);
private:void __move_assign(class vector&__c,class::std::__1::integral_constant<bool,0>);
private:void __destruct_at_end(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer __new_last){(this->__invalidate_iterators_past(__new_last));
typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __old_size=(this->size());
(__vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::.__destruct_at_end(__new_last));
(this->__annotate_shrink(__old_size));
}
private:template<typename __xcodeml_template_type_1_0>void __push_back_slow_path(__xcodeml_template_type_1_0(*__x))
private:template<typename __xcodeml_template_type_1_0>void __emplace_back_slow_path(void/*__args*/)
private:void __annotate_contiguous_container(void const(*),void const(*),void const(*),void const(*))const{}
private:void __annotate_new(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __current_size)const{(this->__annotate_contiguous_container((()),((()),(this->capacity())),((()),(this->capacity())),((()),__current_size)));
}
private:void __annotate_delete()const{(this->__annotate_contiguous_container((()),((()),(this->capacity())),((()),(this->size())),((()),(this->capacity()))));
}
private:void __annotate_increase(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n)const{(this->__annotate_contiguous_container((()),((()),(this->capacity())),((()),(this->size())),(((()),(this->size())),__n)));
}
private:void __annotate_shrink(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __old_size)const{(this->__annotate_contiguous_container((()),((()),(this->capacity())),((()),__old_size),((()),(this->size()))));
}
private:class __RAII_IncreaseAnnotator{public:__RAII_IncreaseAnnotator(class vector const&,typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type){}
public:void __done(){}
}
;
}
;
;
void vector::__swap_out_circular_buffer(__split_buffer<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1&>){(this->__annotate_delete());
(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::__alloc_traits::.__construct_backward((this.__alloc()),this.__begin_,this.__end_,__v.__begin_));
(std::__1::(this.__begin_,__v.__begin_));
(std::__1::(this.__end_,__v.__end_));
(std::__1::((this.__end_cap()),(__v.__end_cap())));
(__v.__first_=__v.__begin_);
(this->__annotate_new((this->size())));
(this->__invalidate_all_iterators());
}
typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer vector::__swap_out_circular_buffer(__split_buffer<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1&>,typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer __p){(this->__annotate_delete());
typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer __r=__v.__begin_;
(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::__alloc_traits::.__construct_backward((this.__alloc()),this.__begin_,__p,__v.__begin_));
(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::__alloc_traits::.__construct_forward((this.__alloc()),__p,this.__end_,__v.__end_));
(std::__1::(this.__begin_,__v.__begin_));
(std::__1::(this.__end_,__v.__end_));
(std::__1::((this.__end_cap()),(__v.__end_cap())));
(__v.__first_=__v.__begin_);
(this->__annotate_new((this->size())));
(this->__invalidate_all_iterators());
return __r;
}
void vector::__vallocate(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n){if((__n,(this->max_size()))){(this.__throw_length_error());};
(this.__begin_=(this.__end_=(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::__alloc_traits::.allocate((this.__alloc()),__n))));
((this.__end_cap())=(this.__begin_,__n));
(this->__annotate_new(0));
}
void vector::__vdeallocate(){if((this.__begin_,nullptr)){{(this->clear());
(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::__alloc_traits::.deallocate((this.__alloc()),this.__begin_,(this->capacity())));
(this.__begin_=(this.__end_=((this.__end_cap())=nullptr)));
};};
}
typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type vector::max_size()const{return(std::__1::typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type((typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::__alloc_traits::.max_size((this.__alloc()))),(numeric_limits<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::difference_type>::.max())));
}
typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type vector::__recommend(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __new_size)const{typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type const __ms=(this->max_size());
if((__new_size,__ms)){(this.__throw_length_error());};
typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type const __cap=(this->capacity());
if((__cap,(__ms/2))){return __ms;};
return(std::__1::typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type((2*__cap),__new_size));
}
void vector::__construct_at_end(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n){__xcodeml_template_type_0_1&__a=(this.__alloc());
do{{class::std::__1::vector::__RAII_IncreaseAnnotator __annotator=(*this);
(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::__alloc_traits::.construct(__a,(std::__1::(this.__end_))));
(++this.__end_);
(--__n);
(__annotator.__done());
};}while((__n,0));
}
void vector::__construct_at_end(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n,typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_reference __x){__xcodeml_template_type_0_1&__a=(this.__alloc());
do{{class::std::__1::vector::__RAII_IncreaseAnnotator __annotator=(*this);
(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::__alloc_traits::.construct(__a,(std::__1::(this.__end_)),__x));
(++this.__end_);
(--__n);
(__annotator.__done());
};}while((__n,0));
}
template<typename __xcodeml_template_type_1_0>typename enable_if<expression,void>::type vector::__construct_at_end(__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last,typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n){__xcodeml_template_type_0_1&__a=(this.__alloc());
class::std::__1::vector::__RAII_IncreaseAnnotator __annotator=(*this)__n;
(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::__alloc_traits::.__construct_range_forward(__a,__first,__last,this.__end_));
(__annotator.__done());
}
void vector::__append(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n){if((static_cast<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type>(((this.__end_cap()),this.__end_)),__n)){(this.__construct_at_end(__n));}else{{__xcodeml_template_type_0_1&__a=(this.__alloc());
__split_buffer<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1&> =(this->__recommend(((this->size()),__n)))(this->size())__a;
(__v.__construct_at_end(__n));
((__v));
};};
}
void vector::__append(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n,typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_reference __x){if((static_cast<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type>(((this.__end_cap()),this.__end_)),__n)){(this.__construct_at_end(__n,__x));}else{{__xcodeml_template_type_0_1&__a=(this.__alloc());
__split_buffer<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1&> =(this->__recommend(((this->size()),__n)))(this->size())__a;
(__v.__construct_at_end(__n,__x));
((__v));
};};
}
vector::vector(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n){if((__n,0)){{(this->__vallocate(__n));
((__n));
};};
}
vector::vector(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n,__xcodeml_template_type_0_1 const&__a):(__a){if((__n,0)){{(this->__vallocate(__n));
((__n));
};};
}
vector::vector(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n,__xcodeml_template_type_0_0 const&__x){if((__n,0)){{(this->__vallocate(__n));
((__n,__x));
};};
}
vector::vector(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n,__xcodeml_template_type_0_0 const&__x,__xcodeml_template_type_0_1 const&__a):(__a){if((__n,0)){{(this->__vallocate(__n));
((__n,__x));
};};
}
template<typename __xcodeml_template_type_1_0>vector::vector(__xcodeml_template_type_1_0 __first,typename enable_if<expression,__xcodeml_template_type_1_0>::type __last){{;for(;(__first,__last);(++__first)){(((*__first)));}};
}
template<typename __xcodeml_template_type_1_0>vector::vector(__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last,__xcodeml_template_type_0_1 const&__a,typename enable_if<expression,void>::type(*)):(__a){{;for(;(__first,__last);(++__first)){(((*__first)));}};
}
template<typename __xcodeml_template_type_1_0>vector::vector(__xcodeml_template_type_1_0 __first,typename enable_if<expression,__xcodeml_template_type_1_0>::type __last){typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n=static_cast<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type>((std::__1::(__first,__last)));
if((__n,0)){{(this->__vallocate(__n));
((__first,__last,__n));
};};
}
template<typename __xcodeml_template_type_1_0>vector::vector(__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last,__xcodeml_template_type_0_1 const&__a,typename enable_if<expression,void>::type(*)):(__a){typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n=static_cast<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type>((std::__1::(__first,__last)));
if((__n,0)){{(this->__vallocate(__n));
((__first,__last,__n));
};};
}
vector::vector(class vector const&__x):((typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::__alloc_traits::.select_on_container_copy_construction((__x.__alloc())))){typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n=(__x.size());
if((__n,0)){{(this->__vallocate(__n));
((__x.__begin_,__x.__end_,__n));
};};
}
vector::vector(class vector const&__x,__xcodeml_template_type_0_1 const&__a):(__a){typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n=(__x.size());
if((__n,0)){{(this->__vallocate(__n));
((__x.__begin_,__x.__end_,__n));
};};
}
vector::vector(class vector(*__x)):((std::__1::((__x.__alloc())))){(this.__begin_=__x.__begin_);
(this.__end_=__x.__end_);
((this.__end_cap())=(__x.__end_cap()));
(__x.__begin_=(__x.__end_=((__x.__end_cap())=nullptr)));
}
vector::vector(class vector(*__x),__xcodeml_template_type_0_1 const&__a):(__a){if((__a,(__x.__alloc()))){{(this.__begin_=__x.__begin_);
(this.__end_=__x.__end_);
((this.__end_cap())=(__x.__end_cap()));
(__x.__begin_=(__x.__end_=((__x.__end_cap())=nullptr)));
};}else{{typedef move_iterator<__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer> >;
((__xcodeml_identity<move_iterator<__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer> > >::t((__x.begin())),__xcodeml_identity<move_iterator<__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer> > >::t((__x.end()))));
};};
}
vector::vector(initializer_list<__xcodeml_template_type_0_0>){if(((__il.size()),0)){{(this->__vallocate((__il.size())));
(((__il.begin()),(__il.end()),(__il.size())));
};};
}
vector::vector(initializer_list<__xcodeml_template_type_0_0>,__xcodeml_template_type_0_1 const&__a):(__a){if(((__il.size()),0)){{(this->__vallocate((__il.size())));
(((__il.begin()),(__il.end()),(__il.size())));
};};
}
class vector&vector::operator=(class vector(*__x)){((__x,__xcodeml_identity<integral_constant<bool,expression> >::t()));
return(*this);
}
void vector::__move_assign(class vector&__c,class::std::__1::integral_constant<bool,0>){if(((__vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::.__alloc()),(__c.__alloc()))){{typedef move_iterator<__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer> >;
((__xcodeml_identity<move_iterator<__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer> > >::t((__c.begin())),__xcodeml_identity<move_iterator<__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer> > >::t((__c.end()))));
};}else{((__c,__xcodeml_identity<class::std::__1::integral_constant<bool,1> >::t()));};
}
void vector::__move_assign(class vector&__c,class::std::__1::integral_constant<bool,1>){(this->__vdeallocate());
(__vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::.__move_assign_alloc(__c));
(this.__begin_=__c.__begin_);
(this.__end_=__c.__end_);
((this.__end_cap())=(__c.__end_cap()));
(__c.__begin_=(__c.__end_=((__c.__end_cap())=nullptr)));
}
class vector&vector::operator=(class vector const&__x){if((this,(&__x))){{(__vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::.__copy_assign_alloc(__x));
((__x.__begin_,__x.__end_));
};};
return(*this);
}
template<typename __xcodeml_template_type_1_0>typename enable_if<expression,void>::type vector::assign(__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last){(this->clear());
{;for(;(__first,__last);(++__first)){(((*__first)));}};
}
template<typename __xcodeml_template_type_1_0>typename enable_if<expression,void>::type vector::assign(__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last){typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __new_size=static_cast<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type>((std::__1::(__first,__last)));
if((__new_size,(this->capacity()))){{__xcodeml_template_type_1_0 __mid=__last;
bool __growing=false;
if((__new_size,(this->size()))){{(__growing=true);
(__mid=__first);
(std::__1::(__mid,(this->size())));
};};
typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer __m=(std::__1::(__first,__mid,this.__begin_));
if(__growing){((__mid,__last,(__new_size,(this->size()))));}else{(this.__destruct_at_end(__m));};
};}else{{(this->__vdeallocate());
(this->__vallocate((this->__recommend(__new_size))));
((__first,__last,__new_size));
};};
(this->__invalidate_all_iterators());
}
void vector::assign(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n,typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_reference __u){if((__n,(this->capacity()))){{typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __s=(this->size());
(std::__1::(this.__begin_,(std::__1::(__n,__s)),__u));
if((__n,__s)){(((__n,__s),__u));}else{(this.__destruct_at_end((this.__begin_,__n)));};
};}else{{(this->__vdeallocate());
(this->__vallocate((this->__recommend(static_cast<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type>(__n)))));
((__n,__u));
};};
(this->__invalidate_all_iterators());
}
__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer>{return __xcodeml_identity<__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer> >::t(__p);
}
__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_pointer>{return __xcodeml_identity<__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_pointer> >::t(__p);
}
__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer>{return((this.__begin_));
}
__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_pointer>{return((this.__begin_));
}
__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer>{return((this.__end_));
}
__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_pointer>{return((this.__end_));
}
typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::reference vector::operator[](typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n){((void)0);
return(this.__begin_)[__n];
}
typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_reference vector::operator[](typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n)const{((void)0);
return(this.__begin_)[__n];
}
typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::reference vector::at(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n){if((__n,(this->size()))){(this.__throw_out_of_range());};
return(this.__begin_)[__n];
}
typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_reference vector::at(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n)const{if((__n,(this->size()))){(this.__throw_out_of_range());};
return(this.__begin_)[__n];
}
void vector::reserve(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __n){if((__n,(this->capacity()))){{__xcodeml_template_type_0_1&__a=(this.__alloc());
__split_buffer<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1&> =__n(this->size())__a;
((__v));
};};
}
void vector::shrink_to_fit(){if(((this->capacity()),(this->size()))){{try{__xcodeml_template_type_0_1&__a=(this.__alloc());
__split_buffer<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1&> =(this->size())(this->size())__a;
((__v));
}catch(...){}
;
};};
}
template<typename __xcodeml_template_type_1_0>void vector::__push_back_slow_path(__xcodeml_template_type_1_0(*__x)){__xcodeml_template_type_0_1&__a=(this.__alloc());
__split_buffer<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1&> =(this->__recommend(((this->size()),1)))(this->size())__a;
(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::__alloc_traits::.construct(__a,(std::__1::(__v.__end_)),(std::__1::__xcodeml_template_type_1_0(__x))));
(__v.__end_++);
((__v));
}
void vector::push_back(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_reference __x){if((this.__end_,(this.__end_cap()))){{class::std::__1::vector::__RAII_IncreaseAnnotator __annotator=(*this);
(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::__alloc_traits::.construct((this.__alloc()),(std::__1::(this.__end_)),__x));
(__annotator.__done());
(++this.__end_);
};}else{((__x));};
}
void vector::push_back(__xcodeml_template_type_0_0(*__x)){if((this.__end_,(this.__end_cap()))){{class::std::__1::vector::__RAII_IncreaseAnnotator __annotator=(*this);
(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::__alloc_traits::.construct((this.__alloc()),(std::__1::(this.__end_)),(std::__1::(__x))));
(__annotator.__done());
(++this.__end_);
};}else{(((std::__1::(__x))));};
}
template<typename __xcodeml_template_type_1_0>void vector::__emplace_back_slow_path(void/*__args*/){__xcodeml_template_type_0_1&__a=(this.__alloc());
__split_buffer<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1&> =(this->__recommend(((this->size()),1)))(this->size())__a;
(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::__alloc_traits::.construct(__a,(std::__1::(__v.__end_)),(std::__1::__xcodeml_template_type_1_0(__args))));
(__v.__end_++);
((__v));
}
template<typename __xcodeml_template_type_1_0>void vector::emplace_back(void/*__args*/){if((this.__end_,(this.__end_cap()))){{class::std::__1::vector::__RAII_IncreaseAnnotator __annotator=(*this);
(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::__alloc_traits::.construct((this.__alloc()),(std::__1::(this.__end_)),(std::__1::__xcodeml_template_type_1_0(__args))));
(__annotator.__done());
(++this.__end_);
};}else{(((std::__1::__xcodeml_template_type_1_0(__args))));};
}
void vector::pop_back(){((void)0);
(this.__destruct_at_end((this.__end_,1)));
}
__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer>{((void)0);
typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::difference_type __ps=(__position,(this->cbegin()));
typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer __p=(this.__begin_,__ps);
(this.__destruct_at_end((std::__1::((__p,1),this.__end_,__p))));
(this.__invalidate_iterators_past((__p,1)));
__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer> =((__p));
return __r;
}
__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer>{((void)0);
typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer __p=(this.__begin_,(__first,(())));
if((__first,__last)){{(this.__destruct_at_end((std::__1::((__p,(__last,__first)),this.__end_,__p))));
(this.__invalidate_iterators_past((__p,1)));
};};
__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer> =((__p));
return __r;
}
void vector::__move_range(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer __from_s,typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer __from_e,typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer __to){typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer __old_last=this.__end_;
typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::difference_type __n=(__old_last,__to);
{typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer __i=(__from_s,__n);for(;(__i,__from_e);((++__i),(++this.__end_))){(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::__alloc_traits::.construct((this.__alloc()),(std::__1::(this.__end_)),(std::__1::((*__i)))));}};
(std::__1::(__from_s,(__from_s,__n),__old_last));
}
__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer>{typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer __p=(this.__begin_,(__position,(())));
if((this.__end_,(this.__end_cap()))){{class::std::__1::vector::__RAII_IncreaseAnnotator __annotator=(*this);
if((__p,this.__end_)){{(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::__alloc_traits::.construct((this.__alloc()),(std::__1::(this.__end_)),__x));
(++this.__end_);
};}else{{(this->__move_range(__p,this.__end_,(__p,1)));
typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_pointer __xr=(pointer_traits<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_pointer>::.pointer_to(__x));
if(((__p,__xr)&&(__xr,this.__end_))){(++__xr);};
((*__p)=(*__xr));
};};
(__annotator.__done());
};}else{{__xcodeml_template_type_0_1&__a=(this.__alloc());
__split_buffer<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1&> =(this->__recommend(((this->size()),1)))(__p,this.__begin_)__a;
(__v.push_back(__x));
(__p=((__v,__p)));
};};
return((__p));
}
__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer>{typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer __p=(this.__begin_,(__position,(())));
if((this.__end_,(this.__end_cap()))){{class::std::__1::vector::__RAII_IncreaseAnnotator __annotator=(*this);
if((__p,this.__end_)){{(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::__alloc_traits::.construct((this.__alloc()),(std::__1::(this.__end_)),(std::__1::(__x))));
(++this.__end_);
};}else{{(this->__move_range(__p,this.__end_,(__p,1)));
((*__p)=(std::__1::(__x)));
};};
(__annotator.__done());
};}else{{__xcodeml_template_type_0_1&__a=(this.__alloc());
__split_buffer<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1&> =(this->__recommend(((this->size()),1)))(__p,this.__begin_)__a;
(__v.push_back((std::__1::(__x))));
(__p=((__v,__p)));
};};
return((__p));
}
template<typename __xcodeml_template_type_1_0>__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer>{typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer __p=(this.__begin_,(__position,(())));
if((this.__end_,(this.__end_cap()))){{class::std::__1::vector::__RAII_IncreaseAnnotator __annotator=(*this);
if((__p,this.__end_)){{(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::__alloc_traits::.construct((this.__alloc()),(std::__1::(this.__end_)),(std::__1::__xcodeml_template_type_1_0(__args))));
(++this.__end_);
};}else{{__temp_value<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1> =(this.__alloc())(std::__1::__xcodeml_template_type_1_0(__args));
(this->__move_range(__p,this.__end_,(__p,1)));
((*__p)=(std::__1::((__tmp.get()))));
};};
(__annotator.__done());
};}else{{__xcodeml_template_type_0_1&__a=(this.__alloc());
__split_buffer<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1&> =(this->__recommend(((this->size()),1)))(__p,this.__begin_)__a;
(__v.emplace_back((std::__1::__xcodeml_template_type_1_0(__args))));
(__p=((__v,__p)));
};};
return((__p));
}
__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer>{typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer __p=(this.__begin_,(__position,(())));
if((__n,0)){{if((__n,static_cast<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type>(((this.__end_cap()),this.__end_)))){{typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __old_n=__n;
typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer __old_last=this.__end_;
if((__n,static_cast<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type>((this.__end_,__p)))){{typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __cx=(__n,(this.__end_,__p));
((__cx,__x));
(__n-=__cx);
};};
if((__n,0)){{class::std::__1::vector::__RAII_IncreaseAnnotator __annotator=(*this)__n;
(this->__move_range(__p,__old_last,(__p,__old_n)));
(__annotator.__done());
typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_pointer __xr=(pointer_traits<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_pointer>::.pointer_to(__x));
if(((__p,__xr)&&(__xr,this.__end_))){(__xr+=__old_n);};
(std::__1::(__p,__n,(*__xr)));
};};
};}else{{__xcodeml_template_type_0_1&__a=(this.__alloc());
__split_buffer<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1&> =(this->__recommend(((this->size()),__n)))(__p,this.__begin_)__a;
(__v.__construct_at_end(__n,__x));
(__p=((__v,__p)));
};};
};};
return((__p));
}
template<typename __xcodeml_template_type_1_0>typename enable_if<expression,__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer> >::type vector::insert(__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_pointer>,__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last){typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::difference_type __off=(__position,(()));
typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer __p=(this.__begin_,__off);
__xcodeml_template_type_0_1&__a=(this.__alloc());
typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer __old_last=this.__end_;
{;for(;((this.__end_,(this.__end_cap()))&&(__first,__last));(++__first)){{class::std::__1::vector::__RAII_IncreaseAnnotator __annotator=(*this);
(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::__alloc_traits::.construct(__a,(std::__1::(this.__end_)),(*__first)));
(++this.__end_);
(__annotator.__done());
};}};
__split_buffer<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1&> =__a;
if((__first,__last)){{try{(__v.__construct_at_end(__first,__last));
typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::difference_type __old_size=(__old_last,this.__begin_);
typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::difference_type __old_p=(__p,this.__begin_);
(this->reserve((this->__recommend(((this->size()),(__v.size()))))));
(__p=(this.__begin_,__old_p));
(__old_last=(this.__begin_,__old_size));
}catch(...){((((__old_last)),(())));
throw;
}
;
};};
(__p=(std::__1::(__p,__old_last,this.__end_)));
((((__p)),(((__v.begin()))),(((__v.end())))));
return((()),__off);
}
template<typename __xcodeml_template_type_1_0>typename enable_if<expression,__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer> >::type vector::insert(__wrap_iter<typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_pointer>,__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last){typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer __p=(this.__begin_,(__position,(())));
typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::difference_type __n=(std::__1::(__first,__last));
if((__n,0)){{if((__n,((this.__end_cap()),this.__end_))){{typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __old_n=__n;
typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer __old_last=this.__end_;
__xcodeml_template_type_1_0 __m=__last;
typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::difference_type __dx=(this.__end_,__p);
if((__n,__dx)){{(__m=__first);
typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::difference_type __diff=(this.__end_,__p);
(std::__1::(__m,__diff));
((__m,__last,(__n,__diff)));
(__n=__dx);
};};
if((__n,0)){{class::std::__1::vector::__RAII_IncreaseAnnotator __annotator=(*this)__n;
(this->__move_range(__p,__old_last,(__p,__old_n)));
(__annotator.__done());
(std::__1::(__first,__m,__p));
};};
};}else{{__xcodeml_template_type_0_1&__a=(this.__alloc());
__split_buffer<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1&> =(this->__recommend(((this->size()),__n)))(__p,this.__begin_)__a;
(__v.__construct_at_end(__first,__last));
(__p=((__v,__p)));
};};
};};
return((__p));
}
void vector::resize(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __sz){typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __cs=(this->size());
if((__cs,__sz)){(this.__append((__sz,__cs)));}else{if((__cs,__sz)){(this.__destruct_at_end((this.__begin_,__sz)));};};
}
void vector::resize(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __sz,typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::const_reference __x){typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type __cs=(this->size());
if((__cs,__sz)){(this.__append((__sz,__cs),__x));}else{if((__cs,__sz)){(this.__destruct_at_end((this.__begin_,__sz)));};};
}
void vector::swap(class vector&__x){((void)0);
(std::__1::(this.__begin_,__x.__begin_));
(std::__1::(this.__end_,__x.__end_));
(std::__1::((this.__end_cap()),(__x.__end_cap())));
(((this.__alloc()),(__x.__alloc()),__xcodeml_identity<integral_constant<bool,expression> >::t()));
}
bool vector::__invariants()const{if((this.__begin_,nullptr)){{if(((this.__end_,nullptr)||((this.__end_cap()),nullptr))){return false;};
};}else{{if((this.__begin_,this.__end_)){return false;};
if((this.__begin_,(this.__end_cap()))){return false;};
if((this.__end_,(this.__end_cap()))){return false;};
};};
return true;
}
void vector::__invalidate_all_iterators(){}
void vector::__invalidate_iterators_past(typename __vector_base<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::pointer __new_last){((void)__new_last);
}
template<typename __xcodeml_template_type_0_0>class vector;
template<typename __xcodeml_template_type_0_0>class hash;
template<typename __xcodeml_template_type_0_0>class __has_storage_type<vector<bool,__xcodeml_template_type_0_0> >{public:static bool const value=true;
}
;
template<typename __xcodeml_template_type_0_0>class vector<bool,__xcodeml_template_type_0_0>:private __vector_base_common<1>{public:
public:typedef class vector<bool,__xcodeml_template_type_0_0>__self;
public:typedef bool value_type;
public:typedef __xcodeml_template_type_0_0 allocator_type;
public:typedef allocator_traits<__xcodeml_template_type_0_0>;
public:typedef typename allocator_traits<__xcodeml_template_type_0_0>::size_type size_type;
public:typedef typename allocator_traits<__xcodeml_template_type_0_0>::difference_type difference_type;
public:typedef typename allocator_traits<__xcodeml_template_type_0_0>::size_type __storage_type;
public:typedef __bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression>;
public:typedef __bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,1,expression>;
public:typedef __bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression>;
public:typedef __bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,1,expression>;
public:typedef reverse_iterator<__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression> >;
public:typedef reverse_iterator<__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,1,expression> >;
private:
private:typedef typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_0>,typename allocator_traits<__xcodeml_template_type_0_0>::size_type>::type __storage_allocator;
private:typedef allocator_traits<typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_0>,typename allocator_traits<__xcodeml_template_type_0_0>::size_type>::type>;
private:typedef typename allocator_traits<typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_0>,typename allocator_traits<__xcodeml_template_type_0_0>::size_type>::type>::pointer __storage_pointer;
private:typedef typename allocator_traits<typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_0>,typename allocator_traits<__xcodeml_template_type_0_0>::size_type>::type>::const_pointer __const_storage_pointer;
private:typename allocator_traits<typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_0>,typename allocator_traits<__xcodeml_template_type_0_0>::size_type>::type>::pointer __begin_;
private:typename allocator_traits<__xcodeml_template_type_0_0>::size_type __size_;
private:__compressed_pair<typename allocator_traits<__xcodeml_template_type_0_0>::size_type,typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_0>,typename allocator_traits<__xcodeml_template_type_0_0>::size_type>::type>;
public:
public:typedef __bit_reference<class vector<bool,__xcodeml_template_type_0_0>,expression>;
public:typedef __bit_const_reference<class vector<bool,__xcodeml_template_type_0_0> >;
private:
private:typename allocator_traits<__xcodeml_template_type_0_0>::size_type&__cap(){return(this->__cap_alloc_.first());
}
private:typename allocator_traits<__xcodeml_template_type_0_0>::size_type const&__cap()const{return(this->__cap_alloc_.first());
}
private:typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_0>,typename allocator_traits<__xcodeml_template_type_0_0>::size_type>::type&__alloc(){return(this->__cap_alloc_.second());
}
private:typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_0>,typename allocator_traits<__xcodeml_template_type_0_0>::size_type>::type const&__alloc()const{return(this->__cap_alloc_.second());
}
private:static unsigned int const __bits_per_word=static_cast<>(((sizeof(typename allocator_traits<__xcodeml_template_type_0_0>::size_type))*8));
private:static typename allocator_traits<__xcodeml_template_type_0_0>::size_type __internal_cap_to_external(typename allocator_traits<__xcodeml_template_type_0_0>::size_type __n){return(__n*__bits_per_word);
}
private:static typename allocator_traits<__xcodeml_template_type_0_0>::size_type __external_cap_to_internal(typename allocator_traits<__xcodeml_template_type_0_0>::size_type __n){return(((__n,1)/__bits_per_word),1);
}
public:
public:vector();
public:vector(__xcodeml_template_type_0_0 const&__a);
public:~vector();
public:vector(typename allocator_traits<__xcodeml_template_type_0_0>::size_type __n);
public:vector(typename allocator_traits<__xcodeml_template_type_0_0>::size_type __n,__xcodeml_template_type_0_0 const&__a);
public:vector(typename allocator_traits<__xcodeml_template_type_0_0>::size_type __n,bool const&__v);
public:vector(typename allocator_traits<__xcodeml_template_type_0_0>::size_type __n,bool const&__v,__xcodeml_template_type_0_0 const&__a);
public:template<typename __xcodeml_template_type_1_0>vector(__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last,typename enable_if<expression,void>::type(*))
public:template<typename __xcodeml_template_type_1_0>vector(__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last,__xcodeml_template_type_0_0 const&__a,typename enable_if<expression,void>::type(*))
public:template<typename __xcodeml_template_type_1_0>vector(__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last,typename enable_if<expression,void>::type(*))
public:template<typename __xcodeml_template_type_1_0>vector(__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last,__xcodeml_template_type_0_0 const&__a,typename enable_if<expression,void>::type(*))
public:vector(class vector const&__v);
public:vector(class vector const&__v,__xcodeml_template_type_0_0 const&__a);
public:class vector<bool,__xcodeml_template_type_0_0>&operator=(class vector const&__v);
public:vector(class::std::initializer_list<bool>__il);
public:vector(class::std::initializer_list<bool>__il,__xcodeml_template_type_0_0 const&__a);
public:vector(class vector<bool,__xcodeml_template_type_0_0>(*__v));
public:vector(class vector<bool,__xcodeml_template_type_0_0>(*__v),__xcodeml_template_type_0_0 const&__a);
public:class vector<bool,__xcodeml_template_type_0_0>&operator=(class vector<bool,__xcodeml_template_type_0_0>(*__v));
public:class vector<bool,__xcodeml_template_type_0_0>&operator=(class::std::initializer_list<bool>__il){(((__il.begin()),(__il.end())));
return(*this);
}
public:template<typename __xcodeml_template_type_1_0>typename enable_if<expression,void>::type assign(__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last)
public:template<typename __xcodeml_template_type_1_0>typename enable_if<expression,void>::type assign(__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last)
public:void assign(typename allocator_traits<__xcodeml_template_type_0_0>::size_type __n,bool const&__x);
public:void assign(class::std::initializer_list<bool>__il){(((__il.begin()),(__il.end())));
}
public:__xcodeml_template_type_0_0 get_allocator()const{return __xcodeml_identity<__xcodeml_template_type_0_0>::t((this.__alloc()));
}
public:typename allocator_traits<__xcodeml_template_type_0_0>::size_type max_size()const;
public:typename allocator_traits<__xcodeml_template_type_0_0>::size_type capacity()const{return(__internal_cap_to_external((())));
}
public:typename allocator_traits<__xcodeml_template_type_0_0>::size_type size()const{return this->__size_;
}
public:bool empty()const{return(this->__size_,0);
}
public:void reserve(typename allocator_traits<__xcodeml_template_type_0_0>::size_type __n);
public:void shrink_to_fit();
public:__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression>{return((0));
}
public:__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,1,expression>{return((0));
}
public:__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression>{return((this->__size_));
}
public:__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,1,expression>{return((this->__size_));
}
public:reverse_iterator<__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression> >{return __xcodeml_identity<reverse_iterator<__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression> > >::t((()));
}
public:reverse_iterator<__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,1,expression> >{return __xcodeml_identity<reverse_iterator<__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,1,expression> > >::t((()));
}
public:reverse_iterator<__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression> >{return __xcodeml_identity<reverse_iterator<__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression> > >::t((()));
}
public:reverse_iterator<__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,1,expression> >{return __xcodeml_identity<reverse_iterator<__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,1,expression> > >::t((()));
}
public:__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,1,expression>{return((0));
}
public:__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,1,expression>{return((this->__size_));
}
public:reverse_iterator<__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,1,expression> >{return(());
}
public:reverse_iterator<__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,1,expression> >{return(());
}
public:__bit_reference<class vector<bool,__xcodeml_template_type_0_0>,expression>{return((__n));
}
public:__bit_const_reference<class vector<bool,__xcodeml_template_type_0_0> >{return((__n));
}
public:__bit_reference<class vector<bool,__xcodeml_template_type_0_0>,expression>;
public:__bit_const_reference<class vector<bool,__xcodeml_template_type_0_0> >;
public:__bit_reference<class vector<bool,__xcodeml_template_type_0_0>,expression>{return((0));
}
public:__bit_const_reference<class vector<bool,__xcodeml_template_type_0_0> >{return((0));
}
public:__bit_reference<class vector<bool,__xcodeml_template_type_0_0>,expression>{return(((this->__size_,1)));
}
public:__bit_const_reference<class vector<bool,__xcodeml_template_type_0_0> >{return(((this->__size_,1)));
}
public:void push_back(bool const&__x);
public:template<typename __xcodeml_template_type_1_0>void emplace_back(void/*__args*/){(this->push_back(__xcodeml_identity<bool>::t((std::__1::__xcodeml_template_type_1_0(__args)))));
}
public:void pop_back(){(--this->__size_);
}
public:template<typename __xcodeml_template_type_1_0>__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression>{return((position,__xcodeml_identity<bool>::t((std::__1::__xcodeml_template_type_1_0(__args)))));
}
public:__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression>;
public:__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression>;
public:__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression>;
public:template<typename __xcodeml_template_type_1_0>typename enable_if<expression,__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression> >::type insert(__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,1,expression>,__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last)
public:template<typename __xcodeml_template_type_1_0>typename enable_if<expression,__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression> >::type insert(__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,1,expression>,__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last)
public:__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression>{return((__position,(__il.begin()),(__il.end())));
}
public:__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression>;
public:__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression>;
public:void clear(){(this->__size_=0);
}
public:void swap(class vector<bool,__xcodeml_template_type_0_0>&);
public:static void swap(__bit_reference<class vector<bool,__xcodeml_template_type_0_0>,expression>,__bit_reference<class vector<bool,__xcodeml_template_type_0_0>,expression>){(std::__1::(__x,__y));
}
public:void resize(typename allocator_traits<__xcodeml_template_type_0_0>::size_type __sz,bool __x);
public:void flip();
public:bool __invariants()const;
private:
private:void __invalidate_all_iterators();
private:void __vallocate(typename allocator_traits<__xcodeml_template_type_0_0>::size_type __n);
private:void __vdeallocate();
private:static typename allocator_traits<__xcodeml_template_type_0_0>::size_type __align_it(typename allocator_traits<__xcodeml_template_type_0_0>::size_type __new_size){return((__new_size,(__bits_per_word-1))&(~(((typename allocator_traits<__xcodeml_template_type_0_0>::size_type)__bits_per_word),1)));
}
private:typename allocator_traits<__xcodeml_template_type_0_0>::size_type __recommend(typename allocator_traits<__xcodeml_template_type_0_0>::size_type __new_size)const;
private:void __construct_at_end(typename allocator_traits<__xcodeml_template_type_0_0>::size_type __n,bool __x);
private:template<typename __xcodeml_template_type_1_0>typename enable_if<expression,void>::type __construct_at_end(__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last)
private:void __append(typename allocator_traits<__xcodeml_template_type_0_0>::size_type __n,__bit_const_reference<class vector<bool,__xcodeml_template_type_0_0> >);
private:__bit_reference<class vector<bool,__xcodeml_template_type_0_0>,expression>{return __xcodeml_identity<__bit_reference<class vector<bool,__xcodeml_template_type_0_0>,expression> >::t((this->__begin_,(__pos/__bits_per_word)),(__xcodeml_identity<typename allocator_traits<__xcodeml_template_type_0_0>::size_type>::t(1),(__pos%__bits_per_word)));
}
private:__bit_const_reference<class vector<bool,__xcodeml_template_type_0_0> >{return __xcodeml_identity<__bit_const_reference<class vector<bool,__xcodeml_template_type_0_0> > >::t((this->__begin_,(__pos/__bits_per_word)),(__xcodeml_identity<typename allocator_traits<__xcodeml_template_type_0_0>::size_type>::t(1),(__pos%__bits_per_word)));
}
private:__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression>{return __xcodeml_identity<__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression> >::t((this->__begin_,(__pos/__bits_per_word)),static_cast<unsigned int>((__pos%__bits_per_word)));
}
private:__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,1,expression>{return __xcodeml_identity<__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,1,expression> >::t((this->__begin_,(__pos/__bits_per_word)),static_cast<unsigned int>((__pos%__bits_per_word)));
}
private:__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression>{return((()),(__p,(this->cbegin())));
}
private:void __copy_assign_alloc(class vector const&__v){((__v,__xcodeml_identity<integral_constant<bool,expression> >::t()));
}
private:void __copy_assign_alloc(class vector const&__c,class::std::__1::integral_constant<bool,1>){if(((()),(__c.__alloc()))){(this->__vdeallocate());};
((())=(__c.__alloc()));
}
private:void __copy_assign_alloc(class vector const&,class::std::__1::integral_constant<bool,0>){}
private:void __move_assign(class vector<bool,__xcodeml_template_type_0_0>&__c,class::std::__1::integral_constant<bool,0>);
private:void __move_assign(class vector<bool,__xcodeml_template_type_0_0>&__c,class::std::__1::integral_constant<bool,1>);
private:void __move_assign_alloc(class vector<bool,__xcodeml_template_type_0_0>&__c){((__c,__xcodeml_identity<integral_constant<bool,expression> >::t()));
}
private:void __move_assign_alloc(class vector<bool,__xcodeml_template_type_0_0>&__c,class::std::__1::integral_constant<bool,1>){((())=(std::__1::((__c.__alloc()))));
}
private:void __move_assign_alloc(class vector<bool,__xcodeml_template_type_0_0>&,class::std::__1::integral_constant<bool,0>){}
private:unsigned long __hash_code()const;
public:friend __bit_reference<class vector<bool,__xcodeml_template_type_0_0>,expression>;
public:friend __bit_const_reference<class vector<bool,__xcodeml_template_type_0_0> >;
public:friend __bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression>;
public:friend __bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,1,expression>;
public:friend __bit_array<class vector<bool,__xcodeml_template_type_0_0> >;
public:friend hash<class vector<bool,__xcodeml_template_type_0_0> >;
}
;
void vector::__invalidate_all_iterators(){}
void vector::__vallocate(typename allocator_traits<__xcodeml_template_type_0_0>::size_type __n){if((__n,(this->max_size()))){(this.__throw_length_error());};
(__n=(__external_cap_to_internal(__n)));
(this.__begin_=(allocator_traits<typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_0>,typename allocator_traits<__xcodeml_template_type_0_0>::size_type>::type>::.allocate((this.__alloc()),__n)));
(this.__size_=0);
((this.__cap())=__n);
}
void vector::__vdeallocate(){if((this.__begin_,nullptr)){{(allocator_traits<typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_0>,typename allocator_traits<__xcodeml_template_type_0_0>::size_type>::type>::.deallocate((this.__alloc()),this.__begin_,(())));
(this->__invalidate_all_iterators());
(this.__begin_=nullptr);
(this.__size_=((this.__cap())=0));
};};
}
typename allocator_traits<__xcodeml_template_type_0_0>::size_type vector::max_size()const{typename allocator_traits<__xcodeml_template_type_0_0>::size_type __amax=(allocator_traits<typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_0>,typename allocator_traits<__xcodeml_template_type_0_0>::size_type>::type>::.max_size((())));
typename allocator_traits<__xcodeml_template_type_0_0>::size_type __nmax=((numeric_limits<typename allocator_traits<__xcodeml_template_type_0_0>::size_type>::.max())/2);
if(((__nmax/__bits_per_word),__amax)){return __nmax;};
return(__internal_cap_to_external(__amax));
}
typename allocator_traits<__xcodeml_template_type_0_0>::size_type vector::__recommend(typename allocator_traits<__xcodeml_template_type_0_0>::size_type __new_size)const{typename allocator_traits<__xcodeml_template_type_0_0>::size_type const __ms=(this->max_size());
if((__new_size,__ms)){(this.__throw_length_error());};
typename allocator_traits<__xcodeml_template_type_0_0>::size_type const __cap=(this->capacity());
if((__cap,(__ms/2))){return __ms;};
return(std::__1::((2*__cap),(__align_it(__new_size))));
}
void vector::__construct_at_end(typename allocator_traits<__xcodeml_template_type_0_0>::size_type __n,bool __x){typename allocator_traits<__xcodeml_template_type_0_0>::size_type __old_size=this.__size_;
(this.__size_+=__n);
if(((__old_size,0)||(((__old_size,1)/__bits_per_word),((this.__size_,1)/__bits_per_word)))){{if((this.__size_,__bits_per_word)){((this.__begin_)[0]=__xcodeml_identity<typename allocator_traits<__xcodeml_template_type_0_0>::size_type>::t(0));}else{((this.__begin_)[((this.__size_,1)/__bits_per_word)]=__xcodeml_identity<typename allocator_traits<__xcodeml_template_type_0_0>::size_type>::t(0));};
};};
(std::__1::(((__old_size)),__n,__x));
}
template<typename __xcodeml_template_type_1_0>typename enable_if<expression,void>::type vector::__construct_at_end(__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last){typename allocator_traits<__xcodeml_template_type_0_0>::size_type __old_size=this.__size_;
(this.__size_+=(std::__1::(__first,__last)));
if(((__old_size,0)||(((__old_size,1)/__bits_per_word),((this.__size_,1)/__bits_per_word)))){{if((this.__size_,__bits_per_word)){((this.__begin_)[0]=__xcodeml_identity<typename allocator_traits<__xcodeml_template_type_0_0>::size_type>::t(0));}else{((this.__begin_)[((this.__size_,1)/__bits_per_word)]=__xcodeml_identity<typename allocator_traits<__xcodeml_template_type_0_0>::size_type>::t(0));};
};};
(std::__1::(__first,__last,((__old_size))));
}
vector::vector():__begin_(nullptr),__size_(0),__cap_alloc_(0){}
vector::vector(__xcodeml_template_type_0_0 const&__a):__begin_(nullptr),__size_(0),__cap_alloc_(0 static_cast<typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_0>,typename allocator_traits<__xcodeml_template_type_0_0>::size_type>::type>(__a)){}
vector::vector(typename allocator_traits<__xcodeml_template_type_0_0>::size_type __n):__begin_(nullptr),__size_(0),__cap_alloc_(0){if((__n,0)){{(this->__vallocate(__n));
((__n,false));
};};
}
vector::vector(typename allocator_traits<__xcodeml_template_type_0_0>::size_type __n,__xcodeml_template_type_0_0 const&__a):__begin_(nullptr),__size_(0),__cap_alloc_(0 static_cast<typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_0>,typename allocator_traits<__xcodeml_template_type_0_0>::size_type>::type>(__a)){if((__n,0)){{(this->__vallocate(__n));
((__n,false));
};};
}
vector::vector(typename allocator_traits<__xcodeml_template_type_0_0>::size_type __n,bool const&__x):__begin_(nullptr),__size_(0),__cap_alloc_(0){if((__n,0)){{(this->__vallocate(__n));
((__n,__x));
};};
}
vector::vector(typename allocator_traits<__xcodeml_template_type_0_0>::size_type __n,bool const&__x,__xcodeml_template_type_0_0 const&__a):__begin_(nullptr),__size_(0),__cap_alloc_(0 static_cast<typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_0>,typename allocator_traits<__xcodeml_template_type_0_0>::size_type>::type>(__a)){if((__n,0)){{(this->__vallocate(__n));
((__n,__x));
};};
}
template<typename __xcodeml_template_type_1_0>vector::vector(__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last,typename enable_if<expression,void>::type(*)):__begin_(nullptr),__size_(0),__cap_alloc_(0){try{{;for(;(__first,__last);(++__first)){(this->push_back((*__first)));}};
}catch(...){if((this->__begin_,nullptr)){(allocator_traits<typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_0>,typename allocator_traits<__xcodeml_template_type_0_0>::size_type>::type>::.deallocate((()),this->__begin_,(())));};
(this->__invalidate_all_iterators());
throw;
}
;
}
template<typename __xcodeml_template_type_1_0>vector::vector(__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last,__xcodeml_template_type_0_0 const&__a,typename enable_if<expression,void>::type(*)):__begin_(nullptr),__size_(0),__cap_alloc_(0 static_cast<typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_0>,typename allocator_traits<__xcodeml_template_type_0_0>::size_type>::type>(__a)){try{{;for(;(__first,__last);(++__first)){(this->push_back((*__first)));}};
}catch(...){if((this->__begin_,nullptr)){(allocator_traits<typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_0>,typename allocator_traits<__xcodeml_template_type_0_0>::size_type>::type>::.deallocate((()),this->__begin_,(())));};
(this->__invalidate_all_iterators());
throw;
}
;
}
template<typename __xcodeml_template_type_1_0>vector::vector(__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last,typename enable_if<expression,void>::type(*)):__begin_(nullptr),__size_(0),__cap_alloc_(0){typename allocator_traits<__xcodeml_template_type_0_0>::size_type __n=static_cast<typename allocator_traits<__xcodeml_template_type_0_0>::size_type>((std::__1::(__first,__last)));
if((__n,0)){{(this->__vallocate(__n));
((__first,__last));
};};
}
template<typename __xcodeml_template_type_1_0>vector::vector(__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last,__xcodeml_template_type_0_0 const&__a,typename enable_if<expression,void>::type(*)):__begin_(nullptr),__size_(0),__cap_alloc_(0 static_cast<typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_0>,typename allocator_traits<__xcodeml_template_type_0_0>::size_type>::type>(__a)){typename allocator_traits<__xcodeml_template_type_0_0>::size_type __n=static_cast<typename allocator_traits<__xcodeml_template_type_0_0>::size_type>((std::__1::(__first,__last)));
if((__n,0)){{(this->__vallocate(__n));
((__first,__last));
};};
}
vector::vector(class::std::initializer_list<bool>__il):__begin_(nullptr),__size_(0),__cap_alloc_(0){typename allocator_traits<__xcodeml_template_type_0_0>::size_type __n=static_cast<typename allocator_traits<__xcodeml_template_type_0_0>::size_type>((__il.size()));
if((__n,0)){{(this->__vallocate(__n));
(((__il.begin()),(__il.end())));
};};
}
vector::vector(class::std::initializer_list<bool>__il,__xcodeml_template_type_0_0 const&__a):__begin_(nullptr),__size_(0),__cap_alloc_(0 static_cast<typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_0>,typename allocator_traits<__xcodeml_template_type_0_0>::size_type>::type>(__a)){typename allocator_traits<__xcodeml_template_type_0_0>::size_type __n=static_cast<typename allocator_traits<__xcodeml_template_type_0_0>::size_type>((__il.size()));
if((__n,0)){{(this->__vallocate(__n));
(((__il.begin()),(__il.end())));
};};
}
vector::~vector(){if((this->__begin_,nullptr)){(allocator_traits<typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_0>,typename allocator_traits<__xcodeml_template_type_0_0>::size_type>::type>::.deallocate((()),this->__begin_,(())));};
(this->__invalidate_all_iterators());
}
vector::vector(class vector const&__v):__begin_(nullptr),__size_(0),__cap_alloc_(0(allocator_traits<typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_0>,typename allocator_traits<__xcodeml_template_type_0_0>::size_type>::type>::.select_on_container_copy_construction((__v.__alloc())))){if(((__v.size()),0)){{(this->__vallocate((__v.size())));
(((__v.begin()),(__v.end())));
};};
}
vector::vector(class vector const&__v,__xcodeml_template_type_0_0 const&__a):__begin_(nullptr),__size_(0),__cap_alloc_(0 __a){if(((__v.size()),0)){{(this->__vallocate((__v.size())));
(((__v.begin()),(__v.end())));
};};
}
class vector<bool,__xcodeml_template_type_0_0>&vector::operator=(class vector const&__v){if((this,(&__v))){{((__v));
if(__v.__size_){{if((__v.__size_,(this->capacity()))){{(this->__vdeallocate());
(this->__vallocate(__v.__size_));
};};
(std::__1::(__v.__begin_,(__v.__begin_,(__external_cap_to_internal(__v.__size_))),this->__begin_));
};};
(this->__size_=__v.__size_);
};};
return(*this);
}
vector::vector(class vector<bool,__xcodeml_template_type_0_0>(*__v)):__begin_(__v.__begin_),__size_(__v.__size_),__cap_alloc_((std::(__v.__cap_alloc_))){(__v.__begin_=nullptr);
(__v.__size_=0);
((__v.__cap())=0);
}
vector::vector(class vector<bool,__xcodeml_template_type_0_0>(*__v),__xcodeml_template_type_0_0 const&__a):__begin_(nullptr),__size_(0),__cap_alloc_(0 __a){if((__a,__xcodeml_identity<__xcodeml_template_type_0_0>::t((__v.__alloc())))){{(this.__begin_=__v.__begin_);
(this.__size_=__v.__size_);
((this.__cap())=(__v.__cap()));
(__v.__begin_=nullptr);
((__v.__cap())=(__v.__size_=0));
};}else{if(((__v.size()),0)){{(this->__vallocate((__v.size())));
(((__v.begin()),(__v.end())));
};};};
}
class vector<bool,__xcodeml_template_type_0_0>&vector::operator=(class vector<bool,__xcodeml_template_type_0_0>(*__v)){((__v,__xcodeml_identity<integral_constant<bool,expression> >::t()));
return(*this);
}
void vector::__move_assign(class vector<bool,__xcodeml_template_type_0_0>&__c,class::std::__1::integral_constant<bool,0>){if(((()),(__c.__alloc()))){(((__c.begin()),(__c.end())));}else{((__c,__xcodeml_identity<class::std::__1::integral_constant<bool,1> >::t()));};
}
void vector::__move_assign(class vector<bool,__xcodeml_template_type_0_0>&__c,class::std::__1::integral_constant<bool,1>){(this->__vdeallocate());
((__c));
(this.__begin_=__c.__begin_);
(this.__size_=__c.__size_);
((this.__cap())=(__c.__cap()));
(__c.__begin_=nullptr);
((__c.__cap())=(__c.__size_=0));
}
void vector::assign(typename allocator_traits<__xcodeml_template_type_0_0>::size_type __n,bool const&__x){(this->__size_=0);
if((__n,0)){{typename allocator_traits<__xcodeml_template_type_0_0>::size_type __c=(this->capacity());
if((__n,__c)){(this->__size_=__n);}else{{class vector<bool,__xcodeml_template_type_0_0>__v=(());
(__v.reserve((this->__recommend(__n))));
(__v.__size_=__n);
((__v));
};};
(std::__1::((()),__n,__x));
};};
(this->__invalidate_all_iterators());
}
template<typename __xcodeml_template_type_1_0>typename enable_if<expression,void>::type vector::assign(__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last){(this->clear());
{;for(;(__first,__last);(++__first)){(this->push_back((*__first)));}};
}
template<typename __xcodeml_template_type_1_0>typename enable_if<expression,void>::type vector::assign(__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last){(this->clear());
typename allocator_traits<__xcodeml_template_type_0_0>::difference_type __ns=(std::__1::(__first,__last));
((void)0);
unsigned long const __n=static_cast<typename allocator_traits<__xcodeml_template_type_0_0>::size_type>(__ns);
if(__n){{if((__n,(this->capacity()))){{(this->__vdeallocate());
(this->__vallocate(__n));
};};
((__first,__last));
};};
}
void vector::reserve(typename allocator_traits<__xcodeml_template_type_0_0>::size_type __n){if((__n,(this->capacity()))){{class vector<bool,__xcodeml_template_type_0_0>__v=(this.__alloc());
(__v.__vallocate(__n));
(__v.__construct_at_end((this.begin()),(this.end())));
((__v));
(this->__invalidate_all_iterators());
};};
}
void vector::shrink_to_fit(){if(((__external_cap_to_internal((this->size()))),(()))){{try{(__xcodeml_identity<class vector<bool,__xcodeml_template_type_0_0> >::t((*this),__xcodeml_identity<__xcodeml_template_type_0_0>::t((()))).swap((*this)));
}catch(...){}
;
};};
}
__bit_reference<class vector<bool,__xcodeml_template_type_0_0>,expression>{if((__n,(this->size()))){(this.__throw_out_of_range());};
return((*this))[__n];
}
__bit_const_reference<class vector<bool,__xcodeml_template_type_0_0> >{if((__n,(this->size()))){(this.__throw_out_of_range());};
return((*this))[__n];
}
void vector::push_back(bool const&__x){if((this.__size_,(this.capacity()))){(this->reserve((this->__recommend((this.__size_,1)))));};
(++this.__size_);
((())=__x);
}
__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression>{__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression>;
if(((this->size()),(this->capacity()))){{__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,1,expression> =(());
(++this->__size_);
(std::__1::(__position,__old_end,(())));
(__r=(this->__const_iterator_cast(__position)));
};}else{{class vector<bool,__xcodeml_template_type_0_0>__v=(());
(__v.reserve((this->__recommend((this->__size_,1)))));
(__v.__size_=(this->__size_,1));
(__r=(std::__1::((this->cbegin()),__position,(__v.begin()))));
(std::__1::(__position,(this->cend()),(__v.end())));
((__v));
};};
((*__r)=__x);
return __r;
}
__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression>{__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression>;
typename allocator_traits<__xcodeml_template_type_0_0>::size_type __c=(this->capacity());
if(((__n,__c)&&((this->size()),(__c,__n)))){{__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,1,expression> =(());
(this->__size_+=__n);
(std::__1::(__position,__old_end,(())));
(__r=(this->__const_iterator_cast(__position)));
};}else{{class vector<bool,__xcodeml_template_type_0_0>__v=(());
(__v.reserve((this->__recommend((this->__size_,__n)))));
(__v.__size_=(this->__size_,__n));
(__r=(std::__1::((this->cbegin()),__position,(__v.begin()))));
(std::__1::(__position,(this->cend()),(__v.end())));
((__v));
};};
(std::__1::(__r,__n,__x));
return __r;
}
template<typename __xcodeml_template_type_1_0>typename enable_if<expression,__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression> >::type vector::insert(__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,1,expression>,__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last){typename allocator_traits<__xcodeml_template_type_0_0>::difference_type __off=(__position,(()));
__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression> =(this->__const_iterator_cast(__position));
__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression> =(());
{;for(;(((this->size()),(this->capacity()))&&(__first,__last));(++__first)){{(++this.__size_);
((())=(*__first));
};}};
class vector<bool,__xcodeml_template_type_0_0>__v=(());
if((__first,__last)){{try{(__v.assign(__first,__last));
typename allocator_traits<__xcodeml_template_type_0_0>::difference_type __old_size=static_cast<typename allocator_traits<__xcodeml_template_type_0_0>::difference_type>((__old_end,(())));
typename allocator_traits<__xcodeml_template_type_0_0>::difference_type __old_p=(__p,(()));
(this->reserve((this->__recommend(((this->size()),(__v.size()))))));
(__p=((()),__old_p));
(__old_end=((()),__old_size));
}catch(...){((__old_end,(())));
throw;
}
;
};};
(__p=(std::__1::(__p,__old_end,(()))));
((__p,(__v.begin()),(__v.end())));
return((()),__off);
}
template<typename __xcodeml_template_type_1_0>typename enable_if<expression,__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression> >::type vector::insert(__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,1,expression>,__xcodeml_template_type_1_0 __first,__xcodeml_template_type_1_0 __last){typename allocator_traits<__xcodeml_template_type_0_0>::difference_type const __n_signed=(std::__1::(__first,__last));
((void)0);
typename allocator_traits<__xcodeml_template_type_0_0>::size_type const __n=static_cast<typename allocator_traits<__xcodeml_template_type_0_0>::size_type>(__n_signed);
__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression>;
typename allocator_traits<__xcodeml_template_type_0_0>::size_type __c=(this->capacity());
if(((__n,__c)&&((this->size()),(__c,__n)))){{__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,1,expression> =(());
(this->__size_+=__n);
(std::__1::(__position,__old_end,(())));
(__r=(this->__const_iterator_cast(__position)));
};}else{{class vector<bool,__xcodeml_template_type_0_0>__v=(());
(__v.reserve((this->__recommend((this->__size_,__n)))));
(__v.__size_=(this->__size_,__n));
(__r=(std::__1::((this->cbegin()),__position,(__v.begin()))));
(std::__1::(__position,(this->cend()),(__v.end())));
((__v));
};};
(std::__1::(__first,__last,__r));
return __r;
}
__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression>{__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression> =(this->__const_iterator_cast(__position));
(std::__1::((__position,1),(this.cend()),__r));
(--this->__size_);
return __r;
}
__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression>{__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression> =(this->__const_iterator_cast(__first));
typename allocator_traits<__xcodeml_template_type_0_0>::difference_type __d=(__last,__first);
(std::__1::(__last,(this.cend()),__r));
(this->__size_-=__d);
return __r;
}
void vector::swap(class vector<bool,__xcodeml_template_type_0_0>&__x){(std::__1::(this.__begin_,__x.__begin_));
(std::__1::(this.__size_,__x.__size_));
(std::__1::((this.__cap()),(__x.__cap())));
(((this.__alloc()),(__x.__alloc()),__xcodeml_identity<integral_constant<bool,expression> >::t()));
}
void vector::resize(typename allocator_traits<__xcodeml_template_type_0_0>::size_type __sz,bool __x){typename allocator_traits<__xcodeml_template_type_0_0>::size_type __cs=(this->size());
if((__cs,__sz)){{__bit_iterator<class vector<bool,__xcodeml_template_type_0_0>,0,expression>;
typename allocator_traits<__xcodeml_template_type_0_0>::size_type __c=(this->capacity());
typename allocator_traits<__xcodeml_template_type_0_0>::size_type __n=(__sz,__cs);
if(((__n,__c)&&(__cs,(__c,__n)))){{(__r=(()));
(this->__size_+=__n);
};}else{{class vector<bool,__xcodeml_template_type_0_0>__v=(());
(__v.reserve((this->__recommend((this->__size_,__n)))));
(__v.__size_=(this->__size_,__n));
(__r=(std::__1::((this->cbegin()),(this->cend()),(__v.begin()))));
((__v));
};};
(std::__1::(__r,__n,__x));
};}else{(this->__size_=__sz);};
}
void vector::flip(){typename allocator_traits<__xcodeml_template_type_0_0>::size_type __n=this->__size_;
typename allocator_traits<typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_0>,typename allocator_traits<__xcodeml_template_type_0_0>::size_type>::type>::pointer __p=this->__begin_;
{;for(;(__n,__bits_per_word);((++__p),(__n-=__bits_per_word))){((*__p)=(~(*__p)));}};
if((__n,0)){{typename allocator_traits<__xcodeml_template_type_0_0>::size_type __m=((~__xcodeml_identity<typename allocator_traits<__xcodeml_template_type_0_0>::size_type>::t(0))>>(__bits_per_word,__n));
typename allocator_traits<__xcodeml_template_type_0_0>::size_type __b=((*__p)&__m);
((*__p)&=(~__m));
((*__p)|=((~__b)&__m));
};};
}
bool vector::__invariants()const{if((this.__begin_,nullptr)){{if(((this.__size_,0)||((this.__cap()),0))){return false;};
};}else{{if(((this.__cap()),0)){return false;};
if((this.__size_,(this.capacity()))){return false;};
};};
return true;
}
unsigned long vector::__hash_code()const{unsigned long __h=0;
typename allocator_traits<__xcodeml_template_type_0_0>::size_type __n=this->__size_;
typename allocator_traits<typename __rebind_alloc_helper<allocator_traits<__xcodeml_template_type_0_0>,typename allocator_traits<__xcodeml_template_type_0_0>::size_type>::type>::pointer __p=this->__begin_;
{;for(;(__n,__bits_per_word);((++__p),(__n-=__bits_per_word))){(__h^=(*__p));}};
if((__n,0)){{typename allocator_traits<__xcodeml_template_type_0_0>::size_type const __m=((~__xcodeml_identity<typename allocator_traits<__xcodeml_template_type_0_0>::size_type>::t(0))>>(__bits_per_word,__n));
(__h^=((*__p)&__m));
};};
return __h;
}
template<typename __xcodeml_template_type_0_0>class hash<vector<bool,__xcodeml_template_type_0_0> >:public unary_function<vector<bool,__xcodeml_template_type_0_0>,unsigned long>{public:unsigned long operator()(vector<bool,__xcodeml_template_type_0_0>)const{return(__vec.__hash_code());
}
}
;
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator==(vector<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,vector<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>){typename vector<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>::size_type const __sz=(__x.size());
return((__sz,(__y.size()))&&(std::__1::((__x.begin()),(__x.end()),(__y.begin()))));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator!=(vector<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,vector<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>){return(!(__x,__y));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator<(vector<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,vector<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>){return(std::__1::((__x.begin()),(__x.end()),(__y.begin()),(__y.end())));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator>(vector<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,vector<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>){return(__y,__x);
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator>=(vector<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,vector<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>){return(!(__x,__y));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>bool operator<=(vector<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,vector<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>){return(!(__y,__x));
}
template<typename __xcodeml_template_type_0_0,typename __xcodeml_template_type_0_1>void swap(vector<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>,vector<__xcodeml_template_type_0_0,__xcodeml_template_type_0_1>){(__x.swap(__y));
}
}
}
typedef long fpos_t;
typedef long off_t;
typedef long off64_t;
class __sbuf{public:unsigned char(*_base);
public:int _size;
}
;
class __sFILE{public:unsigned char(*_p);
public:int _r;
public:int _w;
public:short _flags;
public:short _file;
public:class::__sbuf _bf;
public:int _lbfsize;
public:void(*_cookie);
public:int(*_close)(void(*));
public:int(*_read)(void(*),char(*),int);
public:long(*_seek)(void(*),long,int);
public:int(*_write)(void(*),char const(*),int);
public:class::__sbuf _ub;
public:unsigned char(*_up);
public:int _ur;
public:unsigned char _ubuf[3];
public:unsigned char _nbuf[1];
public:class::__sbuf _lb;
public:int _blksize;
public:long _offset;

/* Ignored a member with no access specifier class pthread_mutex;*/

public:class::pthread_mutex(*_fl_mutex);

/* Ignored a member with no access specifier class pthread;*/

public:class::pthread(*_fl_owner);
public:int _fl_count;
public:int _orientation;
public:union::__xcodeml_2 _mbstate;
public:int _flags2;
}
;
extern"C"{void clearerr(class::__sFILE(*));};
extern"C"{int fclose(class::__sFILE(*));};
extern"C"{int feof(class::__sFILE(*));};
extern"C"{int ferror(class::__sFILE(*));};
extern"C"{int fflush(class::__sFILE(*));};
extern"C"{int fgetc(class::__sFILE(*));};
extern"C"{int fgetpos(class::__sFILE(*),long(*));};
extern"C"{char(*fgets(char(*),int,class::__sFILE(*)));};
extern"C"{class::__sFILE(*fopen(char const(*),char const(*)));};
extern"C"{int fprintf(class::__sFILE(*),char const(*),...);};
extern"C"{int fputc(int,class::__sFILE(*));};
extern"C"{int fputs(char const(*),class::__sFILE(*));};
extern"C"{unsigned long fread(void(*),unsigned long,unsigned long,class::__sFILE(*));};
extern"C"{class::__sFILE(*freopen(char const(*),char const(*),class::__sFILE(*)));};
extern"C"{int fscanf(class::__sFILE(*),char const(*),...);};
extern"C"{int fseek(class::__sFILE(*),long,int);};
extern"C"{int fsetpos(class::__sFILE(*),long const(*));};
extern"C"{long ftell(class::__sFILE(*));};
extern"C"{unsigned long fwrite(void const(*),unsigned long,unsigned long,class::__sFILE(*));};
extern"C"{int getc(class::__sFILE(*));};
extern"C"{int getchar();};
extern"C"{char(*gets_s(char(*),unsigned long));};
extern"C"{void perror(char const(*));};
extern"C"{int printf(char const(*),...);};
extern"C"{int putc(int,class::__sFILE(*));};
extern"C"{int putchar(int);};
extern"C"{int puts(char const(*));};
extern"C"{int remove(char const(*));};
extern"C"{int rename(char const(*),char const(*));};
extern"C"{void rewind(class::__sFILE(*));};
extern"C"{int scanf(char const(*),...);};
extern"C"{void setbuf(class::__sFILE(*),char(*));};
extern"C"{int setvbuf(class::__sFILE(*),char(*),int,unsigned long);};
extern"C"{int sprintf(char(*),char const(*),...);};
extern"C"{int sscanf(char const(*),char const(*),...);};
extern"C"{class::__sFILE(*tmpfile());};
extern"C"{char(*tmpnam(char(*)));};
extern"C"{int ungetc(int,class::__sFILE(*));};
extern"C"{int vfprintf(class::__sFILE(*),char const(*),class::__va_list_tag(*));};
extern"C"{int vprintf(char const(*),class::__va_list_tag(*));};
extern"C"{int vsprintf(char(*),char const(*),class::__va_list_tag(*));};
extern"C"{int snprintf(char(*),unsigned long,char const(*),...);};
extern"C"{int vsnprintf(char(*),unsigned long,char const(*),class::__va_list_tag(*));};
extern"C"{int vfscanf(class::__sFILE(*),char const(*),class::__va_list_tag(*));};
extern"C"{int vscanf(char const(*),class::__va_list_tag(*));};
extern"C"{int vsscanf(char const(*),char const(*),class::__va_list_tag(*));};
extern"C"{char(*ctermid(char(*)));};
extern"C"{class::__sFILE(*fdopen(int,char const(*)));};
extern"C"{int fileno(class::__sFILE(*));};
extern"C"{int pclose(class::__sFILE(*));};
extern"C"{class::__sFILE(*popen(char const(*),char const(*)));};
extern"C"{int ftrylockfile(class::__sFILE(*));};
extern"C"{void flockfile(class::__sFILE(*));};
extern"C"{void funlockfile(class::__sFILE(*));};
extern"C"{int getc_unlocked(class::__sFILE(*));};
extern"C"{int getchar_unlocked();};
extern"C"{int putc_unlocked(int,class::__sFILE(*));};
extern"C"{int putchar_unlocked(int);};
extern"C"{void clearerr_unlocked(class::__sFILE(*));};
extern"C"{int feof_unlocked(class::__sFILE(*));};
extern"C"{int ferror_unlocked(class::__sFILE(*));};
extern"C"{int fileno_unlocked(class::__sFILE(*));};
extern"C"{int fseeko(class::__sFILE(*),long,int);};
extern"C"{long ftello(class::__sFILE(*));};
extern"C"{int getw(class::__sFILE(*));};
extern"C"{int putw(int,class::__sFILE(*));};
extern"C"{char(*tempnam(char const(*),char const(*)));};
extern"C"{class::__sFILE(*fmemopen(void(*),unsigned long,char const(*)));};
extern"C"{long getdelim(char(*(*)),unsigned long(*),int,class::__sFILE(*));};
extern"C"{class::__sFILE(*open_memstream(char(*(*)),unsigned long(*)));};
extern"C"{int renameat(int,char const(*),int,char const(*));};
extern"C"{int vdprintf(int,char const(*),class::__va_list_tag(*));};
extern"C"{long getline(char(*(*)),unsigned long(*),class::__sFILE(*));};
extern"C"{int dprintf(int,char const(*),...);};
extern"C"{int asprintf(char(*(*)),char const(*),...);};
extern"C"{char(*ctermid_r(char(*)));};
extern"C"{void fcloseall();};
extern"C"{int fdclose(class::__sFILE(*),int(*));};
extern"C"{char(*fgetln(class::__sFILE(*),unsigned long(*)));};
extern"C"{char const(*fmtcheck(char const(*),char const(*)));};
extern"C"{int fpurge(class::__sFILE(*));};
extern"C"{void setbuffer(class::__sFILE(*),char(*),int);};
extern"C"{int setlinebuf(class::__sFILE(*));};
extern"C"{int vasprintf(char(*(*)),char const(*),class::__va_list_tag(*));};
extern int const sys_nerr;
extern char const(*const sys_errlist);
extern"C"{class::__sFILE(*funopen(void const(*),int(*)(void(*),char(*),int),int(*)(void(*),char const(*),int),long(*)(void(*),long,int),int(*)(void(*))));};
typedef long cookie_read_function_t(void(*),char(*),unsigned long);
typedef long cookie_write_function_t(void(*),char const(*),unsigned long);
typedef int cookie_seek_function_t(void(*),long(*),int);
typedef int cookie_close_function_t(void(*));
class __xcodeml_24{public:long(*read)(void(*),char(*),unsigned long);
public:long(*write)(void(*),char const(*),unsigned long);
public:int(*seek)(void(*),long(*),int);
public:int(*close)(void(*));
}
;
typedef class __xcodeml_24 cookie_io_functions_t;
extern"C"{class::__sFILE(*fopencookie(void(*),char const(*),class __xcodeml_24));};
extern"C"{int ftruncate(int,long);};
extern"C"{long lseek(int,long,int);};
extern"C"{void(*mmap(void(*),unsigned long,int,int,int,long));};
extern"C"{int truncate(char const(*),long);};
extern"C"{int __srget(class::__sFILE(*));};
extern"C"{int __swbuf(int,class::__sFILE(*));};
int __sputc(int _c,class::__sFILE(*_p)){if((((--_p->_w)>=0)||((_p->_w>=_p->_lbfsize)&&(((char)_c)!='\n')))){return((*(_p->_p++))=_c);}else{return(__swbuf(_c,_p));};
}
extern int __isthreaded;

int main(){class::std::__1::vector<int,class::std::__1::allocator<int> >a;
(a.push_back(1));
(printf("%d\n",a.operator[](0)));
return 0;
}

